---
title: Build an app
---

While the [`.app()` method](reference/querychat.qmd#querychat.querychat.app) provides a quick way to start exploring data, building bespoke Shiny apps with querychat unlocks the full power of integrating natural language data exploration with custom visualizations, layouts, and interactivity. This guide shows you how to integrate querychat into your own Shiny applications and leverage its reactive data outputs to create rich, interactive dashboards.

querychat is a particularly good fit for Shiny apps that have:

1. **A single data source** (or a set of related tables that can be joined)
2. **Multiple filters** that let users slice and explore the data in different ways
3. **Several visualizations and outputs** that all depend on the same filtered data

In these apps, querychat can replace or augment your filtering UI by allowing users to describe what they want to see in natural language. Instead of building complex filter controls, users can simply ask questions like "show me customers from California who spent over $1000 last quarter" and querychat will generate the appropriate SQL query.

This is especially valuable when:

- Your data has many columns and building a UI for all possible filters would be overwhelming
- Users want to explore ad-hoc combinations of filters that you didn't anticipate
- You want to make data exploration more accessible to users who aren't comfortable with traditional filtering UIs

If you have an existing app with a reactive data frame that flows through multiple outputs, querychat can be a natural addition to provide an alternative way to filter that data.


## Starter template

Integrating querychat into a Shiny app requires just three steps:

1. Initialize a `querychat()` instance with your data
2. Add the UI component (either `.sidebar()` or `.ui()`)
3. Use reactive values like `.df()`, `.sql()`, and `.title()` to build outputs that respond to user queries

Here's a starter template demonstrating these steps:

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
{{< include /../examples/03-sidebar-express-app.py >}}
```

#### Core

```python
{{< include /../examples/03-sidebar-core-app.py >}}
```


:::

::: callout-note
With Core, you'll need to call the `qc.server()` method within your server function to set up querychat's reactive behavior, and capture its return value to access reactive data. This is not necessary with Express, which handles it automatically and exposes reactive values directly on the `querychat` instance.
:::

## Reactives

There are three main reactive values provided by querychat for use in your app:

### Filtered data {#filtered-data}

The `.df()` method returns the current filtered and/or sorted data frame. This updates whenever the user prompts a filtering or sorting operation through the chat interface (see [Data updating](tools.qmd#data-updating) for details).


::: {.panel-tabset group="shiny-mode"}

#### Express

```python
@render.data_frame
def table():
    return qc.df()  # Returns filtered/sorted data
```

#### Core

```python
qc_vals = qc.server()

@render.data_frame
def table():
    return qc_vals.df()  # Returns filtered/sorted data
```

:::

You can use `.df()` to power any output in your app - visualizations, summary statistics, data tables, and more. When a user asks to "show only survivors" or "sort by age", `.df()` automatically updates, and any outputs that depend on it will re-render.

### SQL query {#sql-query}

The `.sql()` method returns the current SQL query as a string. This is useful for displaying the query to users for transparency and reproducibility:

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
@render.text
def current_query():
    return qc.sql() or "SELECT * FROM my_data"
```

#### Core

```python
qc_vals = qc.server()

@render.text
def current_query():
    return qc_vals.sql() or "SELECT * FROM my_data"
```

:::

You can also use `.sql()` as a setter to programmatically update the query (see [Programmatic filtering](#programmatic-filtering) below).

### Title {#title}

The `.title()` method returns a short description of the current filter, provided by the LLM when it generates a query. For example, if a user asks to "show first-class survivors", the title might be "First-class survivors".

::: {.panel-tabset group="shiny-mode"}

##### Express

```python
@render.text
def card_title():
    return qc.title() or "All Data"
```

#### Core

```python
qc_vals = qc.server()

@render.text
def card_title():
    return qc_vals.title() or "All Data"
```

:::

Returns `None` when no filter is active. You can also use `.title()` as a setter to update the title programmatically.

## Custom UI

In the starter template above, we used the `.sidebar()` method for a simple sidebar layout. In some cases, you might want to place the chat UI somewhere else in your app layout, or just more fully customize what goes in the sidebar. The `.ui()` method is designed for this -- it returns the chat component without additional layout wrappers.

For example here is how to place the chat in a sidebar with some additional controls:

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
from shiny.express import ui, reactive
from querychat.express import QueryChat

qc = QueryChat(data, "my_data")

with ui.sidebar():
    qc.ui()  # Chat component
    ui.hr()
    ui.input_action_button("reset", "Reset Filters", class_="w-100")
```

#### Core

```python
from shiny import ui, reactive
from querychat import QueryChat

qc = QueryChat(data, "my_data")

app_ui = ui.page_sidebar(
    ui.sidebar(
        qc.ui(),  # Chat component
        ui.hr(),
        ui.input_action_button("reset", "Reset Filters", class_="w-100"),
    ),
    # Main content here
)
```

:::

::: callout-tip
### Custom Shiny chat UIs

Learn more about customizing Shiny chat UIs in the [Shiny Chat documentation](https://shiny.posit.co/py/docs/genai-chatbots.html#layout).
:::


## Data views

Thanks to Shiny's support for [Jupyter Widgets](https://shiny.posit.co/py/docs/jupyter-widgets.html) like [Plotly](https://shiny.posit.co/py/components/outputs/plot-plotly/), it's straightforward to create rich data views that depend on querychat data. Here's an example of an app showing both the filtered data and a bar chart depending on that same data:


```python
import plotly.express as px

from shiny.express import render, ui
from shinywidgets import render_plotly

from querychat.express import QueryChat
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic")
qc.sidebar()

with ui.layout_columns():
    with ui.card():
        ui.card_header("Data Table")

        @render.data_frame
        def table():
            return qc.df()

    with ui.card():
        ui.card_header("Survival by Class")

        @render_plotly
        def survival_plot():
            d = qc.df().to_native()  # Convert for pandas groupby()
            summary = d.groupby('pclass')['survived'].mean().reset_index()
            return px.bar(summary, x='pclass', y='survived')
```

Now when a user filters the data through natural language (e.g., "filter to only children"), both the table and the chart update automatically.

![](/images/plotly-data-view.png){fig-alt="Screenshot of a querychat app showing both a data table and a bar chart of survival by class." class="lightbox shadow rounded mb-3"}

A more useful, but slightly more involved example like the one below might incorporate other [Shiny components](https://shiny.posit.co/py/components/) like value boxes to summarize key statistics about the filtered data.

```{.python filename="titanic-dashboard.py" code-fold="true" code-summary="Show app code"}
{{< include _examples/titanic-dashboard.py >}}
```


![](/images/rich-data-views.png){fig-alt="Screenshot of a querychat app showing value boxes, a data table, and multiple plots." class="lightbox shadow rounded mb-3"}


## Programmatic updates

querychat's reactive state can be updated programmatically. For example, you might want to add a "Reset Filters" button that clears any active filters and returns the data table to its original state. You can do this by setting both the SQL query and title to their default values. This way you don't have to rely on both the user and LLM to send the right prompt.

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
ui.input_action_button("reset", "Reset Filters")

@reactive.effect
@reactive.event(input.reset)
def _():
    qc.sql("")
    qc.title(None)
```

#### Core

```python
ui.input_action_button("reset", "Reset Filters")

qc_vals = qc.server()

@reactive.effect
@reactive.event(input.reset)
def _():
    qc_vals.sql.set("")
    qc_vals.title.set(None)
```

:::

This is equivalent to the user asking the LLM to "reset" or "show all data".

## Multiple tables

Currently, you have two options for exploring multiple tables in querychat:

1. Join the tables into a single table before passing to querychat
2. Use multiple querychat instances in the same app

The first option makes it possible to chat with multiple tables inside a single chat interface, whereas the second option requires a separate chat interface for each table.

::: {.callout-note}
### Multiple filtered tables

We plan to support multiple filtered tables in a future release -- if you're interested in this feature, please upvote [the relevant issue](https://github.com/posit-dev/querychat/issues/6)
:::

Here's an example of the second approach, using two separate querychat instances to explore both the `titanic` and `penguins` datasets within the same app:

```{.python filename="multiple-datasets.py" code-fold="true" code-summary="Show app code"}
{{< include _examples/multiple-datasets.py >}}
```

![](/images/multiple-datasets.png){fig-alt="Screenshot of a querychat app with two datasets: titanic and penguins." class="lightbox shadow rounded mb-3"}


## See also

- [Greet users](greet.qmd) - Create welcoming onboarding experiences
- [Provide context](context.qmd) - Help the LLM understand your data better
- [Tools](tools.qmd) - Understand what querychat can do under the hood
