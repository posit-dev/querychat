[
  {
    "objectID": "context.html",
    "href": "context.html",
    "title": "Provide context",
    "section": "",
    "text": "To improve the LLM’s ability to accurately translate natural language queries into SQL, it often helps to provide relevant metadata. Querychat automatically provides things like column names and data types to the LLM, but you can enhance this further with additional context like data descriptions. You can also provide custom instructions to add additional behaviors and even supply a fully custom prompt template, if desired.\nAll of this information is provided to the LLM as part of the system prompt – a string of text containing instructions and context for the LLM to consider when responding to user queries.",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#default-prompt",
    "href": "context.html#default-prompt",
    "title": "Provide context",
    "section": "Default prompt",
    "text": "Default prompt\nFor full visibility into the full system prompt that Querychat generates for the LLM, see the system_prompt property. This is useful for debugging and understanding exactly what context the LLM is using:\nfrom querychat import QueryChat\nfrom seaborn import load_dataset\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nprint(qc.system_prompt)\nBy default, the system prompt contains the following components:\n\nThe basic set of behaviors and guidelines the LLM must follow in order for querychat to work properly, including how to use tools to execute queries and update the app.\nThe SQL schema of the data frame you provided. This includes:\n\nColumn names\nData types (integer, float, boolean, datetime, text)\nFor text columns with less than 10 unique values, we assume they are categorical variables and include the list of values\nFor integer and float columns, we include the range\n\nA data description (if provided via data_description)\nAdditional instructions you want to use to guide querychat’s behavior (if provided via extra_instructions).",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#data-description",
    "href": "context.html#data-description",
    "title": "Provide context",
    "section": "Data description",
    "text": "Data description\nIf your column names are descriptive, Querychat may already work well without additional context. However, if your columns are named x, V1, value, etc., you should provide a data description. Use the data_description parameter for this:\n\n\ntitanic-app.py\n\nfrom pathlib import Path\nfrom querychat import QueryChat\n\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    data_description=Path(\"data_description.md\")\n)\napp = qc.app()\n\nQuerychat doesn’t need this information in any particular format – just provide what a human would find helpful:\n\n\ndata_description.md\n\nThis dataset contains information about Titanic passengers, collected for predicting survival.\n\n- survived: Survival (0 = No, 1 = Yes)\n- pclass: Ticket class (1 = 1st, 2 = 2nd, 3 = 3rd)\n- sex: Sex of passenger\n- age: Age in years\n- sibsp: Number of siblings/spouses aboard\n- parch: Number of parents/children aboard\n- fare: Passenger fare\n- embarked: Port of embarkation (C = Cherbourg, Q = Queenstown, S = Southampton)",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#extra-instructions",
    "href": "context.html#extra-instructions",
    "title": "Provide context",
    "section": "Additional instructions",
    "text": "Additional instructions\nYou can add custom instructions to guide the LLM’s behavior using the extra_instructions parameter:\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    extra_instructions=Path(\"instructions.md\")\n)\nOr as a string:\ninstructions = \"\"\"\n- Use British spelling conventions\n- Stay on topic and only discuss the data dashboard\n- Refuse to answer unrelated questions\n\"\"\"\n\nqc = QueryChat(titanic, \"titanic\", extra_instructions=instructions)\n\n\n\n\n\n\nWarning\n\n\n\nLLMs may not always follow your instructions perfectly. Test extensively when changing instructions or models.",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#custom-template",
    "href": "context.html#custom-template",
    "title": "Provide context",
    "section": "Custom template",
    "text": "Custom template\nIf you want more control over the system prompt, you can provide a custom prompt template using the prompt_template parameter. This is for more advanced users who want to fully customize the LLM’s behavior. See the API reference for details on the available template variables.",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "data-sources.html",
    "href": "data-sources.html",
    "title": "Data Sources",
    "section": "",
    "text": "querychat supports many types of data sources, including:\nThe sections below describe how to use each type of data source with querychat.",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#data-frames",
    "href": "data-sources.html#data-frames",
    "title": "Data Sources",
    "section": "Data frames",
    "text": "Data frames\nYou can use any narwhals-compatible data frame as a data source in querychat. This includes popular data frame libraries like pandas, polars, pyarrow, and many more.\n\nPandasPolarsPyarrow\n\n\n\n\npandas-app.py\n\nimport pandas as pd\nfrom querychat import QueryChat\n\nmtcars = pd.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n)\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\n\npolars-app.py\n\nimport polars as pl\nfrom querychat import QueryChat\n\nmtcars = pl.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n)\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\n\npyarrow-app.py\n\nimport pyarrow as pa\nimport pyarrow.csv as pv\nfrom querychat import QueryChat\n\nmtcars = pv.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n).to_table()\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\nIf you’re building an app, note you can read the queried data frame reactively using the df() method, which returns a pandas.DataFrame by default.",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#databases",
    "href": "data-sources.html#databases",
    "title": "Data Sources",
    "section": "Databases",
    "text": "Databases\nYou can also connect querychat directly to any database supported by SQLAlchemy. This includes popular databases like SQLite, DuckDB, PostgreSQL, MySQL, and many more.\nAssuming you have a database set up and accessible, you can pass a SQLAlchemy database URL to create_engine(), and then pass the resulting engine to QueryChat. Below are some examples for common databases.\n\nDuck DBSQLitePostgreSQLMySQL\n\n\npip install duckdb duckdb-engine\n\n\nduckdb-app.py\n\nfrom pathlib import Path\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\n# Assumes my_database.duckdb is in the same directory as this script\ndb_path = Path(__file__).parent / \"my_database.duckdb\"\nengine = create_engine(f\"duckdb:///{db_path}\")\n\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\n\n\nsqlite-app.py\n\nfrom pathlib import Path\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\n# Assumes my_database.db is in the same directory as this script\ndb_path = Path(__file__).parent / \"my_database.db\"\nengine = create_engine(f\"sqlite:///{db_path}\")\n\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\npip install psycopg2-binary\n\n\npostgresql-app.py\n\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\nengine = create_engine(\"postgresql+psycopg2://user:password@localhost:5432/mydatabase\")\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\npip install pymysql\n\n\nmysql-app.py\n\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\nengine = create_engine(\"mysql+pymysql://user:password@localhost:3306/mydatabase\")\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\n\nIf you don’t have a database set up, you can easily create a local DuckDB database from a CSV file using the following code:\n\n\ncreate-duckdb.py\n\nimport duckdb\n\nconn = duckdb.connect(\"my_database.duckdb\")\n\nconn.execute(\"\"\"\n    CREATE TABLE my_table AS\n    SELECT * FROM read_csv_auto('path/to/your/file.csv')\n\"\"\")\n\nOr, if you have a pandas DataFrame, you can create the DuckDB database like so:\n\n\ncreate-duckdb-from-pandas.py\n\nimport duckdb\nimport pandas as pd\n\nfrom seaborn import load_dataset\ntitanic = load_dataset(\"titanic\")\n\nconn = duckdb.connect(\"my_database.duckdb\")\nconn.register('titanic_df', titanic)\nconn.execute(\"\"\"\n    CREATE TABLE titanic AS\n    SELECT * FROM titanic_df\n\"\"\")\n\nThen you can connect to this database using the DuckDB example above (changing the table name as appropriate):",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#custom-sources",
    "href": "data-sources.html#custom-sources",
    "title": "Data Sources",
    "section": "Custom sources",
    "text": "Custom sources\nIf you have a custom data source that doesn’t fit into the above categories, you can implement the DataSource interface/protocol. This requires implementing methods for getting schema information and executing queries.",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html",
    "href": "reference/tools.tool_update_dashboard.html",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "tool_update_dashboard(data_source, current_query, current_title)\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\ncurrent_query\nReactiveString\nReactive value for storing the current SQL query\nrequired\n\n\ncurrent_title\nReactiveStringOrNone\nReactive value for storing the current title\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html#parameters",
    "href": "reference/tools.tool_update_dashboard.html#parameters",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\ncurrent_query\nReactiveString\nReactive value for storing the current SQL query\nrequired\n\n\ncurrent_title\nReactiveStringOrNone\nReactive value for storing the current title\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html#returns",
    "href": "reference/tools.tool_update_dashboard.html#returns",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html",
    "href": "reference/tools.tool_reset_dashboard.html",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "tool_reset_dashboard(current_query, current_title)\nCreate a tool that resets the dashboard to show all data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurrent_query\nReactiveString\nReactive value for storing the current SQL query\nrequired\n\n\ncurrent_title\nReactiveStringOrNone\nReactive value for storing the current title\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html#parameters",
    "href": "reference/tools.tool_reset_dashboard.html#parameters",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncurrent_query\nReactiveString\nReactive value for storing the current SQL query\nrequired\n\n\ncurrent_title\nReactiveStringOrNone\nReactive value for storing the current title\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html#returns",
    "href": "reference/tools.tool_reset_dashboard.html#returns",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html",
    "href": "reference/tools.tool_query.html",
    "title": "tools.tool_query",
    "section": "",
    "text": "tool_query(data_source)\nCreate a tool that performs a SQL query on the data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html#parameters",
    "href": "reference/tools.tool_query.html#parameters",
    "title": "tools.tool_query",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html#returns",
    "href": "reference/tools.tool_query.html#returns",
    "title": "tools.tool_query",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/QueryChat.html",
    "href": "reference/QueryChat.html",
    "title": "QueryChat",
    "section": "",
    "text": "QueryChat(\n    data_source,\n    table_name,\n    *,\n    id=None,\n    greeting=None,\n    client=None,\n    data_description=None,\n    categorical_threshold=10,\n    extra_instructions=None,\n    prompt_template=None,\n)\nCreate a QueryChat instance.\n\n\nfrom querychat import QueryChat\n\nqc = QueryChat(my_dataframe, \"my_data\")\nqc.app()\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n10\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nserver\nInitialize Shiny server logic.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nQueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nQueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nQueryChat.server(enable_bookmarking=False)\nInitialize Shiny server logic.\nThis method is intended for use in Shiny Code mode, where the user must explicitly call .server() within the Shiny server function. In Shiny Express mode, you can use querychat.express.QueryChat instead of querychat.QueryChat, which calls .server() automatically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenable_bookmarking\nbool\nWhether to enable bookmarking for the querychat module.\nFalse\n\n\n\n\n\n\nfrom shiny import App, render, ui\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\n\n\ndef app_ui(request):\n    return ui.page_sidebar(\n        qc.sidebar(),\n        ui.card(\n            ui.card_header(ui.output_text(\"title\")),\n            ui.output_data_frame(\"data_table\"),\n        ),\n        title=\"Titanic QueryChat App\",\n        fillable=True,\n    )\n\n\ndef server(input, output, session):\n    qc_vals = qc.server(enable_bookmarking=True)\n\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"My Data\"\n\n\napp = App(app_ui, server, bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nServerValues\nA ServerValues dataclass containing session-specific reactive values and the chat client. See ServerValues documentation for details on the available attributes.\n\n\n\n\n\n\n\nQueryChat.sidebar(width=400, height='100%', **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nQueryChat.ui(**kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#examples",
    "href": "reference/QueryChat.html#examples",
    "title": "QueryChat",
    "section": "",
    "text": "from querychat import QueryChat\n\nqc = QueryChat(my_dataframe, \"my_data\")\nqc.app()",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#parameters",
    "href": "reference/QueryChat.html#parameters",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n10\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#attributes",
    "href": "reference/QueryChat.html#attributes",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#methods",
    "href": "reference/QueryChat.html#methods",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nserver\nInitialize Shiny server logic.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nQueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nQueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nQueryChat.server(enable_bookmarking=False)\nInitialize Shiny server logic.\nThis method is intended for use in Shiny Code mode, where the user must explicitly call .server() within the Shiny server function. In Shiny Express mode, you can use querychat.express.QueryChat instead of querychat.QueryChat, which calls .server() automatically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenable_bookmarking\nbool\nWhether to enable bookmarking for the querychat module.\nFalse\n\n\n\n\n\n\nfrom shiny import App, render, ui\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\n\n\ndef app_ui(request):\n    return ui.page_sidebar(\n        qc.sidebar(),\n        ui.card(\n            ui.card_header(ui.output_text(\"title\")),\n            ui.output_data_frame(\"data_table\"),\n        ),\n        title=\"Titanic QueryChat App\",\n        fillable=True,\n    )\n\n\ndef server(input, output, session):\n    qc_vals = qc.server(enable_bookmarking=True)\n\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"My Data\"\n\n\napp = App(app_ui, server, bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nServerValues\nA ServerValues dataclass containing session-specific reactive values and the chat client. See ServerValues documentation for details on the available attributes.\n\n\n\n\n\n\n\nQueryChat.sidebar(width=400, height='100%', **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nQueryChat.ui(**kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html",
    "href": "reference/types.DataSource.html",
    "title": "types.DataSource",
    "section": "",
    "text": "DataSource()\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntable_name\nstr\nName of the table to be used in SQL queries.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nName for the database behind the SQL execution.\n\n\nget_schema\nReturn schema information about the table as a string.\n\n\n\n\n\ntypes.DataSource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_db_type()\nName for the database behind the SQL execution.\n\n\n\ntypes.DataSource.get_schema(categorical_threshold)\nReturn schema information about the table as a string.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA string containing the schema information in a format suitable for prompting an LLM about the data structure",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html#attributes",
    "href": "reference/types.DataSource.html#attributes",
    "title": "types.DataSource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntable_name\nstr\nName of the table to be used in SQL queries.",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html#methods",
    "href": "reference/types.DataSource.html#methods",
    "title": "types.DataSource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nName for the database behind the SQL execution.\n\n\nget_schema\nReturn schema information about the table as a string.\n\n\n\n\n\ntypes.DataSource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_db_type()\nName for the database behind the SQL execution.\n\n\n\ntypes.DataSource.get_schema(categorical_threshold)\nReturn schema information about the table as a string.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA string containing the schema information in a format suitable for prompting an LLM about the data structure",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "build.html",
    "href": "build.html",
    "title": "Build an app",
    "section": "",
    "text": "While the .app() method provides a quick way to start exploring data, building bespoke Shiny apps with QueryChat unlocks the full power of integrating natural language data exploration with custom visualizations, layouts, and interactivity. This guide shows you how to integrate QueryChat into your own Shiny applications and leverage its reactive data outputs to create rich, interactive dashboards.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#starter-template",
    "href": "build.html#starter-template",
    "title": "Build an app",
    "section": "Starter template",
    "text": "Starter template\nIntegrating QueryChat into a Shiny app requires just three steps:\n\nInitialize a QueryChat() instance with your data\nAdd the QueryChat UI component (either .sidebar() or .ui())\nUse reactive values like .df(), .sql(), and .title() to build outputs that respond to user queries\n\nHere’s a starter template demonstrating these steps:\n\nExpressCore\n\n\nfrom seaborn import load_dataset\nfrom shiny.express import render, ui\nfrom querychat.express import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\n# 1. Provide data source to QueryChat\nqc = QueryChat(titanic, \"titanic\")\n\n# 2. Add sidebar chat control\nqc.sidebar()\n\n# 3. Add a card with reactive title and data frame\nwith ui.card():\n    with ui.card_header():\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n    \n# 4. Set some page options (optional)\nui.page_opts(\n    fillable=True,\n    title=\"Titanic Dataset Explorer\"\n)\n\n\nfrom seaborn import load_dataset\nfrom shiny import App, render, ui\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\n# 1. Provide data source to QueryChat\nqc = QueryChat(titanic, \"titanic\")\n\napp_ui = ui.page_sidebar(\n    # 2. Create sidebar chat control\n    qc.sidebar(),\n    ui.card(\n        ui.card_header(ui.output_text(\"title\")),\n        ui.output_data_frame(\"data_table\"),\n        fill=True,\n    ),\n    fillable=True\n)\n\n\ndef server(input, output, session):\n    # 3. Add server logic (to get reactive data frame and title)\n    qc_vals = qc.server()\n\n    # 4. Use the filtered/sorted data frame reactively\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"Titanic Dataset\"\n\n\napp = App(app_ui, server)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWith Core, you’ll need to call the qc.server() method within your server function to set up QueryChat’s reactive behavior, and capture its return value to access reactive data. This is not necessary with Express, which handles it automatically and exposes reactive values directly on the QueryChat instance.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#reactives",
    "href": "build.html#reactives",
    "title": "Build an app",
    "section": "Reactives",
    "text": "Reactives\nThere are three main reactive values provided by QueryChat for use in your app:\n\nFiltered data\nThe .df() method returns the current filtered and/or sorted data frame. This updates whenever the user prompts a filtering or sorting operation through the chat interface (see Data updating for details).\n\nExpressCore\n\n\n@render.data_frame\ndef table():\n    return qc.df()  # Returns filtered/sorted data\n\n\nqc_vals = qc.server()\n\n@render.data_frame\ndef table():\n    return qc_vals.df()  # Returns filtered/sorted data\n\n\n\nYou can use .df() to power any output in your app - visualizations, summary statistics, data tables, and more. When a user asks to “show only survivors” or “sort by age”, .df() automatically updates, and any outputs that depend on it will re-render.\n\n\nSQL query\nThe .sql() method returns the current SQL query as a string. This is useful for displaying the query to users for transparency and reproducibility:\n\nExpressCore\n\n\n@render.text\ndef current_query():\n    return qc.sql() or \"SELECT * FROM my_data\"\n\n\nqc_vals = qc.server()\n\n@render.text\ndef current_query():\n    return qc_vals.sql() or \"SELECT * FROM my_data\"\n\n\n\nYou can also use .sql() as a setter to programmatically update the query (see Programmatic filtering below).\n\n\nTitle\nThe .title() method returns a short description of the current filter, provided by the LLM when it generates a query. For example, if a user asks to “show first-class survivors”, the title might be “First-class survivors”.\n\nExpress\n\n\n@render.text\ndef card_title():\n    return qc.title() or \"All Data\"\n\nCore\nqc_vals = qc.server()\n\n@render.text\ndef card_title():\n    return qc_vals.title() or \"All Data\"\n\n\n\n\nReturns None when no filter is active. You can also use .title() as a setter to update the title programmatically.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#custom-ui",
    "href": "build.html#custom-ui",
    "title": "Build an app",
    "section": "Custom UI",
    "text": "Custom UI\nIn the starter template above, we used the .sidebar() method for a simple sidebar layout. In some cases, you might want to place the chat UI somewhere else in your app layout, or just more fully customize what goes in the sidebar. The .ui() method is designed for this – it returns the chat component without additional layout wrappers.\nFor example here is how to place the chat in a sidebar with some additional controls:\n\nExpressCore\n\n\nfrom shiny.express import ui, reactive\nfrom querychat.express import QueryChat\n\nqc = QueryChat(data, \"my_data\")\n\nwith ui.sidebar():\n    qc.ui()  # Chat component\n    ui.hr()\n    ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\")\n\n\nfrom shiny import ui, reactive\nfrom querychat import QueryChat\n\nqc = QueryChat(data, \"my_data\")\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        qc.ui(),  # Chat component\n        ui.hr(),\n        ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\"),\n    ),\n    # Main content here\n)\n\n\n\n\n\n\n\n\n\nCustom Shiny chat UIs\n\n\n\nLearn more about customizing Shiny chat UIs in the Shiny Chat documentation.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#data-views",
    "href": "build.html#data-views",
    "title": "Build an app",
    "section": "Data views",
    "text": "Data views\nThanks to Shiny’s support for Jupyter Widgets like Plotly, it’s straightforward to create rich data views that depend on QueryChat data. Here’s an example of an app showing both the filtered data and a bar chart depending on that same data:\nimport plotly.express as px\n\nfrom seaborn import load_dataset\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\n\nfrom querychat.express import QueryChat\n\ntitanic = load_dataset(\"titanic\")\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Data Table\")\n\n        @render.data_frame\n        def table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render_plotly\n        def survival_plot():\n            d = qc.df()\n            summary = d.groupby('pclass')['survived'].mean().reset_index()\n            return px.bar(summary, x='pclass', y='survived')\nNow when a user filters the data through natural language (e.g., “filter to only children”), both the table and the chart update automatically.\n\nA more useful, but slightly more involved example like the one below might incorporate other Shiny components like value boxes to summarize key statistics about the filtered data.\n\n\napp.py\n\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom faicons import icon_svg\nimport plotly.express as px\n\ntitanic = load_dataset(\"titanic\")\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.layout_column_wrap(fill=False):\n    with ui.value_box(showcase=icon_svg(\"users\")):\n        \"Passengers\"\n\n        @render.text\n        def count():\n            return str(len(qc.df()))\n\n    with ui.value_box(showcase=icon_svg(\"heart\")):\n        \"Survival Rate\"\n\n        @render.text\n        def survival():\n            rate = qc.df()['survived'].mean() * 100\n            return f\"{rate:.1f}%\"\n\n    with ui.value_box(showcase=icon_svg(\"coins\")):\n        \"Avg Fare\"\n\n        @render.text\n        def fare():\n            avg = qc.df()['fare'].mean()\n            return f\"${avg:.2f}\"\n\nwith ui.layout_columns():\n    with ui.card():\n        with ui.card_header():\n            \"Data Table\"\n\n            @render.text\n            def table_title():\n                return f\" - {qc.title()}\" if qc.title() else \"\"\n\n        @render.data_frame\n        def data_table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render_plotly\n        def survival_by_class():\n            df = qc.df()\n            summary = df.groupby('pclass')['survived'].mean().reset_index()\n            return px.bar(\n                summary,\n                x='pclass',\n                y='survived',\n                labels={'pclass': 'Class', 'survived': 'Survival Rate'},\n            )\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Age Distribution\")\n\n        @render_plotly\n        def age_dist():\n            df = qc.df()\n            return px.histogram(df, x='age', nbins=30)\n\n    with ui.card():\n        ui.card_header(\"Fare by Class\")\n\n        @render_plotly\n        def fare_by_class():\n            df = qc.df()\n            return px.box(df, x='pclass', y='fare', color='survived')\n\nui.page_opts(\n    title=\"Titanic Survival Analysis\",\n    fillable=True,\n    class_=\"bslib-page-dashboard\",\n)",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#programmatic-updates",
    "href": "build.html#programmatic-updates",
    "title": "Build an app",
    "section": "Programmatic updates",
    "text": "Programmatic updates\nQueryChat’s reactive state can be updated programmatically. For example, you might want to add a “Reset Filters” button that clears any active filters and returns the data table to its original state. You can do this by setting both the SQL query and title to their default values. This way you don’t have to rely on both the user and LLM to send the right prompt.\n\nExpressCore\n\n\nui.input_action_button(\"reset\", \"Reset Filters\")\n\n@reactive.effect\n@reactive.event(input.reset)\ndef _():\n    qc.sql(\"\")\n    qc.title(None)\n\n\nui.input_action_button(\"reset\", \"Reset Filters\")\n\nqc_vals = qc.server()\n\n@reactive.effect\n@reactive.event(input.reset)\ndef _():\n    qc_vals.sql.set(\"\")\n    qc_vals.title.set(None)\n\n\n\nThis is equivalent to the user asking the LLM to “reset” or “show all data”.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#multiple-datasets",
    "href": "build.html#multiple-datasets",
    "title": "Build an app",
    "section": "Multiple datasets",
    "text": "Multiple datasets\nYou can use multiple QueryChat instances in a single app to explore different datasets. Just ensure each instance has a different table name (or id which derives the table name) to avoid conflicts. Here’s an example with two datasets:\nfrom seaborn import load_dataset\nfrom shiny.express import render, ui\nfrom querychat.express import QueryChat\n\ntitanic = load_dataset(\"titanic\")\npenguins = load_dataset(\"penguins\")\n\nqc_titanic = QueryChat(titanic, \"titanic\")\nqc_penguins = QueryChat(penguins, \"penguins\")\n\nwith ui.sidebar():\n    with ui.panel_conditional(\"input.navbar == 'Titanic'\"):\n        qc_titanic.ui()\n    with ui.panel_conditional(\"input.navbar == 'Penguins'\"):\n        qc_penguins.ui()\n\nwith ui.nav_panel(\"Titanic\"):\n    @render.data_frame\n    def titanic_table():\n        return qc_titanic.df()\n\nwith ui.nav_panel(\"Penguins\"):\n    @render.data_frame\n    def penguins_table():\n        return qc_penguins.df()\n\nui.page_opts(\n    id=\"navbar\",\n    title=\"Multiple Datasets with QueryChat\",\n    fillable=True,\n)",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#complete-example",
    "href": "build.html#complete-example",
    "title": "Build an app",
    "section": "Complete example",
    "text": "Complete example\nHere’s a complete example bringing together multiple concepts - a Titanic survival analysis dashboard with natural language exploration, coordinated visualizations, and custom controls:\nfrom shiny.express import render, ui\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nimport plotly.express as px\n\n# Load data\ntitanic = load_dataset(\"titanic\")\n\n# Create QueryChat\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    data_description=\"Titanic passenger data with survival outcomes\",\n)\n\n# Page configuration\nui.page_opts(\n    title=\"Titanic Survival Analysis\",\n    fillable=True,\n    class_=\"bslib-page-dashboard\",\n)\n\n# Create sidebar with chat\nwith ui.sidebar(width=400):\n    qc.ui()\n    ui.hr()\n    ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\")\n\n# Summary cards\nwith ui.layout_columns():\n    with ui.value_box(showcase=ui.icon(\"users\")):\n        \"Passengers\"\n\n        @render.text\n        def count():\n            return str(len(qc.df()))\n\n    with ui.value_box(showcase=ui.icon(\"heart\")):\n        \"Survival Rate\"\n\n        @render.text\n        def survival():\n            rate = qc.df()['survived'].mean() * 100\n            return f\"{rate:.1f}%\"\n\n    with ui.value_box(showcase=ui.icon(\"coins\")):\n        \"Avg Fare\"\n\n        @render.text\n        def fare():\n            avg = qc.df()['fare'].mean()\n            return f\"${avg:.2f}\"\n\n# Main content area with visualizations\nwith ui.layout_columns():\n    with ui.card():\n        with ui.card_header():\n            \"Data Table\"\n\n            @render.text\n            def table_title():\n                return f\" - {qc.title()}\" if qc.title() else \"\"\n\n        @render.data_frame\n        def data_table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render.plot\n        def survival_by_class():\n            df = qc.df()\n            summary = df.groupby('pclass')['survived'].mean().reset_index()\n            fig = px.bar(\n                summary,\n                x='pclass',\n                y='survived',\n                labels={'pclass': 'Class', 'survived': 'Survival Rate'},\n            )\n            return fig\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Age Distribution\")\n\n        @render.plot\n        def age_dist():\n            df = qc.df()\n            fig = px.histogram(df, x='age', nbins=30)\n            return fig\n\n    with ui.card():\n        ui.card_header(\"Fare by Class\")\n\n        @render.plot\n        def fare_by_class():\n            df = qc.df()\n            fig = px.box(df, x='pclass', y='fare', color='survived')\n            return fig\n\n# Reset button handler\n@reactive.effect\n@reactive.event(input.reset)\ndef handle_reset():\n    qc.sql(\"\")\n    qc.title(None)\n    ui.notification_show(\"Filters cleared\", type=\"message\")\nThis dashboard demonstrates: - Natural language filtering through chat - Multiple coordinated views (cards, table, plots) - Custom reset button alongside natural language - Dynamic titles reflecting current state - Responsive layout that updates together",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#see-also",
    "href": "build.html#see-also",
    "title": "Build an app",
    "section": "See also",
    "text": "See also\n\nGreet users - Create welcoming onboarding experiences\nProvide context - Help the LLM understand your data better\nTools - Understand what QueryChat can do under the hood",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Explore data using natural language queries\nQuerychat makes it easy to explore data with natural language through the power of Shiny and large language models (LLMs). Start chatting with your data in just one line of code. Or, with a few more lines, design your own rich user experience around data exploration and analysis through natural language.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Introduction",
    "section": "Installation",
    "text": "Installation\nInstall the latest stable release from PyPI:\npip install querychat",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Introduction",
    "section": "Quick start",
    "text": "Quick start\nThe main entry point is the QueryChat class. It requires a data source (e.g., pandas, polars, etc) and a name for the data. It also accepts optional parameters to customize the behavior, such as the client model. The quickest way to start chatting is to call the .app() method, which returns a Shiny app object.\n\n\ntitanic-app.py\n\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\nqc = QueryChat(titanic, \"titanic\", client=\"openai/gpt-4.1\")\napp = qc.app()\n\nWith the above code saved to titanic-app.py and an API key set1, you can run the app from a terminal (or VSCode):\nexport OPENAI_API_KEY=\"your_api_key_here\"\nshiny run --reload titanic-app.py\nOnce running, you’ll notice 3 main views:\n\nA sidebar chat with suggestions on where to start exploring.\nA data table that updates to reflect filtering and sorting queries.\nThe SQL query behind the data table, for transparency and reproducibility.\n\n\nSuppose we pick a suggestion like “Show me passengers who survived”. Since this is a filtering operation, both the data table and SQL query update accordingly.\n\nQuerychat can also handle more general questions about the data that require calculations and aggregations. For example, we can ask “What is the average age of passengers who survived?”. In this case, querychat will generate/execute the SQL query to perform the relevant calculation, and return the result in the chat:\n\nAs you’ll learn later in Build an app, you can also access the SQL query and filtered/sorted data frame programmatically for use elsewhere in your app. This makes it rather seemless to have natural language interaction with your data alongside other visualizations and analyses.\nBefore we build though, let’s take a moment to better understand how querychat works under the hood, and whether it’s right for you.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "Introduction",
    "section": "How it works",
    "text": "How it works\nQuerychat leverages LLMs incredible capability to translate natural language into SQL queries. Frontier models are shockingly good at this task, but even the best models still need to know the overall data structure to perform well. For this reason, querychat supplies a system prompt with the schema of the data (i.e., column names, types, ranges, etc), but never the raw data itself.\nWhen the LLM generates a SQL query, querychat executes it against a SQL database (DuckDB2 by default) to get results in a safe, reliable, and verifiable manner. In short, this execution is safe since only SELECT statements are allowed, reliable since the database engine handles all calculations, and verifiable since the user can always see the SQL query that was run. This makes querychat a trustworthy tool for data exploration, as every action taken by the LLM is transparent and independently reproducible.\n\n\n\n\n\n\nData privacy\n\n\n\nSee the Provide context and Tools articles to learn more about what information is provided to the LLM and what it’s capable of doing with code execution.\n\n\n\nBespoke interfaces\nWhile the quickstart app is a great way to get started, querychat is designed to be highly extensible. You can not only customize the underlying model and data source, but also build fully custom Shiny apps around the core chat functionality.\nFor a motivating example, consider the following (sidebot) app that leverages querychat’s tooling to create reactive summaries and visualizations based on the user’s natural language queries:",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#next-steps",
    "href": "index.html#next-steps",
    "title": "Introduction",
    "section": "Next steps",
    "text": "Next steps\nFrom here, you might want to learn more about:\n\nModels: customize the LLM behind querychat.\nData sources: different data sources you can use with querychat.\nProvide context: provide the LLM with the context it needs to work well.\nBuild an app: design a custom Shiny app around querychat.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Introduction",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBy default, Querychat uses OpenAI to power the chat experience. So, for this example to work, you’ll need an OpenAI API key. See the Models page for details on how to set up credentials for other model providers.↩︎\nDuckdb is extremely fast and has a surprising number of statistical functions.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Changelog",
    "section": "",
    "text": "All notable changes to this project will be documented in this file.\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.\n\n\n\n\n\nThe entire functional API (i.e., init(), sidebar(), server(), etc) has been hard deprecated in favor of a simpler OOP-based API. Namely, the new QueryChat() class is now the main entry point (instead of init()) and has methods to replace old functions (e.g., .sidebar(), .server(), etc). (#101)\n\n\n\n\n\nNew QueryChat.app() method enables quicker/easier chatting with a dataset. (#104)\nEnabled bookmarking by default in both .app() and .server() methods. In latter case, you’ll need to also specify the bookmark_store (either in shiny.App() or shiny.express.app_opts()) for it to take effect. (#104)\nThe current SQL query and title can now be programmatically set through the .sql() and .title() methods of QueryChat(). (#98, #101)\nAdded a .generate_greeting() method to help you create a greeting message for your querychat bot. (#87)\nAdded querychat_reset_dashboard() tool for easily resetting the dashboard filters when asked by the user. (#81)\n\n\n\n\n\nAdded rich tool UI support using shinychat development version and chatlas &gt;= 0.11.1. (#67)\nquerychat’s system prompt and tool descriptions were rewritten for clarity and future extensibility. (#90)\n\n\n\n\n\n\nFixed another issue with data sources that aren’t already narwhals DataFrames (#83)\n\n\n\n\n\nFixed an issue with the query tool when used with SQLAlchemy data sources. (@npelikan #79)\n\n\n\n\n\nquerychat.init() now accepts a client argument, replacing the previous create_chat_callback argument. (#60)\nThe client can be:\n\na chatlas.Chat object,\na function that returns a chatlas.Chat object,\nor a provider-model string, e.g. \"openai/gpt-4.1\", to be passed to chatlas.ChatAuto().\n\nIf client is not provided, querychat will use the QUERYCHAT_CLIENT environment variable, which should be a provider-model string. If the envvar is not set, querychat uses OpenAI with the default model from chatlas.ChatOpenAI().\nquerychat.ui() now adds a .querychat class to the chat container and querychat.sidebar() adds a .querychat-sidebar class to the sidebar, allowing for easier customization via CSS. (#68)\n\n\n\n\nThis first release of the querychat package."
  },
  {
    "objectID": "CHANGELOG.html#unreleased",
    "href": "CHANGELOG.html#unreleased",
    "title": "Changelog",
    "section": "",
    "text": "The entire functional API (i.e., init(), sidebar(), server(), etc) has been hard deprecated in favor of a simpler OOP-based API. Namely, the new QueryChat() class is now the main entry point (instead of init()) and has methods to replace old functions (e.g., .sidebar(), .server(), etc). (#101)\n\n\n\n\n\nNew QueryChat.app() method enables quicker/easier chatting with a dataset. (#104)\nEnabled bookmarking by default in both .app() and .server() methods. In latter case, you’ll need to also specify the bookmark_store (either in shiny.App() or shiny.express.app_opts()) for it to take effect. (#104)\nThe current SQL query and title can now be programmatically set through the .sql() and .title() methods of QueryChat(). (#98, #101)\nAdded a .generate_greeting() method to help you create a greeting message for your querychat bot. (#87)\nAdded querychat_reset_dashboard() tool for easily resetting the dashboard filters when asked by the user. (#81)\n\n\n\n\n\nAdded rich tool UI support using shinychat development version and chatlas &gt;= 0.11.1. (#67)\nquerychat’s system prompt and tool descriptions were rewritten for clarity and future extensibility. (#90)"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "Changelog",
    "section": "",
    "text": "Fixed another issue with data sources that aren’t already narwhals DataFrames (#83)"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "Changelog",
    "section": "",
    "text": "Fixed an issue with the query tool when used with SQLAlchemy data sources. (@npelikan #79)"
  },
  {
    "objectID": "CHANGELOG.html#section-2",
    "href": "CHANGELOG.html#section-2",
    "title": "Changelog",
    "section": "",
    "text": "querychat.init() now accepts a client argument, replacing the previous create_chat_callback argument. (#60)\nThe client can be:\n\na chatlas.Chat object,\na function that returns a chatlas.Chat object,\nor a provider-model string, e.g. \"openai/gpt-4.1\", to be passed to chatlas.ChatAuto().\n\nIf client is not provided, querychat will use the QUERYCHAT_CLIENT environment variable, which should be a provider-model string. If the envvar is not set, querychat uses OpenAI with the default model from chatlas.ChatOpenAI().\nquerychat.ui() now adds a .querychat class to the chat container and querychat.sidebar() adds a .querychat-sidebar class to the sidebar, allowing for easier customization via CSS. (#68)"
  },
  {
    "objectID": "CHANGELOG.html#section-3",
    "href": "CHANGELOG.html#section-3",
    "title": "Changelog",
    "section": "",
    "text": "This first release of the querychat package."
  },
  {
    "objectID": "models.html",
    "href": "models.html",
    "title": "Models",
    "section": "",
    "text": "Under the hood, querychat is powered by chatlas, a library for building chat-based applications with large language models (LLMs). chatlas supports a wide range of LLM providers – see here for a full list.\n\nSpecify a model\nTo use a particular model, pass a \"{provider}/{model}\" string to the client parameter. Under the hood, this gets passed along to chatlas.ChatAuto\nfrom querychat import QueryChat\nfrom seaborn import load_dataset\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    client=\"anthropic/claude-sonnet-4-5\"\n)\nAnd, if you’d like to effectively set a new default model, you can use the QUERYCHAT_CLIENT environment variable.\nexport QUERYCHAT_CLIENT=\"anthropic/claude-sonnet-4-5\"\nNote that it can also be useful to pass a full Chat object to the client parameter for more advanced use cases (e.g., custom parameters, tools, etc). It can also be useful for getting some helpful autocomplete of available models.\nfrom chatlas import ChatAnthropic\n\nclient = ChatAnthropic(model=\"claude-sonnet-4-5\")\n\n\nCredentials\nMost models require an API key or some other form of authentication. See the reference page for the relevant model provider (e.g., ChatAnthropic) to learn more on how to set up credentials.\n\n\n\n\n\n\nGithub model marketplace\n\n\n\nIf you are already setup with Github credentials, Github model marketplace provides a free and easy way to get started. See here for more details on how to get setup.\n\n\ngithub-model.py\n\nfrom chatlas import ChatGithub\n\n# Just works if GITHUB_TOKEN is set in your environment\nclient = ChatGithub(model=\"gpt-4.1\")\n\n\n\nIn general, most providers will prefer credentials stored as environment variables, and common practice is to use a .env file to manage these variables. For example, for ChatOpenAI(), you might create a .env file like so:\n\n\n.env\n\nOPENAI_API_KEY=\"your_api_key_here\"\n\nThen, load the environment variables via the dotenv package:\npip install dotenv\nfrom dotenv import load_dotenv\nload_dotenv()\n\n\nRecommended models\nIn theory, you could use any model that has tool calling support, but we currently recommend (as of November 2025):\n\nGPT-4.1 (the default)\nClaude 4.5 Sonnet\nGoogle Gemini 3.0\n\nIn our testing, we’ve found that those models strike a good balance between accuracy and latency. Smaller/cheaper models like GPT-4o-mini are fine for simple queries but make surprising mistakes with more complex ones; and reasoning models like o3-mini slow down responses without providing meaningfully better results.\nWe’ve also seen some decent results with frontier local models, but even if you have the compute to run the largest models, they still tend to lag behind the cloud-hosted options in terms of accuracy and speed.\n\n\n\n\n\n\nData privacy concerns?\n\n\n\nIf you have data privacy concerns, consider that your org may provide access to private instances of these models with data residency guarantees. For example, Azure, AWS Bedrock, and Google Vertex AI all provide private instances of popular LLMs. You can interface with these enterprise providers by passing the right string (e.g., \"bedrock-anthropic\") or Chat object (e.g., ChatBedrockAnthropic()) to the client parameter. See the chatlas docs for more details.",
    "crumbs": [
      "Overview",
      "Models"
    ]
  },
  {
    "objectID": "reference/types.SQLAlchemySource.html",
    "href": "reference/types.SQLAlchemySource.html",
    "title": "types.SQLAlchemySource",
    "section": "",
    "text": "SQLAlchemySource(engine, table_name)\nA DataSource implementation that supports multiple SQL databases via SQLAlchemy.\nSupports various databases including PostgreSQL, MySQL, SQLite, Snowflake, and Databricks.\n\n\n\n\n\nName\nDescription\n\n\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from database table.\n\n\n\n\n\ntypes.SQLAlchemySource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_db_type()\nGet the database type.\nReturns the specific database type (e.g., POSTGRESQL, MYSQL, SQLITE) by inspecting the SQLAlchemy engine. Removes ” SQL” suffix if present.\n\n\n\ntypes.SQLAlchemySource.get_schema(categorical_threshold)\nGenerate schema information from database table.\nReturns: String describing the schema",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.SQLAlchemySource"
    ]
  },
  {
    "objectID": "reference/types.SQLAlchemySource.html#methods",
    "href": "reference/types.SQLAlchemySource.html#methods",
    "title": "types.SQLAlchemySource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from database table.\n\n\n\n\n\ntypes.SQLAlchemySource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_db_type()\nGet the database type.\nReturns the specific database type (e.g., POSTGRESQL, MYSQL, SQLITE) by inspecting the SQLAlchemy engine. Removes ” SQL” suffix if present.\n\n\n\ntypes.SQLAlchemySource.get_schema(categorical_threshold)\nGenerate schema information from database table.\nReturns: String describing the schema",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.SQLAlchemySource"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "The starting point for any QueryChat session\n\n\n\nQueryChat\nCreate a QueryChat instance.\n\n\nexpress.QueryChat\nUse QueryChat with Shiny Express.\n\n\n\n\n\n\nSession-specific reactive values representing the current query\n\n\n\ntypes.ServerValues\nSession-specific reactive values and client returned by QueryChat.server().\n\n\n\n\n\n\nThe underlying logic for managing data sources\n\n\n\ntypes.DataSource\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\ntypes.DataFrameSource\nA DataSource implementation that wraps a pandas DataFrame using DuckDB.\n\n\ntypes.SQLAlchemySource\nA DataSource implementation that supports multiple SQL databases via\n\n\n\n\n\n\nThe underlying tools provided to the LLM\n\n\n\ntools.tool_query\nCreate a tool that performs a SQL query on the data.\n\n\ntools.tool_update_dashboard\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\ntools.tool_reset_dashboard\nCreate a tool that resets the dashboard to show all data.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#the-querychat-class",
    "href": "reference/index.html#the-querychat-class",
    "title": "Function reference",
    "section": "",
    "text": "The starting point for any QueryChat session\n\n\n\nQueryChat\nCreate a QueryChat instance.\n\n\nexpress.QueryChat\nUse QueryChat with Shiny Express.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reactive-values",
    "href": "reference/index.html#reactive-values",
    "title": "Function reference",
    "section": "",
    "text": "Session-specific reactive values representing the current query\n\n\n\ntypes.ServerValues\nSession-specific reactive values and client returned by QueryChat.server().",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#data-sources",
    "href": "reference/index.html#data-sources",
    "title": "Function reference",
    "section": "",
    "text": "The underlying logic for managing data sources\n\n\n\ntypes.DataSource\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\ntypes.DataFrameSource\nA DataSource implementation that wraps a pandas DataFrame using DuckDB.\n\n\ntypes.SQLAlchemySource\nA DataSource implementation that supports multiple SQL databases via",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#tools",
    "href": "reference/index.html#tools",
    "title": "Function reference",
    "section": "",
    "text": "The underlying tools provided to the LLM\n\n\n\ntools.tool_query\nCreate a tool that performs a SQL query on the data.\n\n\ntools.tool_update_dashboard\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\ntools.tool_reset_dashboard\nCreate a tool that resets the dashboard to show all data.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/types.DataFrameSource.html",
    "href": "reference/types.DataFrameSource.html",
    "title": "types.DataFrameSource",
    "section": "",
    "text": "DataFrameSource(df, table_name)\nA DataSource implementation that wraps a pandas DataFrame using DuckDB.\n\n\n\n\n\nName\nDescription\n\n\n\n\nexecute_query\nExecute query using DuckDB.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from DataFrame.\n\n\n\n\n\ntypes.DataFrameSource.execute_query(query)\nExecute query using DuckDB.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_db_type()\nGet the database type.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe string “DuckDB”\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_schema(categorical_threshold)\nGenerate schema information from DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataFrameSource"
    ]
  },
  {
    "objectID": "reference/types.DataFrameSource.html#methods",
    "href": "reference/types.DataFrameSource.html#methods",
    "title": "types.DataFrameSource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nexecute_query\nExecute query using DuckDB.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from DataFrame.\n\n\n\n\n\ntypes.DataFrameSource.execute_query(query)\nExecute query using DuckDB.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_db_type()\nGet the database type.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe string “DuckDB”\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_schema(categorical_threshold)\nGenerate schema information from DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataFrameSource"
    ]
  },
  {
    "objectID": "reference/types.ServerValues.html",
    "href": "reference/types.ServerValues.html",
    "title": "types.ServerValues",
    "section": "",
    "text": "types.ServerValues(df, sql, title, client)\nSession-specific reactive values and client returned by QueryChat.server().\nThis dataclass contains all the session-specific reactive state for a QueryChat instance. Each session gets its own ServerValues to ensure proper isolation between concurrent sessions.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\nCallable[[], pd.DataFrame]\nA reactive Calc that returns the current filtered data frame. If no SQL query has been set, this returns the unfiltered data from the data source. Call it like .df() to reactively read the current data frame.\n\n\nsql\nReactiveString\nA reactive Value containing the current SQL query string. Access the value by calling .sql(), or set it with .sql.set(\"SELECT ...\"). An empty string \"\" indicates no query has been set.\n\n\ntitle\nReactiveStringOrNone\nA reactive Value containing the current title for the query. The LLM provides this title when generating a new SQL query. Access it with .title(), or set it with .title.set(\"...\"). Returns None if no title has been set.\n\n\nclient\nchatlas.Chat\nThe session-specific chat client instance. This is a deep copy of the base client configured for this specific session, containing the chat history and tool registrations for this session only.",
    "crumbs": [
      "API Reference",
      "Reactive values",
      "types.ServerValues"
    ]
  },
  {
    "objectID": "reference/types.ServerValues.html#attributes",
    "href": "reference/types.ServerValues.html#attributes",
    "title": "types.ServerValues",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndf\nCallable[[], pd.DataFrame]\nA reactive Calc that returns the current filtered data frame. If no SQL query has been set, this returns the unfiltered data from the data source. Call it like .df() to reactively read the current data frame.\n\n\nsql\nReactiveString\nA reactive Value containing the current SQL query string. Access the value by calling .sql(), or set it with .sql.set(\"SELECT ...\"). An empty string \"\" indicates no query has been set.\n\n\ntitle\nReactiveStringOrNone\nA reactive Value containing the current title for the query. The LLM provides this title when generating a new SQL query. Access it with .title(), or set it with .title.set(\"...\"). Returns None if no title has been set.\n\n\nclient\nchatlas.Chat\nThe session-specific chat client instance. This is a deep copy of the base client configured for this specific session, containing the chat history and tool registrations for this session only.",
    "crumbs": [
      "API Reference",
      "Reactive values",
      "types.ServerValues"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html",
    "href": "reference/express.QueryChat.html",
    "title": "express.QueryChat",
    "section": "",
    "text": "express.QueryChat(\n    data_source,\n    table_name,\n    *,\n    id=None,\n    greeting=None,\n    client=None,\n    data_description=None,\n    categorical_threshold=10,\n    extra_instructions=None,\n    prompt_template=None,\n    enable_bookmarking='auto',\n)\nUse QueryChat with Shiny Express.\nThis class makes it easy to use querychat within Shiny Express apps – it automatically calls .server() during initialization, so you don’t have to do it manually.\n\n\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import app_opts, render, ui\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.card(fill=True):\n    with ui.card_header():\n\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n\n\nui.page_opts(\n    title=\"Titanic QueryChat App\",\n    fillable=True,\n)\n\napp_opts(bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n10\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclient\nGet the (session-specific) chat client.\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ndf\nReactively read the current filtered data frame that is in effect.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nsql\nReactively read (or set) the current SQL query that is in effect.\n\n\ntitle\nReactively read (or set) the current title that is in effect.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nexpress.QueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nexpress.QueryChat.df()\nReactively read the current filtered data frame that is in effect.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe current filtered data frame as a pandas DataFrame. If no query has been set, this will return the unfiltered data frame from the data source.\n\n\n\n\n\n\n\nexpress.QueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nexpress.QueryChat.sidebar(width=400, height='100%', **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nexpress.QueryChat.sql(query=None)\nReactively read (or set) the current SQL query that is in effect.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nOptional[str]\nIf provided, sets the current SQL query to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | bool\nIf no query is provided, returns the current SQL query as a string (possibly \"\" if no query has been set). If a query is provided, returns True if the query was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.title(value=None)\nReactively read (or set) the current title that is in effect.\nThe title is a short description of the current query that the LLM provides to us whenever it generates a new SQL query. It can be used as a status string for the data dashboard.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nOptional[str]\nIf provided, sets the current title to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no value is provided, returns the current title as a string, or None if no title has been set due to no SQL query being set. If a value is provided, sets the current title to this value and returns True if the title was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.ui(**kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#examples",
    "href": "reference/express.QueryChat.html#examples",
    "title": "express.QueryChat",
    "section": "",
    "text": "from querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import app_opts, render, ui\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.card(fill=True):\n    with ui.card_header():\n\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n\n\nui.page_opts(\n    title=\"Titanic QueryChat App\",\n    fillable=True,\n)\n\napp_opts(bookmark_store=\"url\")",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#parameters",
    "href": "reference/express.QueryChat.html#parameters",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n10\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#attributes",
    "href": "reference/express.QueryChat.html#attributes",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nclient\nGet the (session-specific) chat client.\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#methods",
    "href": "reference/express.QueryChat.html#methods",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ndf\nReactively read the current filtered data frame that is in effect.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nsql\nReactively read (or set) the current SQL query that is in effect.\n\n\ntitle\nReactively read (or set) the current title that is in effect.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nexpress.QueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nexpress.QueryChat.df()\nReactively read the current filtered data frame that is in effect.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe current filtered data frame as a pandas DataFrame. If no query has been set, this will return the unfiltered data frame from the data source.\n\n\n\n\n\n\n\nexpress.QueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nexpress.QueryChat.sidebar(width=400, height='100%', **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nexpress.QueryChat.sql(query=None)\nReactively read (or set) the current SQL query that is in effect.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nOptional[str]\nIf provided, sets the current SQL query to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | bool\nIf no query is provided, returns the current SQL query as a string (possibly \"\" if no query has been set). If a query is provided, returns True if the query was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.title(value=None)\nReactively read (or set) the current title that is in effect.\nThe title is a short description of the current query that the LLM provides to us whenever it generates a new SQL query. It can be used as a status string for the data dashboard.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nOptional[str]\nIf provided, sets the current title to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no value is provided, returns the current title as a string, or None if no title has been set due to no SQL query being set. If a value is provided, sets the current title to this value and returns True if the title was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.ui(**kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The Querychat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "tools.html",
    "href": "tools.html",
    "title": "Tools",
    "section": "",
    "text": "QueryChat combines tool calling with reactivity to not only execute SQL, but also reactively update dependent data views. Understanding how these tools work will help you better understand what QueryChat is capable of and how to customize/extend to its behavior.\nOne important thing to understand generally about Querychat’s tools is they are Python functions, and that execution happens on your machine, not on the LLM provider’s side. In other words, the SQL queries generated by the LLM are executed locally in the Shiny app process, and only the results (if any) are sent back to the LLM.\nQuerychat provides the LLM access to three tools, serving two primary purposes:",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#data-updating",
    "href": "tools.html#data-updating",
    "title": "Tools",
    "section": "Data updating",
    "text": "Data updating\nWhen a user asks to “Show me…” or “Filter to…” or “Sort by…”, the LLM requests a call to the update_dashboard tool with an appropriate SQL query as input. An important constraint is that the query must return all original schema columns (typically using SELECT *). When called, Querychat will both set a reactive value holding the current SQL query and execute the query to get the result.\nThe result of query then used to set a reactive value holding the filtered/sorted data frame. Thanks to reactivity, this will automatically update any views depending on this data frame, such as the data table displayed in the UI.\nThis tool also takes a title parameter, which is a short description of the filter/sort operation (e.g., “First-class passengers”). This, also, is made available through a reactive value for display somewhere in your app.\nHere’s a basic example of this tool in action with the .app() method. Notice how this pre-built app not only shows the data table, but also the SQL query and title generated by the LLM (for transparency):\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom seaborn import load_dataset\n\ntitanic = load_dataset(\"titanic\")\nqc = QueryChat(titanic, \"titanic\")\napp = qc.app()\n\n\nThe other data updating tool is reset_dashboard, which clears any active filters and returns the data table to its original unfiltered state. The LLM typically uses this when users say “reset”, “start over”, or “clear filters”.",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#data-analysis",
    "href": "tools.html#data-analysis",
    "title": "Tools",
    "section": "Data analysis",
    "text": "Data analysis\nWhen a user asks analytical questions like “What is the average…?”, “How many…?”, or “Which item has the highest…?”, the LLM generates a SQL query and requests a call to the query tool. Unlike the data updating tools, this tool will not update any reactive values. Instead, it will:\n\nExecute the SQL query\nDisplay both the SQL query and results in the UI\nReturn the results back to the LLM for interpretation\n\nHere’s an example of it in action:\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom seaborn import load_dataset\n\ntitanic = load_dataset(\"titanic\")\nqc = QueryChat(titanic, \"titanic\")\napp = qc.app()",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#view-the-source",
    "href": "tools.html#view-the-source",
    "title": "Tools",
    "section": "View the source",
    "text": "View the source\nIf you’d like to better understand how the tools work and how the LLM is prompted to use them, check out the following resources:\nSource code:\n\ntools.py\n\nPrompts:\n\nprompts/tool-update-dashboard.md\nprompts/tool-reset-dashboard.md\nprompts/tool-query.md",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "greet.html",
    "href": "greet.html",
    "title": "Greet users",
    "section": "",
    "text": "Provide a greeting\nWhen the querychat UI first appears, you will usually want it to greet the user with some basic instructions. By default, these instructions are auto-generated every time a user arrives; this is slow, wasteful, and unpredictable. Instead, you should create a greeting file and pass it when creating your QueryChat object:\nfrom pathlib import Path\nqc = QueryChat(titanic, \"titanic\", greeting=Path(\"greeting.md\"))\nYou can provide suggestions to the user by using the &lt;span class=\"suggestion\"&gt; &lt;/span&gt; tag:\n* **Filter and sort the data:**\n  * &lt;span class=\"suggestion\"&gt;Show only survivors&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;Filter to first class passengers under 30&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;Sort by fare from highest to lowest&lt;/span&gt;\n\n* **Answer questions about the data:**\n  * &lt;span class=\"suggestion\"&gt;What was the survival rate by gender?&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;What's the average age of children who survived?&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;How many passengers were traveling alone?&lt;/span&gt;\nThese suggestions appear in the greeting and automatically populate the chat text box when clicked. You can see this behavior in our querychat template.\n\n\nGenerate a greeting\nIf you need help coming up with a greeting, you can use the .generate_greeting() method:\nfrom palmerpenguins import load_penguins\nfrom querychat import QueryChat\n\n# Create QueryChat object with your dataset\npenguins = load_penguins()\nqc = QueryChat(penguins, \"penguins\")\n\n# Generate a greeting (this calls the LLM)\ngreeting_text = qc.generate_greeting()\n#&gt; Hello! I'm here to help you explore and analyze the penguins dataset.\n#&gt; Here are some example prompts you can try:\n#&gt; ...\n\n# Save it for reuse\nwith open(\"penguins_greeting.md\", \"w\") as f:\n    f.write(greeting_text)\n\n# Then use the saved greeting in your app\nqc = QueryChat(penguins, \"penguins\", greeting=Path(\"penguins_greeting.md\"))\nThis approach generates a greeting once and saves it for reuse, avoiding the latency and cost of generating it for every user.",
    "crumbs": [
      "Overview",
      "Greet users"
    ]
  }
]