---
title: Shiny
lightbox: true
---

[Shiny](https://shiny.posit.co/py/) is a web framework for building interactive data applications. It provides a reactive programming model that's a natural fit for querychat. 

In this guide, you'll learn how to build Shiny apps with querychat to enable rich data exploration experiences where [data views](#data-views) update based on natural language filters.

![](/images/rich-data-views.png){fig-alt="Screenshot of querychat running in a custom Shiny app." class="lightbox shadow rounded mb-3"}

## Initialize `QueryChat`

The "main" `QueryChat` class is available directly from the top-level module, and it designed to work with Shiny (Core):

```{.python}
from querychat import QueryChat
```

For Shiny Express, import from `querychat.express` instead (similar to how you import from `shiny.express`):

```{.python}
from querychat.express import QueryChat
```

Once imported, initialize it with your [data source](data-sources.qmd):

```{.python}
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic")
```

::: {.callout-note collapse="true"}

## Quick start with `.app()`

Remember, the simplest way to get started is with `.app()`, which gives a "pre-baked" Shiny app:

```{.python filename="shiny-app.py"}
from querychat import QueryChat
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic")
app = qc.app()
```

Run with:

```bash
shiny run shiny-app.py
```
:::

## Relevant methods

After initializing `QueryChat`, use `.sidebar()` or `.ui()` to place the chat interface in your app. As users interact with the chat, `.df()`, `.sql()`, and `.title()` automatically update to reflect the current query. Any Shiny outputs that depend on these reactive values will re-render automatically.

| Method | Description |
|--------|-------------|
| `.sidebar()` | Place the chat interface in a sidebar |
| `.ui()` | Returns just the chat component for custom placement |
| `.df()` | Current filtered/sorted DataFrame |
| `.sql()` | Current SQL query (str \| None) |
| `.title()` | Short description of current filter (str \| None) |



::: callout-note
Shiny has two modes: **Express** (simple, script-based) and **Core** (explicit UI/server separation). With Core, call `qc.server()` in your server function and access reactives via the returned object (e.g., `qc_vals.df()`). With Express, access them directly on the `QueryChat` instance (e.g., `qc.df()`).
:::

## Basic sidebar

The most common pattern places chat in the sidebar with your custom filtered views in the main area:

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
{{< include /../examples/03-sidebar-express-app.py >}}
```

#### Core

```python
{{< include /../examples/03-sidebar-core-app.py >}}
```

:::

## Deferred data sources (Core only) {#deferred-data-sources}

In Shiny Core applications, you may need to create database connections per-user rather than globally. For example, when connections depend on session-specific authentication or user credentials. The deferred data source pattern supports this by allowing `data_source=None` at initialization:

```python
from shiny import App, ui
from querychat import QueryChat

# Global scope - create QueryChat without data source
qc = QueryChat(None, "users")

def app_ui(request):
    return ui.page_sidebar(
        qc.sidebar(),
        ui.output_data_frame("table"),
    )

def server(input, output, session):
    # Server scope - create connection with session credentials
    conn = get_user_connection(session)

    # Option A: Pass data source to server()
    qc_vals = qc.server(data_source=conn)

    # Option B: Set property first
    # qc.data_source = conn
    # qc_vals = qc.server()

    @render.data_frame
    def table():
        return qc_vals.df()

app = App(app_ui, server)
```

When using this pattern:

- **`table_name` is required** - it cannot be inferred from `None`
- **UI methods work without data** - `.sidebar()` and `.ui()` don't need the data source
- **Server methods require data** - `.server()`, `.client()`, `.console()`, and `.generate_greeting()` need the data source to be set first

::: callout-note
This pattern is primarily useful for Shiny Core. In Express mode, the single-scope design means you typically have access to session information when creating the `QueryChat` instance.
:::

## Custom chat UI

Use `.ui()` to place the chat anywhere in your layout. Here we use it simply to place custom content in the sidebar alongside the chat (like a [reset button](#resetting-filters)):

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
from shiny.express import ui
from querychat.express import QueryChat

qc = QueryChat(data, "my_data")

with ui.sidebar():
    qc.ui()  # Chat component
    ui.hr()
    ui.input_action_button("reset", "Reset Filters", class_="w-100")
```

#### Core

```python
from shiny import ui
from querychat import QueryChat

qc = QueryChat(data, "my_data")

app_ui = ui.page_sidebar(
    ui.sidebar(
        qc.ui(),  # Chat component
        ui.hr(),
        ui.input_action_button("reset", "Reset Filters", class_="w-100"),
    ),
    # Main content here
)
```

:::

::: callout-tip
#### Custom Shiny chat UIs

Learn more about customizing Shiny chat UIs in the [Shiny Chat documentation](https://shiny.posit.co/py/docs/genai-chatbots.html#layout).
:::


## Data views

The real power of querychat comes from connecting it to visualizations. Here's an example showing both filtered data and a chart:

```python
import plotly.express as px

from shiny.express import render, ui
from shinywidgets import render_plotly

from querychat.express import QueryChat
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic")
qc.sidebar()

with ui.layout_columns():
    with ui.card():
        ui.card_header("Data Table")

        @render.data_frame
        def table():
            return qc.df()

    with ui.card():
        ui.card_header("Survival by Class")

        @render_plotly
        def survival_plot():
            d = qc.df().to_native()  # Convert for pandas groupby()
            summary = d.groupby('pclass')['survived'].mean().reset_index()
            return px.bar(summary, x='pclass', y='survived')
```

When users filter data through the chat (e.g., "show only children"), both charts update automatically.

![](/images/plotly-data-view.png){fig-alt="Screenshot of a querychat app showing both a data table and a bar chart of survival by class." class="lightbox shadow rounded mb-3"}

A more complete example adds metrics, tabs, and multiple views:

```{python}
# | eval: false
# | code-fold: true
# | code-summary: "titanic-dashboard.py"
{{< include _examples/titanic-dashboard.py >}}
```

![](/images/rich-data-views.png){fig-alt="Screenshot of a querychat app showing value boxes, a data table, and multiple plots." class="lightbox shadow rounded mb-3"}


### Resetting filters

Add a reset button to clear filters and show all data:

::: {.panel-tabset group="shiny-mode"}

#### Express

```python
ui.input_action_button("reset", "Reset Filters")

@reactive.effect
@reactive.event(input.reset)
def _():
    qc.sql("")
    qc.title(None)
```

#### Core

```python
ui.input_action_button("reset", "Reset Filters")

qc_vals = qc.server()

@reactive.effect
@reactive.event(input.reset)
def _():
    qc_vals.sql.set("")
    qc_vals.title.set(None)
```

:::

::: {.callout-tip}
Users can also ask the LLM to "reset" or "show all data" to clear filters through the chat interface.
:::

### Advanced patterns

#### Programmatic updates

You can update the query state programmatically using `.sql()` and `.title()` as setters. This is useful for adding preset filter buttons or linking filters to other UI controls.

#### Multiple datasets

To explore multiple datasets, use separate `QueryChat` instances (i.e., separate chat interfaces).

::: {.callout-note}
### Multiple tables in one chat?

In some cases, you might be able to "pre-join" datasets into a single table and use one `QueryChat` instance to explore them together. In the future, we may support multiple filtered tables in one chat interface, but this is not currently available. Please upvote [the relevant issue](https://github.com/posit-dev/querychat/issues/6) if this is a feature you'd like to see!
:::

```{python}
# | eval: false
# | code-fold: true
# | code-summary: "multiple-datasets.py"
{{< include _examples/multiple-datasets.py >}}
```

![](/images/multiple-datasets.png){fig-alt="Screenshot of a querychat app with two datasets: titanic and penguins." class="lightbox shadow rounded mb-3"}

::: {.callout-note}
Each dataset gets its own chat interface and maintains separate state.
:::

## See also

- [Greet users](greet.qmd) - Create welcoming onboarding experiences
- [Provide context](context.qmd) - Help the LLM understand your data better
- [Tools](tools.qmd) - Understand what querychat can do under the hood
