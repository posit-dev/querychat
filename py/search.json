[
  {
    "objectID": "context.html",
    "href": "context.html",
    "title": "Provide context",
    "section": "",
    "text": "querychat automatically gathers information about your table to help the LLM write accurate SQL queries. This includes column names and types, numerical ranges, and categorical value examples.1\nImportantly, we are not sending your raw data to the LLM and asking it to do complicated math. The LLM only needs to understand the structure and schema of your data in order to write SQL queries.\nYou can get even better results by customizing the system prompt in three ways:",
    "crumbs": [
      "Get started",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#default-prompt",
    "href": "context.html#default-prompt",
    "title": "Provide context",
    "section": "Default prompt",
    "text": "Default prompt\nFor full visibility into the system prompt that querychat generates for the LLM, you can inspect the system_prompt property. This is useful for debugging and understanding exactly what context the LLM is using:\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nprint(qc.system_prompt)\nBy default, the system prompt contains the following components:\n\nThe basic set of behaviors and guidelines the LLM must follow in order for querychat to work properly, including how to use tools to execute queries and update the app.\nThe SQL schema of the data frame you provided. This includes:\n\nColumn names\nData types (integer, float, boolean, datetime, text)\nFor text columns with less than 10 unique values, we assume they are categorical variables and include the list of values\nFor integer and float columns, we include the range\n\nA data description (if provided via data_description)\nAdditional instructions you want to use to guide querychat’s behavior (if provided via extra_instructions).",
    "crumbs": [
      "Get started",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#data-description",
    "href": "context.html#data-description",
    "title": "Provide context",
    "section": "Data description",
    "text": "Data description\nIf your column names are descriptive, querychat may already work well without additional context. However, if your columns are named x, V1, value, etc., you should provide a data description. Use the data_description parameter for this:\n\n\ntitanic-app.py\n\nfrom pathlib import Path\nfrom querychat import QueryChat\n\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    data_description=Path(\"data_description.md\")\n)\napp = qc.app()\n\nquerychat doesn’t need this information in any particular format – just provide what a human would find helpful:\n\n\ndata_description.md\n\nThis dataset contains information about Titanic passengers, collected for predicting survival.\n\n- survived: Survival (0 = No, 1 = Yes)\n- pclass: Ticket class (1 = 1st, 2 = 2nd, 3 = 3rd)\n- sex: Sex of passenger\n- age: Age in years\n- sibsp: Number of siblings/spouses aboard\n- parch: Number of parents/children aboard\n- fare: Passenger fare\n- embarked: Port of embarkation (C = Cherbourg, Q = Queenstown, S = Southampton)",
    "crumbs": [
      "Get started",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#extra-instructions",
    "href": "context.html#extra-instructions",
    "title": "Provide context",
    "section": "Additional instructions",
    "text": "Additional instructions\nYou can add custom instructions to guide the LLM’s behavior using the extra_instructions parameter:\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    extra_instructions=Path(\"instructions.md\")\n)\nOr as a string:\ninstructions = \"\"\"\n- Use British spelling conventions\n- Stay on topic and only discuss the data dashboard\n- Refuse to answer unrelated questions\n\"\"\"\n\nqc = QueryChat(titanic, \"titanic\", extra_instructions=instructions)\n\n\n\n\n\n\nWarning\n\n\n\nLLMs may not always follow your instructions perfectly. Test extensively when changing instructions or models.",
    "crumbs": [
      "Get started",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#custom-template",
    "href": "context.html#custom-template",
    "title": "Provide context",
    "section": "Custom template",
    "text": "Custom template\nIf you want more control over the system prompt, you can provide a custom prompt template using the prompt_template parameter. This is for more advanced users who want to fully customize the LLM’s behavior. See the API reference for details on the available template variables.",
    "crumbs": [
      "Get started",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#footnotes",
    "href": "context.html#footnotes",
    "title": "Provide context",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAll of this information is provided to the LLM as part of the system prompt – a string of text containing instructions and context for the LLM to consider when responding to user queries.↩︎",
    "crumbs": [
      "Get started",
      "Provide context"
    ]
  },
  {
    "objectID": "build-gradio.html",
    "href": "build-gradio.html",
    "title": "Gradio",
    "section": "",
    "text": "Gradio is a web framework for building interactive data/ML applications. It provides a event-based programming model that’s great for quickly assembling simple UIs.\nIn this guide, you’ll learn how to build Gradio apps with querychat to enable rich data exploration experiences where data views update based on natural language filters.",
    "crumbs": [
      "Build custom apps",
      "Gradio"
    ]
  },
  {
    "objectID": "build-gradio.html#initialize-querychat",
    "href": "build-gradio.html#initialize-querychat",
    "title": "Gradio",
    "section": "Initialize QueryChat",
    "text": "Initialize QueryChat\nFirst, install querychat with Gradio support:\npip install \"querychat[gradio]\"\nThen import the Gradio-specific QueryChat class:\nfrom querychat.gradio import QueryChat\nAnd initialize it with your data source:\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\n\n\n\n\n\n\nQuick start with .app()\n\n\n\n\n\nRemember, the simplest way to get started is with .app(), which gives a “pre-baked” Gradio app:\n\n\ngradio-app.py\n\nfrom querychat.gradio import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\napp.launch()\n\nRun with:\npython gradio-app.py",
    "crumbs": [
      "Build custom apps",
      "Gradio"
    ]
  },
  {
    "objectID": "build-gradio.html#relevant-methods",
    "href": "build-gradio.html#relevant-methods",
    "title": "Gradio",
    "section": "Relevant methods",
    "text": "Relevant methods\nAfter initializing QueryChat, use .ui() to place the chat interface in your gr.Blocks layout. It creates the chat components and returns a gr.State that updates as users interact with the chat. Use .df(state), .sql(state), and .title(state) in your callbacks to access the current query values.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n.ui()\nCreates chat UI and returns gr.State for wiring to callbacks\n\n\n.df(state)\nCurrent filtered/sorted DataFrame\n\n\n.sql(state)\nCurrent SQL query (str | None)\n\n\n.title(state)\nShort description of current filter (str | None)\n\n\n\n\n\n\n\n\n\nWhy css=qc.css, head=qc.head?\n\n\n\nThe qc.css and qc.head properties provide the CSS and JavaScript needed for clickable suggestions in chat messages. Always include these when building custom layouts with .ui().",
    "crumbs": [
      "Build custom apps",
      "Gradio"
    ]
  },
  {
    "objectID": "build-gradio.html#basic-layout",
    "href": "build-gradio.html#basic-layout",
    "title": "Gradio",
    "section": "Basic layout",
    "text": "Basic layout\nThe most common pattern places chat alongside your custom filtered views:\nimport gradio as gr\nfrom querychat.gradio import QueryChat\nfrom querychat.data import titanic\nfrom querychat.types import AppStateDict\n\nqc = QueryChat(titanic(), \"titanic\")\n\nwith gr.Blocks() as app:\n    with gr.Row():\n        with gr.Column():\n            state = qc.ui()\n\n        with gr.Column():\n            data_table = gr.Dataframe(label=\"Data\")\n\n    def update_table(state_dict: AppStateDict):\n        return qc.df(state_dict).to_pandas()\n\n    state.change(fn=update_table, inputs=[state], outputs=[data_table])\n\napp.launch(css=qc.css, head=qc.head)",
    "crumbs": [
      "Build custom apps",
      "Gradio"
    ]
  },
  {
    "objectID": "build-gradio.html#data-views",
    "href": "build-gradio.html#data-views",
    "title": "Gradio",
    "section": "Data views",
    "text": "Data views\nThe real power of querychat comes from connecting it to visualizations. Here’s an example showing two charts that respond to query changes:\n\nimport plotly.express as px\nfrom querychat.data import titanic\nfrom querychat.gradio import QueryChat\nfrom querychat.types import AppStateDict\n\nimport gradio as gr\n\nqc = QueryChat(titanic(), \"titanic\")\n\nwith gr.Blocks() as app:\n    with gr.Row():\n        with gr.Column():\n            state = qc.ui()\n\n        with gr.Column():\n            plot1 = gr.Plot(label=\"Age Distribution\")\n            plot2 = gr.Plot(label=\"Survival by Class\")\n\n    def update_views(state_dict: AppStateDict):\n        df = qc.df(state_dict).to_pandas()\n        fig1 = px.histogram(df, x=\"age\", color=\"survived\", title=\"Age Distribution\")\n        fig2 = px.bar(\n            df.groupby(\"pclass\")[\"survived\"].mean().reset_index(),\n            x=\"pclass\",\n            y=\"survived\",\n            title=\"Survival by Class\",\n        )\n        return fig1, fig2\n\n    state.change(fn=update_views, inputs=[state], outputs=[plot1, plot2])\n\napp.launch(css=qc.css, head=qc.head)\n\nWhen users filter data through the chat (e.g., “show only survivors”), both charts update automatically.\n\nA more complete example adds metrics:\n\n\ngradio-complete.py\nimport plotly.express as px\nfrom querychat.data import titanic\nfrom querychat.gradio import QueryChat\nfrom querychat.types import AppStateDict\n\nimport gradio as gr\n\nqc = QueryChat(titanic(), \"titanic\")\n\nwith gr.Blocks(title=\"Titanic Explorer\") as app:\n    gr.Markdown(\"# Titanic Dataset Explorer\")\n\n    with gr.Row():\n        with gr.Column(scale=1):\n            state = qc.ui()\n\n        with gr.Column(scale=2):\n            title_display = gr.Markdown(\"## All Data\")\n\n            with gr.Row():\n                passengers_box = gr.Textbox(label=\"Passengers\", interactive=False)\n                survivors_box = gr.Textbox(label=\"Survivors\", interactive=False)\n                rate_box = gr.Textbox(label=\"Survival Rate\", interactive=False)\n\n            with gr.Row():\n                plot1 = gr.Plot()\n                plot2 = gr.Plot()\n\n    def update_all(state_dict: AppStateDict):\n        df = qc.df(state_dict).to_pandas()\n        title = qc.title(state_dict) or \"All Data\"\n\n        # Metrics\n        n_passengers = str(len(df))\n        n_survivors = str(int(df[\"survived\"].sum()))\n        survival_rate = f\"{df['survived'].mean():.1%}\"\n\n        # Visualizations\n        fig1 = px.histogram(\n            df, x=\"age\", color=\"survived\", title=\"Age Distribution by Survival\"\n        )\n        fig2 = px.bar(\n            df.groupby(\"pclass\")[\"survived\"].mean().reset_index(),\n            x=\"pclass\",\n            y=\"survived\",\n            title=\"Survival by Class\",\n        )\n\n        return (\n            f\"## {title}\",\n            n_passengers,\n            n_survivors,\n            survival_rate,\n            fig1,\n            fig2,\n        )\n\n    state.change(\n        fn=update_all,\n        inputs=[state],\n        outputs=[\n            title_display,\n            passengers_box,\n            survivors_box,\n            rate_box,\n            plot1,\n            plot2,\n        ],\n    )\n\napp.launch(css=qc.css, head=qc.head)\n\n\n\n\nResetting filters\nAdd a reset button to show all data by fetching the original data from qc.data_source.get_data():\nreset_btn = gr.Button(\"Reset\")\n\ndef reset_data():\n    return qc.data_source.get_data().to_pandas()\n\nreset_btn.click(fn=reset_data, outputs=[data_table])\n\n\n\n\n\n\nTip\n\n\n\nThis resets the data display only. Users can also ask the LLM to “reset” or “show all data” to clear filters through the chat interface.\n\n\n\n\nAdvanced patterns\n\nProgrammatic updates\nYou can update the display programmatically by creating event handlers that modify your output components directly.\n\n\nMultiple datasets\nTo explore multiple datasets, use separate QueryChat instances (i.e., separate chat interfaces).\n\n\n\n\n\n\nMultiple tables in one chat?\n\n\n\nIn some cases, you might be able to “pre-join” datasets into a single table and use one QueryChat instance to explore them together. In the future, we may support multiple filtered tables in one chat interface, but this is not currently available. Please upvote the relevant issue if this is a feature you’d like to see!",
    "crumbs": [
      "Build custom apps",
      "Gradio"
    ]
  },
  {
    "objectID": "build-gradio.html#see-also",
    "href": "build-gradio.html#see-also",
    "title": "Gradio",
    "section": "See also",
    "text": "See also\n\nGreet users - Create welcoming onboarding experiences\nProvide context - Help the LLM understand your data better",
    "crumbs": [
      "Build custom apps",
      "Gradio"
    ]
  },
  {
    "objectID": "build-streamlit.html",
    "href": "build-streamlit.html",
    "title": "Streamlit",
    "section": "",
    "text": "Streamlit is a web framework for interactive data/ML applications. It provides a simple scripting model that’s great for quickly assembling simple apps.\nIn this guide, you’ll learn how to build Streamlit apps with querychat to enable rich data exploration experiences where data views update based on natural language filters.",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-streamlit.html#initialize-querychat",
    "href": "build-streamlit.html#initialize-querychat",
    "title": "Streamlit",
    "section": "Initialize QueryChat",
    "text": "Initialize QueryChat\nFirst, install querychat with Streamlit support:\npip install \"querychat[streamlit]\"\nThen import the Streamlit-specific QueryChat class:\nfrom querychat.streamlit import QueryChat\nAnd initialize it with your data source:\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\n\n\n\n\n\n\nQuick start with .app()\n\n\n\n\n\nRemember, the simplest way to get started is with .app(), which gives a “pre-baked” Streamlit app:\n\n\nstreamlit-app.py\n\nfrom querychat.streamlit import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.app()\n\nRun with:\nstreamlit run streamlit-app.py",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-streamlit.html#relevant-methods",
    "href": "build-streamlit.html#relevant-methods",
    "title": "Streamlit",
    "section": "Relevant methods",
    "text": "Relevant methods\nAfter initializing QueryChat, use .sidebar() or .ui() to place the chat interface in your app. As users interact with the chat, .df(), .sql(), and .title() automatically update to reflect the current query.\n\n\n\nMethod\nDescription\n\n\n\n\n.sidebar()\nPlace the chat interface in Streamlit’s sidebar\n\n\n.ui()\nReturns just the chat component for custom placement\n\n\n.df()\nCurrent filtered/sorted DataFrame\n\n\n.sql()\nCurrent SQL query (str | None)\n\n\n.title()\nShort description of current filter (str | None)",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-streamlit.html#basic-sidebar",
    "href": "build-streamlit.html#basic-sidebar",
    "title": "Streamlit",
    "section": "Basic sidebar",
    "text": "Basic sidebar\nThe most common pattern places chat in the sidebar with your custom filtered views in the main area:\nimport streamlit as st\nfrom querychat.streamlit import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.sidebar()\n\nst.header(qc.title() or \"Titanic Explorer\")\nst.dataframe(qc.df())",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-streamlit.html#custom-chat-ui",
    "href": "build-streamlit.html#custom-chat-ui",
    "title": "Streamlit",
    "section": "Custom chat UI",
    "text": "Custom chat UI\nUse .ui() to place the chat anywhere in your layout. Here we use it to place custom content in the sidebar alongside the chat (like a reset button):\nimport streamlit as st\nfrom querychat.streamlit import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\n\nwith st.sidebar:\n    qc.ui()\n    st.divider()\n    if st.button(\"Reset Filters\"):\n        qc.reset()\n\nst.dataframe(qc.df())",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-streamlit.html#data-views",
    "href": "build-streamlit.html#data-views",
    "title": "Streamlit",
    "section": "Data views",
    "text": "Data views\nThe real power of querychat comes from connecting it to visualizations. Here’s an example showing both filtered data and a chart:\n\nimport plotly.express as px\nfrom querychat.data import titanic\nfrom querychat.streamlit import QueryChat\n\nimport streamlit as st\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.sidebar()\n\nst.header(qc.title() or \"Titanic Explorer\")\nst.dataframe(qc.df())\n\ndf = qc.df().to_pandas()\nfig = px.histogram(df, x=\"age\", color=\"survived\", title=\"Age Distribution\")\nst.plotly_chart(fig)\n\nWhen users filter data through the chat (e.g., “show only survivors”), both views update automatically.\n\nA more complete example adds metrics:\n\n\nstreamlit-complete.py\nimport plotly.express as px\nfrom querychat.data import titanic\nfrom querychat.streamlit import QueryChat\n\nimport streamlit as st\n\nst.set_page_config(page_title=\"Titanic Explorer\", layout=\"wide\")\n\nqc = QueryChat(titanic(), \"titanic\")\n\n# Sidebar with chat and reset\nwith st.sidebar:\n    qc.ui()\n    st.divider()\n    if st.button(\"Reset Filters\", use_container_width=True):\n        qc.reset()\n\n# Main content\nst.header(qc.title() or \"Titanic Dataset\")\n\n# Metrics row\ndf = qc.df().to_pandas()\ncol1, col2, col3 = st.columns(3)\ncol1.metric(\"Passengers\", len(df))\ncol2.metric(\"Survivors\", df[\"survived\"].sum())\ncol3.metric(\"Survival Rate\", f\"{df['survived'].mean():.1%}\")\n\n# Visualizations\ncol1, col2 = st.columns(2)\n\nwith col1:\n    fig1 = px.histogram(\n        df, x=\"age\", color=\"survived\", title=\"Age Distribution by Survival\"\n    )\n    st.plotly_chart(fig1, use_container_width=True)\n\nwith col2:\n    fig2 = px.bar(\n        df.groupby(\"pclass\")[\"survived\"].mean().reset_index(),\n        x=\"pclass\",\n        y=\"survived\",\n        title=\"Survival by Class\",\n    )\n    st.plotly_chart(fig2, use_container_width=True)\n\n\n\n\nResetting filters\nAdd a reset button to clear filters and show all data:\nif st.button(\"Reset Filters\"):\n    qc.reset()  # Automatically triggers st.rerun()\n\n\n\n\n\n\nTip\n\n\n\nUsers can also ask the LLM to “reset” or “show all data” to clear filters through the chat interface.\n\n\n\n\nAdvanced patterns\n\nProgrammatic updates\nYou can update the query state programmatically using .sql() and .title() as setters. This is useful for adding preset filter buttons or linking filters to other UI controls.\n\n\nMultiple datasets\nTo explore multiple datasets, use separate QueryChat instances (i.e., separate chat interfaces).\n\n\n\n\n\n\nMultiple tables in one chat?\n\n\n\nIn some cases, you might be able to “pre-join” datasets into a single table and use one QueryChat instance to explore them together. In the future, we may support multiple filtered tables in one chat interface, but this is not currently available. Please upvote the relevant issue if this is a feature you’d like to see!",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-streamlit.html#see-also",
    "href": "build-streamlit.html#see-also",
    "title": "Streamlit",
    "section": "See also",
    "text": "See also\n\nGreet users - Create welcoming onboarding experiences\nProvide context - Help the LLM understand your data better",
    "crumbs": [
      "Build custom apps",
      "Streamlit"
    ]
  },
  {
    "objectID": "build-intro.html",
    "href": "build-intro.html",
    "title": "Intro",
    "section": "",
    "text": "While the .app() method is a great quick start for exploring data, building custom apps with querychat unlocks the full power of integrating natural language data exploration with custom visualizations, layouts, and interactivity.\nquerychat is a particularly good fit for apps that have:\nIn these apps, querychat can replace or augment your filtering UI by allowing users to describe what they want to see in natural language. Instead of building complex filter controls, users can simply ask questions like “show me customers from California who spent over $1000 last quarter” and querychat will generate the appropriate SQL query.\nThis is especially valuable when:\nIf you have an existing app with a data frame that flows through multiple outputs, querychat can be a natural addition to provide an alternative way to filter that data.",
    "crumbs": [
      "Build custom apps",
      "Intro"
    ]
  },
  {
    "objectID": "build-intro.html#general-pattern",
    "href": "build-intro.html#general-pattern",
    "title": "Intro",
    "section": "General pattern",
    "text": "General pattern\nRegardless of framework, building a custom querychat app follows the same pattern:\n\nInitialize a QueryChat instance with your data\nPlace the chat UI in your layout (.sidebar() or .ui())\nAccess query state (.df(), .sql(), .title()) to build reactive outputs\nConnect visualizations and tables to the filtered data\n\nEach framework has its own way of handling reactivity and state updates, but the core querychat API is largely consistent across all of them.",
    "crumbs": [
      "Build custom apps",
      "Intro"
    ]
  },
  {
    "objectID": "build-intro.html#choosing-a-framework",
    "href": "build-intro.html#choosing-a-framework",
    "title": "Intro",
    "section": "Choosing a framework",
    "text": "Choosing a framework\nquerychat supports four Python web frameworks. Choose based on your needs:\n\n\n\nFramework\nBest for\nGuide\n\n\n\n\nShiny\nComplex reactive apps, fine-grained control, Posit Connect deployment\nBuild with Shiny\n\n\nStreamlit\nQuick prototypes, simple apps, script-based development\nBuild with Streamlit\n\n\nGradio\nML demos, easy sharing, Hugging Face Spaces\nBuild with Gradio\n\n\nDash\nProduction enterprise apps, complex callbacks\nBuild with Dash",
    "crumbs": [
      "Build custom apps",
      "Intro"
    ]
  },
  {
    "objectID": "build-intro.html#api-differences",
    "href": "build-intro.html#api-differences",
    "title": "Intro",
    "section": "API differences",
    "text": "API differences\nWhile querychat provides a consistent interface across frameworks, each implementation follows its framework’s idioms for state management. The key difference is how you access query state:\n\n\n\n\n\n\n\n\nFramework\nState access\nExample\n\n\n\n\nShiny\nReactive callables\nqc.df()(), qc.sql()(), qc.title()()\n\n\nStreamlit\nDirect methods (session state)\nqc.df(), qc.sql(), qc.title()\n\n\nGradio\nMethods with state dict\nqc.df(state), qc.sql(state), qc.title(state)\n\n\nDash\nMethods with state dict\nqc.df(state), qc.sql(state), qc.title(state)\n\n\n\nWhy the difference?\n\nShiny uses reactive programming where values are wrapped in reactive containers. You call .df() to get the reactive, then call it again (or use it in a reactive context) to get the value.\nStreamlit manages state internally via st.session_state, so methods can access it directly without arguments.\nGradio and Dash use callback-based architectures where state is passed explicitly to callback functions, so you pass the state dict to accessors.\n\nEach approach matches how developers typically work in that framework, making querychat feel native regardless of which framework you choose.",
    "crumbs": [
      "Build custom apps",
      "Intro"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html",
    "href": "reference/tools.tool_update_dashboard.html",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "tool_update_dashboard(data_source, update_fn)\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\nupdate_fn\nCallable[[UpdateDashboardData], None]\nCallback function to call with UpdateDashboardData when update succeeds\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html#parameters",
    "href": "reference/tools.tool_update_dashboard.html#parameters",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\nupdate_fn\nCallable[[UpdateDashboardData], None]\nCallback function to call with UpdateDashboardData when update succeeds\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html#returns",
    "href": "reference/tools.tool_update_dashboard.html#returns",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html",
    "href": "reference/tools.tool_reset_dashboard.html",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "tool_reset_dashboard(reset_fn)\nCreate a tool that resets the dashboard to show all data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nreset_fn\nCallable[[], None]\nCallback function to call when reset is invoked\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html#parameters",
    "href": "reference/tools.tool_reset_dashboard.html#parameters",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nreset_fn\nCallable[[], None]\nCallback function to call when reset is invoked\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html#returns",
    "href": "reference/tools.tool_reset_dashboard.html#returns",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html",
    "href": "reference/tools.tool_query.html",
    "title": "tools.tool_query",
    "section": "",
    "text": "tool_query(data_source)\nCreate a tool that performs a SQL query on the data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html#parameters",
    "href": "reference/tools.tool_query.html#parameters",
    "title": "tools.tool_query",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html#returns",
    "href": "reference/tools.tool_query.html#returns",
    "title": "tools.tool_query",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/QueryChat.html",
    "href": "reference/QueryChat.html",
    "title": "QueryChat",
    "section": "",
    "text": "QueryChat(\n    data_source,\n    table_name,\n    *,\n    id=None,\n    greeting=None,\n    client=None,\n    tools=('update', 'query'),\n    data_description=None,\n    categorical_threshold=20,\n    extra_instructions=None,\n    prompt_template=None,\n)\nCreate a QueryChat instance for Shiny applications.\nQueryChat enables natural language interaction with your data through an LLM-powered chat interface. It can be used in Shiny applications, as a standalone chat client, or in an interactive console.\n\n\nBasic Shiny app:\nfrom querychat import QueryChat\n\nqc = QueryChat(my_dataframe, \"my_data\")\nqc.app()\nStandalone chat client:\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Get a chat client with all tools\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Start an interactive console chat\nqc.console()\nPrivacy-focused mode: Only allow dashboard filtering, ensuring the LLM can’t see any raw data.\nqc = QueryChat(df, \"my_data\", tools=\"update\")\nqc.app()\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine | ibis.Table | None\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich querychat tools to include in the chat client by default. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to disable all tools Default is (\"update\", \"query\") (both tools enabled). Set to \"update\" to prevent the LLM from accessing data values, only allowing dashboard filtering without answering questions. The tools can be overridden per-client by passing a different tools parameter to the .client() method.\n('update', 'query')\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nserver\nInitialize Shiny server logic.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nQueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nQueryChat.cleanup()\nClean up resources associated with the data source.\n\n\n\nQueryChat.client(tools=MISSING, update_dashboard=None, reset_dashboard=None)\nCreate a chat client with registered tools.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both.\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nCallback when update_dashboard tool succeeds.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nCallback when reset_dashboard tool is invoked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client.\n\n\n\n\n\n\n\nQueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\n\n\n\nQueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\n\n\n\nQueryChat.server(data_source=None, enable_bookmarking=False, id=None)\nInitialize Shiny server logic.\nThis method is intended for use in Shiny Code mode, where the user must explicitly call .server() within the Shiny server function. In Shiny Express mode, you can use querychat.express.QueryChat instead of querychat.QueryChat, which calls .server() automatically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nOptional[IntoFrame | sqlalchemy.Engine | ibis.Table]\nOptional data source to use. If provided, sets the data_source property before initializing server logic. This is useful for the deferred pattern where data_source is not known at initialization time.\nNone\n\n\nenable_bookmarking\nbool\nWhether to enable bookmarking for the querychat module.\nFalse\n\n\nid\nOptional[str]\nOptional module ID for the QueryChat instance. If not provided, will use the ID provided at initialization. This must match the ID used in the .ui() or .sidebar() methods.\nNone\n\n\n\n\n\n\nfrom shiny import App, render, ui\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\n\n\ndef app_ui(request):\n    return ui.page_sidebar(\n        qc.sidebar(),\n        ui.card(\n            ui.card_header(ui.output_text(\"title\")),\n            ui.output_data_frame(\"data_table\"),\n        ),\n        title=\"Titanic QueryChat App\",\n        fillable=True,\n    )\n\n\ndef server(input, output, session):\n    qc_vals = qc.server(enable_bookmarking=True)\n\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"My Data\"\n\n\napp = App(app_ui, server, bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nServerValues[IntoFrameT]\nA ServerValues dataclass containing session-specific reactive values and the chat client. See ServerValues documentation for details on the available attributes.\n\n\n\n\n\n\n\nQueryChat.sidebar(width=400, height='100%', fillable=True, id=None, **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nQueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#examples",
    "href": "reference/QueryChat.html#examples",
    "title": "QueryChat",
    "section": "",
    "text": "Basic Shiny app:\nfrom querychat import QueryChat\n\nqc = QueryChat(my_dataframe, \"my_data\")\nqc.app()\nStandalone chat client:\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Get a chat client with all tools\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Start an interactive console chat\nqc.console()\nPrivacy-focused mode: Only allow dashboard filtering, ensuring the LLM can’t see any raw data.\nqc = QueryChat(df, \"my_data\", tools=\"update\")\nqc.app()",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#parameters",
    "href": "reference/QueryChat.html#parameters",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine | ibis.Table | None\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich querychat tools to include in the chat client by default. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to disable all tools Default is (\"update\", \"query\") (both tools enabled). Set to \"update\" to prevent the LLM from accessing data values, only allowing dashboard filtering without answering questions. The tools can be overridden per-client by passing a different tools parameter to the .client() method.\n('update', 'query')\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#attributes",
    "href": "reference/QueryChat.html#attributes",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#methods",
    "href": "reference/QueryChat.html#methods",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nserver\nInitialize Shiny server logic.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nQueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nQueryChat.cleanup()\nClean up resources associated with the data source.\n\n\n\nQueryChat.client(tools=MISSING, update_dashboard=None, reset_dashboard=None)\nCreate a chat client with registered tools.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both.\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nCallback when update_dashboard tool succeeds.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nCallback when reset_dashboard tool is invoked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client.\n\n\n\n\n\n\n\nQueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\n\n\n\nQueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\n\n\n\nQueryChat.server(data_source=None, enable_bookmarking=False, id=None)\nInitialize Shiny server logic.\nThis method is intended for use in Shiny Code mode, where the user must explicitly call .server() within the Shiny server function. In Shiny Express mode, you can use querychat.express.QueryChat instead of querychat.QueryChat, which calls .server() automatically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nOptional[IntoFrame | sqlalchemy.Engine | ibis.Table]\nOptional data source to use. If provided, sets the data_source property before initializing server logic. This is useful for the deferred pattern where data_source is not known at initialization time.\nNone\n\n\nenable_bookmarking\nbool\nWhether to enable bookmarking for the querychat module.\nFalse\n\n\nid\nOptional[str]\nOptional module ID for the QueryChat instance. If not provided, will use the ID provided at initialization. This must match the ID used in the .ui() or .sidebar() methods.\nNone\n\n\n\n\n\n\nfrom shiny import App, render, ui\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\n\n\ndef app_ui(request):\n    return ui.page_sidebar(\n        qc.sidebar(),\n        ui.card(\n            ui.card_header(ui.output_text(\"title\")),\n            ui.output_data_frame(\"data_table\"),\n        ),\n        title=\"Titanic QueryChat App\",\n        fillable=True,\n    )\n\n\ndef server(input, output, session):\n    qc_vals = qc.server(enable_bookmarking=True)\n\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"My Data\"\n\n\napp = App(app_ui, server, bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nServerValues[IntoFrameT]\nA ServerValues dataclass containing session-specific reactive values and the chat client. See ServerValues documentation for details on the available attributes.\n\n\n\n\n\n\n\nQueryChat.sidebar(width=400, height='100%', fillable=True, id=None, **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nQueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html",
    "href": "reference/types.DataSource.html",
    "title": "types.DataSource",
    "section": "",
    "text": "DataSource()\nAn abstract class defining the interface for data sources used by QueryChat.\nThis class is generic over the DataFrame type returned by execute_query, test_query, and get_data methods.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntable_name\nstr\nName of the table to be used in SQL queries.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nexecute_query\nExecute SQL query and return results.\n\n\nget_data\nReturn the unfiltered data.\n\n\nget_db_type\nName for the database behind the SQL execution.\n\n\nget_schema\nReturn schema information about the table as a string.\n\n\nget_semantic_views_description\nGet information about semantic views (if any) for the system prompt.\n\n\ntest_query\nTest SQL query by fetching only one row.\n\n\n\n\n\ntypes.DataSource.cleanup()\nClean up resources associated with the data source.\nThis method should clean up any connections or resources used by the data source.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataSource.execute_query(query)\nExecute SQL query and return results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nQuery results\n\n\n\n\n\n\n\ntypes.DataSource.get_data()\nReturn the unfiltered data.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nThe complete dataset\n\n\n\n\n\n\n\ntypes.DataSource.get_db_type()\nName for the database behind the SQL execution.\n\n\n\ntypes.DataSource.get_schema(categorical_threshold)\nReturn schema information about the table as a string.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA string containing the schema information in a format suitable for prompting an LLM about the data structure\n\n\n\n\n\n\n\ntypes.DataSource.get_semantic_views_description()\nGet information about semantic views (if any) for the system prompt.\n\n\n\ntypes.DataSource.test_query(query, *, require_all_columns=False)\nTest SQL query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns. Additional computed columns are allowed.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html#attributes",
    "href": "reference/types.DataSource.html#attributes",
    "title": "types.DataSource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntable_name\nstr\nName of the table to be used in SQL queries.",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html#methods",
    "href": "reference/types.DataSource.html#methods",
    "title": "types.DataSource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nexecute_query\nExecute SQL query and return results.\n\n\nget_data\nReturn the unfiltered data.\n\n\nget_db_type\nName for the database behind the SQL execution.\n\n\nget_schema\nReturn schema information about the table as a string.\n\n\nget_semantic_views_description\nGet information about semantic views (if any) for the system prompt.\n\n\ntest_query\nTest SQL query by fetching only one row.\n\n\n\n\n\ntypes.DataSource.cleanup()\nClean up resources associated with the data source.\nThis method should clean up any connections or resources used by the data source.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataSource.execute_query(query)\nExecute SQL query and return results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nQuery results\n\n\n\n\n\n\n\ntypes.DataSource.get_data()\nReturn the unfiltered data.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nThe complete dataset\n\n\n\n\n\n\n\ntypes.DataSource.get_db_type()\nName for the database behind the SQL execution.\n\n\n\ntypes.DataSource.get_schema(categorical_threshold)\nReturn schema information about the table as a string.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA string containing the schema information in a format suitable for prompting an LLM about the data structure\n\n\n\n\n\n\n\ntypes.DataSource.get_semantic_views_description()\nGet information about semantic views (if any) for the system prompt.\n\n\n\ntypes.DataSource.test_query(query, *, require_all_columns=False)\nTest SQL query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns. Additional computed columns are allowed.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "build.html",
    "href": "build.html",
    "title": "Shiny",
    "section": "",
    "text": "Shiny is a web framework for building interactive data applications. It provides a reactive programming model that’s a natural fit for querychat.\nIn this guide, you’ll learn how to build Shiny apps with querychat to enable rich data exploration experiences where data views update based on natural language filters.",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "build.html#initialize-querychat",
    "href": "build.html#initialize-querychat",
    "title": "Shiny",
    "section": "Initialize QueryChat",
    "text": "Initialize QueryChat\nThe “main” QueryChat class is available directly from the top-level module, and it designed to work with Shiny (Core):\nfrom querychat import QueryChat\nFor Shiny Express, import from querychat.express instead (similar to how you import from shiny.express):\nfrom querychat.express import QueryChat\nOnce imported, initialize it with your data source:\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\n\n\n\n\n\n\nQuick start with .app()\n\n\n\n\n\nRemember, the simplest way to get started is with .app(), which gives a “pre-baked” Shiny app:\n\n\nshiny-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\n\nRun with:\nshiny run shiny-app.py",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "build.html#relevant-methods",
    "href": "build.html#relevant-methods",
    "title": "Shiny",
    "section": "Relevant methods",
    "text": "Relevant methods\nAfter initializing QueryChat, use .sidebar() or .ui() to place the chat interface in your app. As users interact with the chat, .df(), .sql(), and .title() automatically update to reflect the current query. Any Shiny outputs that depend on these reactive values will re-render automatically.\n\n\n\nMethod\nDescription\n\n\n\n\n.sidebar()\nPlace the chat interface in a sidebar\n\n\n.ui()\nReturns just the chat component for custom placement\n\n\n.df()\nCurrent filtered/sorted DataFrame\n\n\n.sql()\nCurrent SQL query (str | None)\n\n\n.title()\nShort description of current filter (str | None)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nShiny has two modes: Express (simple, script-based) and Core (explicit UI/server separation). With Core, call qc.server() in your server function and access reactives via the returned object (e.g., qc_vals.df()). With Express, access them directly on the QueryChat instance (e.g., qc.df()).",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "build.html#basic-sidebar",
    "href": "build.html#basic-sidebar",
    "title": "Shiny",
    "section": "Basic sidebar",
    "text": "Basic sidebar\nThe most common pattern places chat in the sidebar with your custom filtered views in the main area:\n\nExpressCore\n\n\nfrom pathlib import Path\n\nfrom shiny.express import render, ui\nfrom querychat.express import QueryChat\nfrom querychat.data import titanic\n\ngreeting = Path(__file__).parent / \"greeting.md\"\n\n# 1. Provide data source to QueryChat\nqc = QueryChat(titanic(), \"titanic\", greeting=greeting)\n\n# 2. Add sidebar chat control\nqc.sidebar()\n\n# 3. Add a card with reactive title and data frame\nwith ui.card():\n    with ui.card_header():\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n    \n# 4. Set some page options (optional)\nui.page_opts(\n    fillable=True,\n    title=\"Titanic Dataset Explorer\"\n)\n\n\n\n\n\n\nDeferred data sources\n\n\n\nSome data sources, like database connections or reactive calculations, may need to be created within an active Shiny session. To help support this, QueryChat allows you to initialize without a data source and provide it later, like this:\n\n\ndeferred-app.py\n\nfrom shiny.express import render, session, ui\nfrom querychat.express import QueryChat\n\n# Don't create connection until we have an actual session\nif session.is_stub_session():\n    conn = None\nelse:\n    conn = get_user_connection(session)\n\nqc = QueryChat(conn, \"users\")\nqc.sidebar()\n\n@render.data_frame\ndef table():\n    return qc.df()\n\n\n\n\n\nfrom pathlib import Path\n\nfrom shiny import App, render, ui\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\ngreeting = Path(__file__).parent / \"greeting.md\"\n\n# 1. Provide data source to QueryChat\nqc = QueryChat(titanic(), \"titanic\", greeting=greeting)\n\napp_ui = ui.page_sidebar(\n    # 2. Create sidebar chat control\n    qc.sidebar(),\n    ui.card(\n        ui.card_header(ui.output_text(\"title\")),\n        ui.output_data_frame(\"data_table\"),\n        fill=True,\n    ),\n    fillable=True\n)\n\n\ndef server(input, output, session):\n    # 3. Add server logic (to get reactive data frame and title)\n    qc_vals = qc.server()\n\n    # 4. Use the filtered/sorted data frame reactively\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"Titanic Dataset\"\n\n\napp = App(app_ui, server)\n\n\n\n\n\n\nDeferred data sources\n\n\n\nSome data sources, like database connections or reactive calculations, may need to be created within an active Shiny session. To help support this, QueryChat allows you to initialize without a data source and provide it later, like this:\n\n\ndeferred-app.py\n\nfrom shiny import App, ui\nfrom querychat import QueryChat\n\n# Global scope - create QueryChat without data source\nqc = QueryChat(None, \"users\")\n\napp_ui = ui.page_sidebar(\n    qc.sidebar(),\n    ui.output_data_frame(\"table\"),\n)\n\ndef server(input, output, session):\n    # Server scope - create connection with session credentials\n    conn = get_user_connection(session)\n    qc_vals = qc.server(data_source=conn)\n\n    @render.data_frame\n    def table():\n        return qc_vals.df()\n\napp = App(app_ui, server)",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "build.html#custom-chat-ui",
    "href": "build.html#custom-chat-ui",
    "title": "Shiny",
    "section": "Custom chat UI",
    "text": "Custom chat UI\nUse .ui() to place the chat anywhere in your layout. Here we use it simply to place custom content in the sidebar alongside the chat (like a reset button):\n\nExpressCore\n\n\nfrom shiny.express import ui\nfrom querychat.express import QueryChat\n\nqc = QueryChat(data, \"my_data\")\n\nwith ui.sidebar():\n    qc.ui()  # Chat component\n    ui.hr()\n    ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\")\n\n\nfrom shiny import ui\nfrom querychat import QueryChat\n\nqc = QueryChat(data, \"my_data\")\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        qc.ui(),  # Chat component\n        ui.hr(),\n        ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\"),\n    ),\n    # Main content here\n)\n\n\n\n\n\n\n\n\n\nCustom Shiny chat UIs\n\n\n\nLearn more about customizing Shiny chat UIs in the Shiny Chat documentation.",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "build.html#data-views",
    "href": "build.html#data-views",
    "title": "Shiny",
    "section": "Data views",
    "text": "Data views\nThe real power of querychat comes from connecting it to visualizations. Here’s an example showing both filtered data and a chart:\nimport plotly.express as px\n\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\n\nfrom querychat.express import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.sidebar()\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Data Table\")\n\n        @render.data_frame\n        def table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render_plotly\n        def survival_plot():\n            d = qc.df().to_native()  # Convert for pandas groupby()\n            summary = d.groupby('pclass')['survived'].mean().reset_index()\n            return px.bar(summary, x='pclass', y='survived')\nWhen users filter data through the chat (e.g., “show only children”), both charts update automatically.\n\nA more complete example adds metrics, tabs, and multiple views:\n\n\ntitanic-dashboard.py\nimport plotly.express as px\nfrom faicons import icon_svg\nfrom querychat.data import titanic\nfrom querychat.express import QueryChat\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.sidebar()\n\nwith ui.layout_column_wrap(fill=False):\n    with ui.value_box(showcase=icon_svg(\"users\")):\n        \"Passengers\"\n\n        @render.text\n        def count():\n            return str(len(qc.df()))\n\n    with ui.value_box(showcase=icon_svg(\"heart\")):\n        \"Survival Rate\"\n\n        @render.text\n        def survival():\n            rate = qc.df()[\"survived\"].mean() * 100\n            return f\"{rate:.1f}%\"\n\n    with ui.value_box(showcase=icon_svg(\"coins\")):\n        \"Avg Fare\"\n\n        @render.text\n        def fare():\n            avg = qc.df()[\"fare\"].mean()\n            return f\"${avg:.2f}\"\n\n\nwith ui.layout_columns():\n    with ui.card():\n        with ui.card_header():\n            \"Data Table\"\n\n            @render.text\n            def table_title():\n                return f\" - {qc.title()}\" if qc.title() else \"\"\n\n        @render.data_frame\n        def data_table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render_plotly\n        def survival_by_class():\n            df = qc.df().to_pandas()\n            summary = df.groupby(\"pclass\")[\"survived\"].mean().reset_index()\n            return px.bar(\n                summary,\n                x=\"pclass\",\n                y=\"survived\",\n                labels={\"pclass\": \"Class\", \"survived\": \"Survival Rate\"},\n            )\n\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Age Distribution\")\n\n        @render_plotly\n        def age_dist():\n            df = qc.df()\n            return px.histogram(df, x=\"age\", nbins=30)\n\n    with ui.card():\n        ui.card_header(\"Fare by Class\")\n\n        @render_plotly\n        def fare_by_class():\n            df = qc.df()\n            return px.box(df, x=\"pclass\", y=\"fare\", color=\"survived\")\n\n\nui.page_opts(\n    title=\"Titanic Survival Analysis\",\n    fillable=True,\n    class_=\"bslib-page-dashboard\",\n)\n\n\n\n\nResetting filters\nAdd a reset button to clear filters and show all data:\n\nExpressCore\n\n\nui.input_action_button(\"reset\", \"Reset Filters\")\n\n@reactive.effect\n@reactive.event(input.reset)\ndef _():\n    qc.sql(\"\")\n    qc.title(None)\n\n\nui.input_action_button(\"reset\", \"Reset Filters\")\n\nqc_vals = qc.server()\n\n@reactive.effect\n@reactive.event(input.reset)\ndef _():\n    qc_vals.sql.set(\"\")\n    qc_vals.title.set(None)\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nUsers can also ask the LLM to “reset” or “show all data” to clear filters through the chat interface.\n\n\n\n\nAdvanced patterns\n\nProgrammatic updates\nYou can update the query state programmatically using .sql() and .title() as setters. This is useful for adding preset filter buttons or linking filters to other UI controls.\n\n\nMultiple datasets\nTo explore multiple datasets, use separate QueryChat instances (i.e., separate chat interfaces).\n\n\n\n\n\n\nMultiple tables in one chat?\n\n\n\nIn some cases, you might be able to “pre-join” datasets into a single table and use one QueryChat instance to explore them together. In the future, we may support multiple filtered tables in one chat interface, but this is not currently available. Please upvote the relevant issue if this is a feature you’d like to see!\n\n\n\n\nmultiple-datasets.py\nfrom querychat.data import titanic\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import render, ui\n\npenguins = load_dataset(\"penguins\")\n\nqc_titanic = QueryChat(titanic(), \"titanic\")\nqc_penguins = QueryChat(penguins, \"penguins\")\n\nwith ui.sidebar():\n    with ui.panel_conditional(\"input.navbar == 'Titanic'\"):\n        qc_titanic.ui()\n    with ui.panel_conditional(\"input.navbar == 'Penguins'\"):\n        qc_penguins.ui()\n\nwith ui.nav_panel(\"Titanic\"):\n\n    @render.data_frame\n    def titanic_table():\n        return qc_titanic.df()\n\n\nwith ui.nav_panel(\"Penguins\"):\n\n    @render.data_frame\n    def penguins_table():\n        return qc_penguins.df()\n\n\nui.page_opts(\n    id=\"navbar\",\n    title=\"Multiple Datasets with querychat\",\n    fillable=True,\n)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nEach dataset gets its own chat interface and maintains separate state.",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "build.html#see-also",
    "href": "build.html#see-also",
    "title": "Shiny",
    "section": "See also",
    "text": "See also\n\nGreet users - Create welcoming onboarding experiences\nProvide context - Help the LLM understand your data better\nTools - Understand what querychat can do under the hood",
    "crumbs": [
      "Build custom apps",
      "Shiny"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Explore data using natural language queries\nquerychat facilitates safe and reliable natural language exploration of tabular data, powered by SQL and large language models (LLMs). For users, it offers an intuitive web application where they can quickly ask questions of their data and receive verifiable data-driven answers. As a developer, you can access the chat UI component, generated SQL queries, and filtered data to build custom applications that integrate natural language querying into your data workflows.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Introduction",
    "section": "Installation",
    "text": "Installation\nInstall the latest stable release from PyPI:\npip install querychat",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Introduction",
    "section": "Quick start",
    "text": "Quick start\nThe main entry point is the QueryChat class. It requires a data source (e.g., pandas, polars, etc) and a name for the data. It also accepts optional parameters to customize the behavior, such as the client model. The quickest way to start chatting is to call the .app() method, which by default returns a Shiny app:\n\n\napp.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\n\n\n\n\n\n\n\nPrefer Streamlit, Gradio, or Dash?\n\n\n\nquerychat supports multiple web frameworks—just change the import.\n\n\nWith an API key set1, save the code to app.py and run it:\nshiny run --reload app.py\nOnce running, you’ll notice 3 main views:\n\nA sidebar chat with suggestions on where to start exploring.\nA data table that updates to reflect filtering and sorting queries.\nThe SQL query behind the data table, for transparency and reproducibility.\n\n\nSuppose we pick a suggestion like “Show me passengers who survived”. Since this is a filtering operation, both the data table and SQL query update accordingly.\n\nquerychat can also handle more general questions about the data that require calculations and aggregations. For example, we can ask “What is the average age of passengers who survived?”. The LLM will generate the SQL query to perform the calculation, querychat will execute it, and return the result in the chat:",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#web-frameworks",
    "href": "index.html#web-frameworks",
    "title": "Introduction",
    "section": "Web frameworks",
    "text": "Web frameworks\nWhile the examples above use Shiny, querychat also supports Streamlit, Gradio, and Dash. Each framework has its own QueryChat class under the relevant sub-module, but the methods and properties are mostly consistent across all of them.\n\nStreamlitGradioDash\n\n\nfrom querychat.streamlit import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.app()\n\n\nfrom querychat.gradio import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.app().launch()\n\n\nfrom querychat.dash import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.app().run()\n\n\n\nInstall the framework you need with optional dependencies:\npip install \"querychat[streamlit]\"  # or [gradio] or [dash]",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#build-custom-apps",
    "href": "index.html#build-custom-apps",
    "title": "Introduction",
    "section": "Build custom apps",
    "text": "Build custom apps\nquerychat is designed to be highly extensible – it provides programmatic access to the chat interface, the filtered/sorted data frame, SQL queries, and more. This makes it easy to build custom web apps that leverage natural language interaction with your data. For example, here’s a bespoke app for exploring Airbnb listings in Ashville, NC:\n\nTo learn more, see the build guides for your framework: Shiny, Streamlit, Gradio, or Dash.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "Introduction",
    "section": "How it works",
    "text": "How it works\nquerychat uses LLMs to translate natural language into SQL queries. Models of all sizes, from small ones you can run locally to large frontier models from major AI providers, are remarkably effective at this task. But even the best models need to understand your data’s overall structure to perform well.\nTo address this, querychat includes schema metadata – column names, types, ranges, categorical values – in the LLM’s system prompt. Importantly, querychat does not send raw data to the LLM; it shares only enough structural information for the model to generate accurate queries. When the LLM produces a query, querychat executes it in a SQL database (DuckDB2, by default) to obtain precise results.\nThis design makes querychat reliable, safe, and reproducible:\n\nReliable: query results come from a real database, not LLM-generated summaries – so outputs are precise, verifiable, and less vulnerable to hallucination3.\nSafe: querychat’s tools are read-only by design, avoiding destructive actions on your data.4\nReproducible: generated SQL can be exported and re-run in other environments, so your analysis isn’t locked into a single tool.\n\n\n\n\n\n\n\nImportant\n\n\n\nData privacy\nSee the Provide context and Tools articles for more details on exactly what information is provided to the LLM and how customize it.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#next-steps",
    "href": "index.html#next-steps",
    "title": "Introduction",
    "section": "Next steps",
    "text": "Next steps\nFrom here, you might want to learn more about:\n\nModels: customize the LLM behind querychat.\nData sources: different data sources you can use with querychat.\nProvide context: provide the LLM with the context it needs to work well.\nBuild an app: Shiny | Streamlit | Gradio | Dash",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Introduction",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBy default, querychat uses OpenAI to power the chat experience. So, for this example to work, you’ll need an OpenAI API key. See the Models page for details on how to set up credentials for other model providers.↩︎\nDuckDB is extremely fast and has a surprising number of statistical functions.↩︎\nThe query tool gives query results to the model for context and interpretation. Thus, there is some potential that the model to mis-interpret those results.↩︎\nTo fully guarantee no destructive actions on your production database, ensure querychat’s database permissions are read-only.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Changelog",
    "section": "",
    "text": "All notable changes to this project will be documented in this file.\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.\n\n\n\n\n\nAdded support for Snowflake Semantic Views. When connected to Snowflake (via SQLAlchemy or Ibis), querychat automatically discovers available Semantic Views and includes their definitions in the system prompt. This helps the LLM generate correct queries using the SEMANTIC_VIEW() table function with certified business metrics and dimensions. (#200)\n\n\n\n\n\n\n\n\nQueryChat() now supports deferred data source initialization for Shiny Core applications. Pass data_source=None at initialization time, then provide the actual data source via the data_source parameter of server() or by setting the data_source property. This enables use cases where the data source depends on session-specific authentication or per-user database connections. (#202)\n\n\n\n\n\n\n\n\nAdded support for Gradio, Dash, and Streamlit web frameworks in addition to Shiny. Import from the new submodules:\n\nfrom querychat.gradio import QueryChat\nfrom querychat.dash import QueryChat\nfrom querychat.streamlit import QueryChat\n\n\nEach framework’s QueryChat provides .app() for quick standalone apps and .ui() for custom layouts. Install framework dependencies with pip extras: pip install querychat[gradio], pip install querychat[dash], or pip install querychat[streamlit]. (#190)\n\nQueryChat() gains support for more data sources:\n\npolars.LazyFrame: queries execute lazily via polars.SQLContext. In this case, .df() et al. methods will return a polars.LazyFrame. (#191)\nibis.Table: queries execute lazily via the Ibis backend’s SQL interface (DuckDB, PostgreSQL, BigQuery, etc.). In this case, .df() et al. methods will return an ibis.Table. (#193)\npyarrow.Table: queries execute in-memory via duckdb. In this case, .df() et al. methods will return a pyarrow.Table. (#196)\n\n\n\n\n\n\nImproved typing support for return types on .df() et al. (#196)\n\n\n\n\n\nDataFrameSource methods now (once again) return the input DataFrame type (e.g., pandas.DataFrame) instead of nw.DataFrame. (#196)\n\n\n\n\n\n\n\n\nMethods like execute_query(), get_data(), and df() now return a narwhals.DataFrame instead of a pandas.DataFrame. This allows querychat to drop its pandas dependency, and for you to use any narwhals-compatible dataframe of your choosing.\n\nIf this breaks existing code, note you can call .to_native() on the new dataframe value to get your pandas dataframe back.\nNote that polars or pandas will be needed to realize a sqlalchemy connection query as a dataframe. Install with pip install querychat[pandas] or pip install querychat[polars]\n\n\n\n\n\n\nQueryChat.console() was added to launch interactive console-based chat sessions with your data source, with persistent conversation state across invocations. (#168)\nQueryChat.client() can now create standalone querychat-enabled chat clients with configurable tools and callbacks, enabling use outside of Shiny applications. (#168)\nThe tools used in a QueryChat chatbot are now configurable. Use the new tools parameter of QueryChat() to select either or both \"query\" or \"update\" tools. Choose tools=[\"update\"] if you only want QueryChat to be able to update the dashboard (useful when you want to be 100% certain that the LLM will not see any raw data). (#168)\nQueryChat.sidebar(), QueryChat.ui(), and QueryChat.server() now support an optional id parameter to create multiple chat instances from a single QueryChat object. (#172)\n\n\n\n\n\nThe update tool now requires that the SQL query returns all columns from the original data source, ensuring that the dashboard can display the complete data frame after filtering or sorting. If the query does not return all columns, an informative error message will be provided. (#180)\nObvious SQL keywords that lead to data modification (e.g., INSERT, UPDATE, DELETE, DROP, etc.) are now prohibited in queries run via the query tool or update tool, to prevent accidental data changes. If such keywords are detected, an informative error message will be provided. (#180)\n\n\n\n\n\n\n\n\nThe entire functional API (i.e., init(), sidebar(), server(), etc) has been hard deprecated in favor of a simpler OOP-based API. Namely, the new QueryChat() class is now the main entry point (instead of init()) and has methods to replace old functions (e.g., .sidebar(), .server(), etc). (#101)\nThe .sql() method now returns None instead of \"\" (empty string) when no query has been set, aligning with the behavior of .title() for consistency. Most code using the or operator or req() for falsy checks will continue working without changes. Code that explicitly checks sql() == \"\" should be updated to use falsy checks (if not sql()) or explicit null checks (if sql() is None). (#146)\n\n\n\n\n\nNew QueryChat.app() method enables quicker/easier chatting with a dataset. (#104)\nEnabled bookmarking by default in both .app() and .server() methods. In latter case, you’ll need to also specify the bookmark_store (either in shiny.App() or shiny.express.app_opts()) for it to take effect. (#104)\nThe current SQL query and title can now be programmatically set through the .sql() and .title() methods of QueryChat(). (#98, #101)\nNew querychat.data module provides sample datasets (titanic() and tips()) to make it easier to get started without external dependencies. (#118)\nAdded a .generate_greeting() method to help you create a greeting message for your querychat bot. (#87)\nAdded querychat_reset_dashboard() tool for easily resetting the dashboard filters when asked by the user. (#81)\n\n\n\n\n\nAdded rich tool UI support using shinychat development version and chatlas &gt;= 0.11.1. (#67)\nquerychat’s system prompt and tool descriptions were rewritten for clarity and future extensibility. (#90)\nTool detail cards can now be expanded or collapsed by default when querychat runs a query or updates the dashboard via the QUERYCHAT_TOOL_DETAILS environment variable. Valid values are \"expanded\", \"collapsed\", or \"default\". (#137)\n\n\n\n\n\n\nFixed another issue with data sources that aren’t already narwhals DataFrames (#83)\n\n\n\n\n\nFixed an issue with the query tool when used with SQLAlchemy data sources. (@npelikan #79)\n\n\n\n\n\nquerychat.init() now accepts a client argument, replacing the previous create_chat_callback argument. (#60)\nThe client can be:\n\na chatlas.Chat object,\na function that returns a chatlas.Chat object,\nor a provider-model string, e.g. \"openai/gpt-4.1\", to be passed to chatlas.ChatAuto().\n\nIf client is not provided, querychat will use the QUERYCHAT_CLIENT environment variable, which should be a provider-model string. If the envvar is not set, querychat uses OpenAI with the default model from chatlas.ChatOpenAI().\nquerychat.ui() now adds a .querychat class to the chat container and querychat.sidebar() adds a .querychat-sidebar class to the sidebar, allowing for easier customization via CSS. (#68)\n\n\n\n\nThis first release of the querychat package."
  },
  {
    "objectID": "CHANGELOG.html#unreleased",
    "href": "CHANGELOG.html#unreleased",
    "title": "Changelog",
    "section": "",
    "text": "Added support for Snowflake Semantic Views. When connected to Snowflake (via SQLAlchemy or Ibis), querychat automatically discovers available Semantic Views and includes their definitions in the system prompt. This helps the LLM generate correct queries using the SEMANTIC_VIEW() table function with certified business metrics and dimensions. (#200)"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "Changelog",
    "section": "",
    "text": "QueryChat() now supports deferred data source initialization for Shiny Core applications. Pass data_source=None at initialization time, then provide the actual data source via the data_source parameter of server() or by setting the data_source property. This enables use cases where the data source depends on session-specific authentication or per-user database connections. (#202)"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "Changelog",
    "section": "",
    "text": "Added support for Gradio, Dash, and Streamlit web frameworks in addition to Shiny. Import from the new submodules:\n\nfrom querychat.gradio import QueryChat\nfrom querychat.dash import QueryChat\nfrom querychat.streamlit import QueryChat\n\n\nEach framework’s QueryChat provides .app() for quick standalone apps and .ui() for custom layouts. Install framework dependencies with pip extras: pip install querychat[gradio], pip install querychat[dash], or pip install querychat[streamlit]. (#190)\n\nQueryChat() gains support for more data sources:\n\npolars.LazyFrame: queries execute lazily via polars.SQLContext. In this case, .df() et al. methods will return a polars.LazyFrame. (#191)\nibis.Table: queries execute lazily via the Ibis backend’s SQL interface (DuckDB, PostgreSQL, BigQuery, etc.). In this case, .df() et al. methods will return an ibis.Table. (#193)\npyarrow.Table: queries execute in-memory via duckdb. In this case, .df() et al. methods will return a pyarrow.Table. (#196)\n\n\n\n\n\n\nImproved typing support for return types on .df() et al. (#196)\n\n\n\n\n\nDataFrameSource methods now (once again) return the input DataFrame type (e.g., pandas.DataFrame) instead of nw.DataFrame. (#196)"
  },
  {
    "objectID": "CHANGELOG.html#section-2",
    "href": "CHANGELOG.html#section-2",
    "title": "Changelog",
    "section": "",
    "text": "Methods like execute_query(), get_data(), and df() now return a narwhals.DataFrame instead of a pandas.DataFrame. This allows querychat to drop its pandas dependency, and for you to use any narwhals-compatible dataframe of your choosing.\n\nIf this breaks existing code, note you can call .to_native() on the new dataframe value to get your pandas dataframe back.\nNote that polars or pandas will be needed to realize a sqlalchemy connection query as a dataframe. Install with pip install querychat[pandas] or pip install querychat[polars]\n\n\n\n\n\n\nQueryChat.console() was added to launch interactive console-based chat sessions with your data source, with persistent conversation state across invocations. (#168)\nQueryChat.client() can now create standalone querychat-enabled chat clients with configurable tools and callbacks, enabling use outside of Shiny applications. (#168)\nThe tools used in a QueryChat chatbot are now configurable. Use the new tools parameter of QueryChat() to select either or both \"query\" or \"update\" tools. Choose tools=[\"update\"] if you only want QueryChat to be able to update the dashboard (useful when you want to be 100% certain that the LLM will not see any raw data). (#168)\nQueryChat.sidebar(), QueryChat.ui(), and QueryChat.server() now support an optional id parameter to create multiple chat instances from a single QueryChat object. (#172)\n\n\n\n\n\nThe update tool now requires that the SQL query returns all columns from the original data source, ensuring that the dashboard can display the complete data frame after filtering or sorting. If the query does not return all columns, an informative error message will be provided. (#180)\nObvious SQL keywords that lead to data modification (e.g., INSERT, UPDATE, DELETE, DROP, etc.) are now prohibited in queries run via the query tool or update tool, to prevent accidental data changes. If such keywords are detected, an informative error message will be provided. (#180)"
  },
  {
    "objectID": "CHANGELOG.html#section-3",
    "href": "CHANGELOG.html#section-3",
    "title": "Changelog",
    "section": "",
    "text": "The entire functional API (i.e., init(), sidebar(), server(), etc) has been hard deprecated in favor of a simpler OOP-based API. Namely, the new QueryChat() class is now the main entry point (instead of init()) and has methods to replace old functions (e.g., .sidebar(), .server(), etc). (#101)\nThe .sql() method now returns None instead of \"\" (empty string) when no query has been set, aligning with the behavior of .title() for consistency. Most code using the or operator or req() for falsy checks will continue working without changes. Code that explicitly checks sql() == \"\" should be updated to use falsy checks (if not sql()) or explicit null checks (if sql() is None). (#146)\n\n\n\n\n\nNew QueryChat.app() method enables quicker/easier chatting with a dataset. (#104)\nEnabled bookmarking by default in both .app() and .server() methods. In latter case, you’ll need to also specify the bookmark_store (either in shiny.App() or shiny.express.app_opts()) for it to take effect. (#104)\nThe current SQL query and title can now be programmatically set through the .sql() and .title() methods of QueryChat(). (#98, #101)\nNew querychat.data module provides sample datasets (titanic() and tips()) to make it easier to get started without external dependencies. (#118)\nAdded a .generate_greeting() method to help you create a greeting message for your querychat bot. (#87)\nAdded querychat_reset_dashboard() tool for easily resetting the dashboard filters when asked by the user. (#81)\n\n\n\n\n\nAdded rich tool UI support using shinychat development version and chatlas &gt;= 0.11.1. (#67)\nquerychat’s system prompt and tool descriptions were rewritten for clarity and future extensibility. (#90)\nTool detail cards can now be expanded or collapsed by default when querychat runs a query or updates the dashboard via the QUERYCHAT_TOOL_DETAILS environment variable. Valid values are \"expanded\", \"collapsed\", or \"default\". (#137)"
  },
  {
    "objectID": "CHANGELOG.html#section-4",
    "href": "CHANGELOG.html#section-4",
    "title": "Changelog",
    "section": "",
    "text": "Fixed another issue with data sources that aren’t already narwhals DataFrames (#83)"
  },
  {
    "objectID": "CHANGELOG.html#section-5",
    "href": "CHANGELOG.html#section-5",
    "title": "Changelog",
    "section": "",
    "text": "Fixed an issue with the query tool when used with SQLAlchemy data sources. (@npelikan #79)"
  },
  {
    "objectID": "CHANGELOG.html#section-6",
    "href": "CHANGELOG.html#section-6",
    "title": "Changelog",
    "section": "",
    "text": "querychat.init() now accepts a client argument, replacing the previous create_chat_callback argument. (#60)\nThe client can be:\n\na chatlas.Chat object,\na function that returns a chatlas.Chat object,\nor a provider-model string, e.g. \"openai/gpt-4.1\", to be passed to chatlas.ChatAuto().\n\nIf client is not provided, querychat will use the QUERYCHAT_CLIENT environment variable, which should be a provider-model string. If the envvar is not set, querychat uses OpenAI with the default model from chatlas.ChatOpenAI().\nquerychat.ui() now adds a .querychat class to the chat container and querychat.sidebar() adds a .querychat-sidebar class to the sidebar, allowing for easier customization via CSS. (#68)"
  },
  {
    "objectID": "CHANGELOG.html#section-7",
    "href": "CHANGELOG.html#section-7",
    "title": "Changelog",
    "section": "",
    "text": "This first release of the querychat package."
  },
  {
    "objectID": "models.html",
    "href": "models.html",
    "title": "Models",
    "section": "",
    "text": "Under the hood, querychat is powered by chatlas, a library for building chat-based applications with large language models (LLMs). chatlas supports a wide range of LLM providers – see here for a full list.\n\nSpecify a model\nTo use a particular model, pass a \"{provider}/{model}\" string to the client parameter, which gets passed along to chatlas.ChatAuto\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(\n    titanic(),\n    \"titanic\",\n    client=\"anthropic/claude-sonnet-4-5\"\n)\nAnd, if you’d like to effectively set a new default model, you can use the QUERYCHAT_CLIENT environment variable.\nexport QUERYCHAT_CLIENT=\"anthropic/claude-sonnet-4-5\"\nNote that it can also be useful to pass a full Chat object to the client parameter for more advanced use cases (e.g., custom parameters, tools, etc). It can also be useful for getting some helpful autocomplete of available models.\nfrom chatlas import ChatAnthropic\n\nclient = ChatAnthropic(model=\"claude-sonnet-4-5\")\n\n\nCredentials\nMost models require an API key or some other form of authentication. See the reference page for the relevant model provider (e.g., ChatAnthropic) to learn more on how to set up credentials.\n\n\n\n\n\n\nGithub model marketplace\n\n\n\nIf you are already setup with Github credentials, Github model marketplace provides a free and easy way to get started. See here for more details on how to get setup.\n\n\ngithub-model.py\n\nfrom chatlas import ChatGithub\n\n# Just works if GITHUB_TOKEN is set in your environment\nclient = ChatGithub(model=\"gpt-4.1\")\n\n\n\nIn general, most providers will prefer credentials stored as environment variables, and common practice is to use a .env file to manage these variables. For example, for ChatOpenAI(), you might create a .env file like so:\n\n\n.env\n\nOPENAI_API_KEY=\"your_api_key_here\"\n\nThen, load the environment variables via the dotenv package:\npip install dotenv\nfrom dotenv import load_dotenv\nload_dotenv()\n\n\nRecommended models\nIn theory, you could use any model that has tool calling support, but we currently recommend (as of November 2025):\n\nGPT-4.1 (the default)\nClaude 4.5 Sonnet\nGoogle Gemini 3.0\n\nIn our testing, we’ve found that those models strike a good balance between accuracy and latency. That said, smaller/faster models like GPT-4.1-mini or Claude Haiku 4.5 work well for most tables and are worth trying first—they’re significantly cheaper and faster. You can always switch to a larger model if you find the results aren’t meeting your needs. On the other end of the spectrum, reasoning models like o3-mini tend to slow down responses without providing meaningfully better results for this task.\nWe’ve also seen some decent results with frontier local models (e.g., gpt-oss:20b), but even if you have the compute to run the largest models, they still tend to lag behind the cloud-hosted options in terms of accuracy and speed.\n\n\n\n\n\n\nData privacy concerns?\n\n\n\nIf you have data privacy concerns, consider that your org may provide access to private instances of these models with data residency guarantees. For example, Azure, AWS Bedrock, and Google Vertex AI all provide private instances of popular LLMs. You can interface with these enterprise providers by passing the right string (e.g., \"bedrock-anthropic\") or Chat object (e.g., ChatBedrockAnthropic()) to the client parameter. See the chatlas docs for more details.",
    "crumbs": [
      "Get started",
      "Models"
    ]
  },
  {
    "objectID": "reference/types.SQLAlchemySource.html",
    "href": "reference/types.SQLAlchemySource.html",
    "title": "types.SQLAlchemySource",
    "section": "",
    "text": "SQLAlchemySource(engine, table_name)\nA DataSource implementation that supports multiple SQL databases via SQLAlchemy.\nSupports various databases including PostgreSQL, MySQL, SQLite, Snowflake, and Databricks.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nDispose of the SQLAlchemy engine.\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from database table.\n\n\nget_semantic_views_description\nGet information about semantic views (if any) for the system prompt.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.SQLAlchemySource.cleanup()\nDispose of the SQLAlchemy engine.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnw.DataFrame\nQuery results as narwhals DataFrame\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnw.DataFrame\nThe complete dataset as narwhals DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_db_type()\nGet the database type.\nReturns the specific database type (e.g., POSTGRESQL, MYSQL, SQLITE) by inspecting the SQLAlchemy engine. Removes ” SQL” suffix if present.\n\n\n\ntypes.SQLAlchemySource.get_schema(categorical_threshold)\nGenerate schema information from database table.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_semantic_views_description()\nGet information about semantic views (if any) for the system prompt.\n\n\n\ntypes.SQLAlchemySource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnw.DataFrame\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.SQLAlchemySource"
    ]
  },
  {
    "objectID": "reference/types.SQLAlchemySource.html#methods",
    "href": "reference/types.SQLAlchemySource.html#methods",
    "title": "types.SQLAlchemySource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nDispose of the SQLAlchemy engine.\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from database table.\n\n\nget_semantic_views_description\nGet information about semantic views (if any) for the system prompt.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.SQLAlchemySource.cleanup()\nDispose of the SQLAlchemy engine.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnw.DataFrame\nQuery results as narwhals DataFrame\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnw.DataFrame\nThe complete dataset as narwhals DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_db_type()\nGet the database type.\nReturns the specific database type (e.g., POSTGRESQL, MYSQL, SQLITE) by inspecting the SQLAlchemy engine. Removes ” SQL” suffix if present.\n\n\n\ntypes.SQLAlchemySource.get_schema(categorical_threshold)\nGenerate schema information from database table.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_semantic_views_description()\nGet information about semantic views (if any) for the system prompt.\n\n\n\ntypes.SQLAlchemySource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnw.DataFrame\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.SQLAlchemySource"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "The starting point for any QueryChat session\n\n\n\nQueryChat\nCreate a QueryChat instance for Shiny applications.\n\n\nexpress.QueryChat\nUse QueryChat with Shiny Express.\n\n\n\n\n\n\nSession-specific reactive values representing the current query\n\n\n\ntypes.ServerValues\nSession-specific reactive values and client returned by QueryChat.server().\n\n\n\n\n\n\nThe underlying logic for managing data sources\n\n\n\ntypes.DataSource\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\ntypes.DataFrameSource\nA DataSource implementation that wraps a DataFrame using DuckDB.\n\n\ntypes.SQLAlchemySource\nA DataSource implementation that supports multiple SQL databases via\n\n\n\n\n\n\nThe underlying tools provided to the LLM\n\n\n\ntools.tool_query\nCreate a tool that performs a SQL query on the data.\n\n\ntools.tool_update_dashboard\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\ntools.tool_reset_dashboard\nCreate a tool that resets the dashboard to show all data.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#the-querychat-class",
    "href": "reference/index.html#the-querychat-class",
    "title": "Function reference",
    "section": "",
    "text": "The starting point for any QueryChat session\n\n\n\nQueryChat\nCreate a QueryChat instance for Shiny applications.\n\n\nexpress.QueryChat\nUse QueryChat with Shiny Express.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reactive-values",
    "href": "reference/index.html#reactive-values",
    "title": "Function reference",
    "section": "",
    "text": "Session-specific reactive values representing the current query\n\n\n\ntypes.ServerValues\nSession-specific reactive values and client returned by QueryChat.server().",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#data-sources",
    "href": "reference/index.html#data-sources",
    "title": "Function reference",
    "section": "",
    "text": "The underlying logic for managing data sources\n\n\n\ntypes.DataSource\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\ntypes.DataFrameSource\nA DataSource implementation that wraps a DataFrame using DuckDB.\n\n\ntypes.SQLAlchemySource\nA DataSource implementation that supports multiple SQL databases via",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#tools",
    "href": "reference/index.html#tools",
    "title": "Function reference",
    "section": "",
    "text": "The underlying tools provided to the LLM\n\n\n\ntools.tool_query\nCreate a tool that performs a SQL query on the data.\n\n\ntools.tool_update_dashboard\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\ntools.tool_reset_dashboard\nCreate a tool that resets the dashboard to show all data.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/types.DataFrameSource.html",
    "href": "reference/types.DataFrameSource.html",
    "title": "types.DataFrameSource",
    "section": "",
    "text": "DataFrameSource(df, table_name)\nA DataSource implementation that wraps a DataFrame using DuckDB.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nClose the DuckDB connection.\n\n\nexecute_query\nExecute query using DuckDB.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from DataFrame.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.DataFrameSource.cleanup()\nClose the DuckDB connection.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataFrameSource.execute_query(query)\nExecute query using DuckDB.\nReturns results in the same format as the input DataFrame (polars or pandas).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoDataFrameT\nQuery results as native DataFrame (polars or pandas, matching input)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoDataFrameT\nThe complete dataset as native DataFrame (polars or pandas, matching input)\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_db_type()\nGet the database type.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe string “DuckDB”\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_schema(categorical_threshold)\nGenerate schema information from DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema\n\n\n\n\n\n\n\ntypes.DataFrameSource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoDataFrameT\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataFrameSource"
    ]
  },
  {
    "objectID": "reference/types.DataFrameSource.html#methods",
    "href": "reference/types.DataFrameSource.html#methods",
    "title": "types.DataFrameSource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nClose the DuckDB connection.\n\n\nexecute_query\nExecute query using DuckDB.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from DataFrame.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.DataFrameSource.cleanup()\nClose the DuckDB connection.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataFrameSource.execute_query(query)\nExecute query using DuckDB.\nReturns results in the same format as the input DataFrame (polars or pandas).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoDataFrameT\nQuery results as native DataFrame (polars or pandas, matching input)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoDataFrameT\nThe complete dataset as native DataFrame (polars or pandas, matching input)\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_db_type()\nGet the database type.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe string “DuckDB”\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_schema(categorical_threshold)\nGenerate schema information from DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema\n\n\n\n\n\n\n\ntypes.DataFrameSource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoDataFrameT\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataFrameSource"
    ]
  },
  {
    "objectID": "reference/types.ServerValues.html",
    "href": "reference/types.ServerValues.html",
    "title": "types.ServerValues",
    "section": "",
    "text": "types.ServerValues(df, sql, title, client)\nSession-specific reactive values and client returned by QueryChat.server().\nThis dataclass contains all the session-specific reactive state for a QueryChat instance. Each session gets its own ServerValues to ensure proper isolation between concurrent sessions.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\nCallable[[], IntoFrameT]\nA reactive Calc that returns the current filtered data frame or lazy frame. If the data source is lazy, returns a LazyFrame. If no SQL query has been set, this returns the unfiltered data from the data source. Call it like .df() to reactively read the current data.\n\n\nsql\nReactiveStringOrNone\nA reactive Value containing the current SQL query string. Access the value by calling .sql(), or set it with .sql.set(\"SELECT ...\"). Returns None if no query has been set.\n\n\ntitle\nReactiveStringOrNone\nA reactive Value containing the current title for the query. The LLM provides this title when generating a new SQL query. Access it with .title(), or set it with .title.set(\"...\"). Returns None if no title has been set.\n\n\nclient\nchatlas.Chat\nThe session-specific chat client instance. This is a deep copy of the base client configured for this specific session, containing the chat history and tool registrations for this session only.",
    "crumbs": [
      "API Reference",
      "Reactive values",
      "types.ServerValues"
    ]
  },
  {
    "objectID": "reference/types.ServerValues.html#attributes",
    "href": "reference/types.ServerValues.html#attributes",
    "title": "types.ServerValues",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndf\nCallable[[], IntoFrameT]\nA reactive Calc that returns the current filtered data frame or lazy frame. If the data source is lazy, returns a LazyFrame. If no SQL query has been set, this returns the unfiltered data from the data source. Call it like .df() to reactively read the current data.\n\n\nsql\nReactiveStringOrNone\nA reactive Value containing the current SQL query string. Access the value by calling .sql(), or set it with .sql.set(\"SELECT ...\"). Returns None if no query has been set.\n\n\ntitle\nReactiveStringOrNone\nA reactive Value containing the current title for the query. The LLM provides this title when generating a new SQL query. Access it with .title(), or set it with .title.set(\"...\"). Returns None if no title has been set.\n\n\nclient\nchatlas.Chat\nThe session-specific chat client instance. This is a deep copy of the base client configured for this specific session, containing the chat history and tool registrations for this session only.",
    "crumbs": [
      "API Reference",
      "Reactive values",
      "types.ServerValues"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html",
    "href": "reference/express.QueryChat.html",
    "title": "express.QueryChat",
    "section": "",
    "text": "express.QueryChat(\n    data_source,\n    table_name,\n    *,\n    id=None,\n    greeting=None,\n    client=None,\n    data_description=None,\n    categorical_threshold=20,\n    extra_instructions=None,\n    prompt_template=None,\n    enable_bookmarking='auto',\n)\nUse QueryChat with Shiny Express.\nThis class makes it easy to use querychat within Shiny Express apps – it automatically calls .server() during initialization, so you don’t have to do it manually.\n\n\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import app_opts, render, ui\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.card(fill=True):\n    with ui.card_header():\n\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n\n\nui.page_opts(\n    title=\"Titanic QueryChat App\",\n    fillable=True,\n)\n\napp_opts(bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine | ibis.Table | None\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against. Can be None for deferred binding (set via the data_source property before the real session starts).\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ndf\nReactively read the current filtered data frame that is in effect.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nsql\nReactively read (or set) the current SQL query that is in effect.\n\n\ntitle\nReactively read (or set) the current title that is in effect.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nexpress.QueryChat.cleanup()\nClean up resources associated with the data source.\n\n\n\nexpress.QueryChat.client(\n    tools=MISSING,\n    update_dashboard=None,\n    reset_dashboard=None,\n)\nCreate a chat client with registered tools.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both.\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nCallback when update_dashboard tool succeeds.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nCallback when reset_dashboard tool is invoked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client.\n\n\n\n\n\n\n\nexpress.QueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\n\n\n\nexpress.QueryChat.df()\nReactively read the current filtered data frame that is in effect.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nThe current filtered data frame, in the same format as the original data source (e.g., polars DataFrame, Polars LazyFrame, Ibis Table). If no query has been set, returns the unfiltered data from the data source.\n\n\n\n\n\n\n\nexpress.QueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\n\n\n\nexpress.QueryChat.sidebar(\n    width=400,\n    height='100%',\n    fillable=True,\n    id=None,\n    **kwargs,\n)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nexpress.QueryChat.sql(query=None)\nReactively read (or set) the current SQL query that is in effect.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nOptional[str]\nIf provided, sets the current SQL query to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no query is provided, returns the current SQL query as a string (or None if no query has been set). If a query is provided, returns True if the query was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.title(value=None)\nReactively read (or set) the current title that is in effect.\nThe title is a short description of the current query that the LLM provides to us whenever it generates a new SQL query. It can be used as a status string for the data dashboard.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nOptional[str]\nIf provided, sets the current title to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no value is provided, returns the current title as a string, or None if no title has been set due to no SQL query being set. If a value is provided, sets the current title to this value and returns True if the title was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#examples",
    "href": "reference/express.QueryChat.html#examples",
    "title": "express.QueryChat",
    "section": "",
    "text": "from querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import app_opts, render, ui\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.card(fill=True):\n    with ui.card_header():\n\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n\n\nui.page_opts(\n    title=\"Titanic QueryChat App\",\n    fillable=True,\n)\n\napp_opts(bookmark_store=\"url\")",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#parameters",
    "href": "reference/express.QueryChat.html#parameters",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine | ibis.Table | None\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against. Can be None for deferred binding (set via the data_source property before the real session starts).\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#attributes",
    "href": "reference/express.QueryChat.html#attributes",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#methods",
    "href": "reference/express.QueryChat.html#methods",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ndf\nReactively read the current filtered data frame that is in effect.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nsql\nReactively read (or set) the current SQL query that is in effect.\n\n\ntitle\nReactively read (or set) the current title that is in effect.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nexpress.QueryChat.cleanup()\nClean up resources associated with the data source.\n\n\n\nexpress.QueryChat.client(\n    tools=MISSING,\n    update_dashboard=None,\n    reset_dashboard=None,\n)\nCreate a chat client with registered tools.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both.\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nCallback when update_dashboard tool succeeds.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nCallback when reset_dashboard tool is invoked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client.\n\n\n\n\n\n\n\nexpress.QueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\n\n\n\nexpress.QueryChat.df()\nReactively read the current filtered data frame that is in effect.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntoFrameT\nThe current filtered data frame, in the same format as the original data source (e.g., polars DataFrame, Polars LazyFrame, Ibis Table). If no query has been set, returns the unfiltered data from the data source.\n\n\n\n\n\n\n\nexpress.QueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\n\n\n\nexpress.QueryChat.sidebar(\n    width=400,\n    height='100%',\n    fillable=True,\n    id=None,\n    **kwargs,\n)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nexpress.QueryChat.sql(query=None)\nReactively read (or set) the current SQL query that is in effect.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nOptional[str]\nIf provided, sets the current SQL query to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no query is provided, returns the current SQL query as a string (or None if no query has been set). If a query is provided, returns True if the query was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.title(value=None)\nReactively read (or set) the current title that is in effect.\nThe title is a short description of the current query that the LLM provides to us whenever it generates a new SQL query. It can be used as a status string for the data dashboard.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nOptional[str]\nIf provided, sets the current title to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no value is provided, returns the current title as a string, or None if no title has been set due to no SQL query being set. If a value is provided, sets the current title to this value and returns True if the title was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "build-dash.html",
    "href": "build-dash.html",
    "title": "Dash",
    "section": "",
    "text": "Dash is a web framework for building interactive data applications. It provides a callback-based programming model that is designed for scaling to heavy load with simple infrastructure.\nIn this guide, you’ll learn how to build Dash apps with querychat to enable rich data exploration experiences where data views update based on natural language filters.",
    "crumbs": [
      "Build custom apps",
      "Dash"
    ]
  },
  {
    "objectID": "build-dash.html#initialize-querychat",
    "href": "build-dash.html#initialize-querychat",
    "title": "Dash",
    "section": "Initialize QueryChat",
    "text": "Initialize QueryChat\nFirst, install querychat with Dash support:\npip install \"querychat[dash]\"\nThen import the Dash-specific QueryChat class:\nfrom querychat.dash import QueryChat\nAnd initialize it with your data source:\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\n\n\n\n\n\n\nQuick start with .app()\n\n\n\n\n\nRemember, the simplest way to get started is with .app(), which gives a “pre-baked” Dash app:\n\n\ndash-app.py\n\nfrom querychat.dash import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\nRun with:\npython dash-app.py",
    "crumbs": [
      "Build custom apps",
      "Dash"
    ]
  },
  {
    "objectID": "build-dash.html#relevant-methods",
    "href": "build-dash.html#relevant-methods",
    "title": "Dash",
    "section": "Relevant methods",
    "text": "Relevant methods\nAfter initializing QueryChat, use .ui() to place the chat interface in your layout, then call .init_app(app) to register querychat’s callbacks. As users interact with the chat, the store at .store_id updates automatically. Use Input(qc.store_id, \"data\") in your callbacks, then access values with .df(state), .sql(state), and .title(state).\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n.ui()\nReturns the chat UI component\n\n\n.init_app(app)\nRegisters querychat’s internal callbacks on your Dash app\n\n\n.store_id\nID of the dcc.Store component holding query state\n\n\n.df(state)\nCurrent filtered/sorted DataFrame\n\n\n.sql(state)\nCurrent SQL query (str | None)\n\n\n.title(state)\nShort description of current filter (str | None)",
    "crumbs": [
      "Build custom apps",
      "Dash"
    ]
  },
  {
    "objectID": "build-dash.html#basic-layout",
    "href": "build-dash.html#basic-layout",
    "title": "Dash",
    "section": "Basic layout",
    "text": "Basic layout\nThe most common pattern places chat alongside your custom filtered views:\n\n\ndash-custom.py\nimport dash_ag_grid as dag\nimport dash_bootstrap_components as dbc\nfrom querychat.dash import QueryChat\nfrom querychat.data import titanic\nfrom querychat.types import AppStateDict\n\nfrom dash import Dash, Input, Output, html\n\nqc = QueryChat(titanic(), \"titanic\")\n\napp = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n\napp.layout = dbc.Container(\n    [\n        dbc.Row(\n            [\n                # Left column: Chat\n                dbc.Col(qc.ui(), width=4),\n                # Right column: Data display\n                dbc.Col(\n                    [\n                        html.H3(id=\"data-title\"),\n                        dag.AgGrid(\n                            id=\"data-table\",\n                            className=\"ag-theme-balham\",\n                            defaultColDef={\"filter\": True, \"sortable\": True},\n                            dashGridOptions={\n                                \"pagination\": True,\n                                \"paginationPageSize\": 10,\n                            },\n                            columnSize=\"responsiveSizeToFit\",\n                        ),\n                        html.Pre(id=\"sql-display\"),\n                    ],\n                    width=8,\n                ),\n            ]\n        )\n    ],\n    fluid=True,\n)\n\n# Register querychat's internal callbacks\nqc.init_app(app)\n\n\n# Add your own callbacks using qc.store_id\n@app.callback(\n    [\n        Output(\"data-title\", \"children\"),\n        Output(\"data-table\", \"rowData\"),\n        Output(\"data-table\", \"columnDefs\"),\n        Output(\"sql-display\", \"children\"),\n    ],\n    Input(qc.store_id, \"data\"),\n)\ndef update_display(state: AppStateDict):\n    df = qc.df(state).to_pandas()\n    sql = qc.sql(state) or f\"SELECT * FROM {qc.data_source.table_name}\"\n    title = qc.title(state) or \"All Data\"\n\n    columns = [{\"field\": c} for c in df.columns]\n    return title, df.to_dict(\"records\"), columns, sql\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)",
    "crumbs": [
      "Build custom apps",
      "Dash"
    ]
  },
  {
    "objectID": "build-dash.html#data-views",
    "href": "build-dash.html#data-views",
    "title": "Dash",
    "section": "Data views",
    "text": "Data views\nThe real power of querychat comes from connecting it to visualizations. Here’s an example showing both filtered data and charts:\n\nimport dash_bootstrap_components as dbc\nimport plotly.express as px\nfrom querychat.dash import QueryChat\nfrom querychat.data import titanic\nfrom querychat.types import AppStateDict\n\nfrom dash import Dash, Input, Output, dcc\n\nqc = QueryChat(titanic(), \"titanic\")\n\napp = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n\napp.layout = dbc.Container(\n    [\n        dbc.Row(\n            [\n                dbc.Col(qc.ui(), width=4),\n                dbc.Col(\n                    [\n                        dcc.Graph(id=\"age-histogram\"),\n                        dcc.Graph(id=\"class-survival\"),\n                    ],\n                    width=8,\n                ),\n            ]\n        )\n    ],\n    fluid=True,\n)\n\nqc.init_app(app)\n\n\n@app.callback(\n    [Output(\"age-histogram\", \"figure\"), Output(\"class-survival\", \"figure\")],\n    Input(qc.store_id, \"data\"),\n)\ndef update_charts(state: AppStateDict):\n    df = qc.df(state).to_pandas()\n    fig1 = px.histogram(df, x=\"age\", color=\"survived\", title=\"Age Distribution\")\n    fig2 = px.bar(\n        df.groupby(\"pclass\")[\"survived\"].mean().reset_index(),\n        x=\"pclass\",\n        y=\"survived\",\n        title=\"Survival by Class\",\n    )\n    return fig1, fig2\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\nWhen users filter data through the chat (e.g., “show only survivors”), both charts update automatically.\n\nA more complete example adds metrics:\n\n\ndash-complete.py\nimport dash_bootstrap_components as dbc\nimport plotly.express as px\nfrom querychat.dash import QueryChat\nfrom querychat.data import titanic\nfrom querychat.types import AppStateDict\n\nfrom dash import Dash, Input, Output, dcc, html\n\nqc = QueryChat(titanic(), \"titanic\")\n\napp = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n\napp.layout = dbc.Container(\n    [\n        html.H1(\"Titanic Dataset Explorer\", className=\"my-3\"),\n        dbc.Row(\n            [\n                dbc.Col(qc.ui(), width=4),\n                dbc.Col(\n                    [\n                        html.H3(id=\"data-title\", className=\"mb-3\"),\n                        dbc.Row(\n                            [\n                                dbc.Col(\n                                    dbc.Card(\n                                        [\n                                            dbc.CardHeader(\"Passengers\"),\n                                            dbc.CardBody(\n                                                html.H4(id=\"metric-passengers\")\n                                            ),\n                                        ]\n                                    )\n                                ),\n                                dbc.Col(\n                                    dbc.Card(\n                                        [\n                                            dbc.CardHeader(\"Survivors\"),\n                                            dbc.CardBody(\n                                                html.H4(id=\"metric-survivors\")\n                                            ),\n                                        ]\n                                    )\n                                ),\n                                dbc.Col(\n                                    dbc.Card(\n                                        [\n                                            dbc.CardHeader(\"Survival Rate\"),\n                                            dbc.CardBody(html.H4(id=\"metric-rate\")),\n                                        ]\n                                    )\n                                ),\n                            ],\n                            className=\"mb-3\",\n                        ),\n                        dbc.Row(\n                            [\n                                dbc.Col(dcc.Graph(id=\"age-chart\")),\n                                dbc.Col(dcc.Graph(id=\"class-chart\")),\n                            ]\n                        ),\n                    ],\n                    width=8,\n                ),\n            ]\n        ),\n    ],\n    fluid=True,\n)\n\nqc.init_app(app)\n\n\n@app.callback(\n    [\n        Output(\"data-title\", \"children\"),\n        Output(\"metric-passengers\", \"children\"),\n        Output(\"metric-survivors\", \"children\"),\n        Output(\"metric-rate\", \"children\"),\n        Output(\"age-chart\", \"figure\"),\n        Output(\"class-chart\", \"figure\"),\n    ],\n    Input(qc.store_id, \"data\"),\n)\ndef update_all(state: AppStateDict):\n    df = qc.df(state).to_pandas()\n    title = qc.title(state) or \"All Data\"\n\n    # Metrics\n    n_passengers = len(df)\n    n_survivors = int(df[\"survived\"].sum())\n    survival_rate = f\"{df['survived'].mean():.1%}\"\n\n    # Charts\n    fig1 = px.histogram(\n        df, x=\"age\", color=\"survived\", title=\"Age Distribution by Survival\"\n    )\n    fig2 = px.bar(\n        df.groupby(\"pclass\")[\"survived\"].mean().reset_index(),\n        x=\"pclass\",\n        y=\"survived\",\n        title=\"Survival by Class\",\n    )\n\n    return (\n        title,\n        n_passengers,\n        n_survivors,\n        survival_rate,\n        fig1,\n        fig2,\n    )\n\n\nif __name__ == \"__main__\":\n    import os\n\n    port = int(os.environ.get(\"DASH_PORT\", \"8050\"))\n    debug = os.environ.get(\"DASH_DEBUG\", \"true\").lower() == \"true\"\n    app.run(debug=debug, port=port)\n\n\n\n\nResetting filters\nAdd a reset button to show all data by fetching the original data from qc.data_source.get_data():\nreset_btn = html.Button(\"Reset\", id=\"reset-btn\")\n\n@app.callback(\n    Output(\"data-table\", \"rowData\"),\n    [Input(qc.store_id, \"data\"), Input(\"reset-btn\", \"n_clicks\")],\n)\ndef update_table(state, n_clicks):\n    from dash import callback_context\n    if callback_context.triggered_id == \"reset-btn\":\n        return qc.data_source.get_data().to_pandas().to_dict(\"records\")\n    return qc.df(state).to_pandas().to_dict(\"records\")\n\n\n\n\n\n\nTip\n\n\n\nThis resets the data display only. Users can also ask the LLM to “reset” or “show all data” to clear filters through the chat interface.\n\n\n\n\nAdvanced patterns\n\nProgrammatic updates\nYou can update the display programmatically by creating callbacks that execute queries directly:\n@app.callback(\n    Output(\"data-table\", \"rowData\"),\n    Output(\"data-title\", \"children\"),\n    Input(\"preset-survivors\", \"n_clicks\"),\n    prevent_initial_call=True\n)\ndef apply_preset_filter(n_clicks):\n    df = qc.data_source.execute_query(\n        \"SELECT * FROM titanic WHERE survived = 1\"\n    )\n    return df.to_pandas().to_dict(\"records\"), \"Survivors only\"\n\n\nMultiple datasets\nTo explore multiple datasets, use separate QueryChat instances (i.e., separate chat interfaces).\n\n\n\n\n\n\nMultiple tables in one chat?\n\n\n\nIn some cases, you might be able to “pre-join” datasets into a single table and use one QueryChat instance to explore them together. In the future, we may support multiple filtered tables in one chat interface, but this is not currently available. Please upvote the relevant issue if this is a feature you’d like to see!",
    "crumbs": [
      "Build custom apps",
      "Dash"
    ]
  },
  {
    "objectID": "build-dash.html#see-also",
    "href": "build-dash.html#see-also",
    "title": "Dash",
    "section": "See also",
    "text": "See also\n\nGreet users - Create welcoming onboarding experiences\nProvide context - Help the LLM understand your data better",
    "crumbs": [
      "Build custom apps",
      "Dash"
    ]
  },
  {
    "objectID": "tools.html",
    "href": "tools.html",
    "title": "Tools",
    "section": "",
    "text": "querychat combines tool calling with reactivity to not only execute SQL, but also reactively update dependent data views. Understanding how these tools work will help you better understand what querychat is capable of and how to customize/extend to its behavior.\nOne important thing to understand generally about querychat’s tools is they are Python functions, and that execution happens on your machine, not on the LLM provider’s side. In other words, the SQL queries generated by the LLM are executed locally in the Python process running the app.\nquerychat provides the LLM access two tool groups:",
    "crumbs": [
      "Optimize",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#data-updating",
    "href": "tools.html#data-updating",
    "title": "Tools",
    "section": "Data updating",
    "text": "Data updating\nWhen a user asks to “Show me…” or “Filter to…” or “Sort by…”, the LLM requests a call to the update_dashboard tool with an appropriate SQL query as input. An important constraint is that the query must return all original schema columns (typically using SELECT *). When called, querychat will both set a reactive value holding the current SQL query and execute the query to get the result. The result of query then used to set a reactive value holding the filtered/sorted data frame. Thanks to reactivity, this will automatically update any views depending on this data frame, such as the data table displayed in the UI.\nThis tool also takes a title parameter, which is a short description of the filter/sort operation (e.g., “First-class passengers”). This, also, is made available through a reactive value for display somewhere in your app.\nHere’s a basic example of this tool in action with the .app() method. Notice how this pre-built app not only shows the data table, but also the SQL query and title generated by the LLM (for transparency):\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\n\n\nThe other data updating tool is reset_dashboard, which clears any active filters and returns the data table to its original unfiltered state. The LLM typically uses this when users say “reset”, “start over”, or “clear filters”.",
    "crumbs": [
      "Optimize",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#data-analysis",
    "href": "tools.html#data-analysis",
    "title": "Tools",
    "section": "Data analysis",
    "text": "Data analysis\nWhen a user asks analytical questions like “What is the average…?”, “How many…?”, or “Which item has the highest…?”, the LLM generates a SQL query and requests a call to the query tool. Unlike the data updating tools, this tool will not update any reactive values. Instead, it will:\n\nExecute the SQL query\nDisplay both the SQL query and results in the UI\nReturn the results back to the LLM for interpretation\n\nHere’s an example of it in action:\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()",
    "crumbs": [
      "Optimize",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#view-the-source",
    "href": "tools.html#view-the-source",
    "title": "Tools",
    "section": "View the source",
    "text": "View the source\nIf you’d like to better understand how the tools work and how the LLM is prompted to use them, check out the following resources:\nSource code:\n\ntools.py\n\nPrompts:\n\nprompts/tool-update-dashboard.md\nprompts/tool-reset-dashboard.md\nprompts/tool-query.md",
    "crumbs": [
      "Optimize",
      "Tools"
    ]
  },
  {
    "objectID": "data-sources.html",
    "href": "data-sources.html",
    "title": "Data Sources",
    "section": "",
    "text": "querychat supports several different data sources, including:\nThe sections below describe how to use each type of data source with querychat.",
    "crumbs": [
      "Get started",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#data-frames",
    "href": "data-sources.html#data-frames",
    "title": "Data Sources",
    "section": "Data frames",
    "text": "Data frames\nYou can use any narwhals-compatible data frame as a data source in querychat. This includes popular data frame libraries like pandas, polars, pyarrow, and many more.\n\nPandasPolarsPyarrow\n\n\n\n\npandas-app.py\n\nimport pandas as pd\nfrom querychat import QueryChat\n\nmtcars = pd.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n)\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\n\npolars-app.py\n\nimport polars as pl\nfrom querychat import QueryChat\n\nmtcars = pl.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n)\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\n\npyarrow-app.py\n\nimport pyarrow as pa\nimport pyarrow.csv as pv\nfrom querychat import QueryChat\n\nmtcars = pv.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n).to_table()\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\nIf you’re building an app, note you can read the queried data frame reactively using the df() method, which returns a narwhals.DataFrame (or narwhals.LazyFrame for lazy sources). Call .to_native() on the result to get the underlying pandas or polars DataFrame.",
    "crumbs": [
      "Get started",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#lazy-frames",
    "href": "data-sources.html#lazy-frames",
    "title": "Data Sources",
    "section": "Polars LazyFrames",
    "text": "Polars LazyFrames\nFor large datasets, you can use Polars LazyFrames to keep data on disk until it’s actually needed. This is particularly useful when:\n\nYour dataset is too large to fit comfortably in memory\nYou only need filtered or aggregated subsets of the data\nYou want faster startup times for your application\n\nWith lazy evaluation, data stays on disk and queries are optimized by Polars before execution. Only the final results are loaded into memory.\n\n\nlazy-app.py\n\nimport polars as pl\nfrom querychat import QueryChat\n\n# Scan a large parquet file (doesn't load data yet!)\nlf = pl.scan_parquet(\"large_dataset.parquet\")\n\n# Pass the LazyFrame directly to QueryChat\nqc = QueryChat(lf, \"sales\")\napp = qc.app()\n\n\n\n\n\n\n\nWhy use lazy evaluation?\n\n\n\nThe lazy approach can be significantly faster for large datasets because:\n\nDeferred loading: Data stays on disk until actually needed, so startup is nearly instant\nQuery optimization: Polars optimizes the query plan before execution, potentially skipping unnecessary columns and rows\nReduced memory: Only the filtered/aggregated results are loaded into memory, not the entire dataset\n\nThis is especially beneficial when users typically query small subsets of a large dataset.\n\n\nYou can create LazyFrames from various sources:\n# From parquet (most efficient)\nlf = pl.scan_parquet(\"data.parquet\")\n\n# From CSV\nlf = pl.scan_csv(\"data.csv\")\n\n# From multiple files\nlf = pl.scan_parquet(\"data/*.parquet\")\n\n# From an existing DataFrame\ndf = pl.read_csv(\"data.csv\")\nlf = df.lazy()\nWhen using a LazyFrame source, the df() method returns a narwhals.LazyFrame. Call .collect() to materialize the results when needed:\n# Get the lazy result\nresult_lazy = qc.df()\n\n# Materialize when ready\nresult_df = result_lazy.collect()",
    "crumbs": [
      "Get started",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#ibis-tables",
    "href": "data-sources.html#ibis-tables",
    "title": "Data Sources",
    "section": "Ibis Tables",
    "text": "Ibis Tables\nIbis is a Python DataFrame API that provides a unified interface to many different database backends. It enables lazy evaluation and query optimization, making it ideal for working with large datasets that live in databases or data warehouses.\nKey benefits of using Ibis with querychat:\n\nBackend flexibility: Write code once, run on DuckDB, PostgreSQL, BigQuery, Snowflake, and many more\nLazy evaluation: Queries are optimized and only executed when results are needed\nData stays in place: No need to move data out of your database or warehouse\nChainable operations: Query results are Ibis Tables that can be further transformed\n\n\nDuckDBPostgreSQLBigQuery\n\n\npip install ibis-framework[duckdb]\n\n\nibis-duckdb-app.py\n\nimport ibis\nfrom querychat import QueryChat\n\n# Connect to a DuckDB database\nconn = ibis.duckdb.connect(\"my_database.duckdb\")\ntable = conn.table(\"my_table\")\n\nqc = QueryChat(table, \"my_table\")\napp = qc.app()\n\n\n\npip install ibis-framework[postgres]\n\n\nibis-postgres-app.py\n\nimport ibis\nfrom querychat import QueryChat\n\n# Connect to PostgreSQL\nconn = ibis.postgres.connect(\n    host=\"localhost\",\n    port=5432,\n    database=\"mydatabase\",\n    user=\"user\",\n    password=\"password\",\n)\ntable = conn.table(\"my_table\")\n\nqc = QueryChat(table, \"my_table\")\napp = qc.app()\n\n\n\npip install ibis-framework[bigquery]\n\n\nibis-bigquery-app.py\n\nimport ibis\nfrom querychat import QueryChat\n\n# Connect to BigQuery (uses default credentials from environment)\nconn = ibis.bigquery.connect(\n    project_id=\"my-project\",\n    dataset_id=\"my_dataset\",\n)\ntable = conn.table(\"my_table\")\n\nqc = QueryChat(table, \"my_table\")\napp = qc.app()\n\n\n\n\nWhen using an Ibis source, the df() method returns an Ibis Table (lazy). You can chain additional Ibis operations or call .execute() to materialize the results as a pandas DataFrame:\n# Get the lazy Ibis Table\nresult_table = qc.df()\n\n# Chain additional operations\nfiltered = result_table.filter(result_table.amount &gt; 100)\n\n# Materialize when ready\nresult_df = result_table.execute()\n\n\n\n\n\n\nWhen to use Ibis vs SQLAlchemy\n\n\n\nBoth Ibis and SQLAlchemy can connect to databases, but they serve different purposes:\n\nUse Ibis when you want lazy evaluation, need to chain DataFrame-style operations on query results, or want to work with cloud data warehouses like BigQuery or Snowflake\nUse SQLAlchemy when you need a simple, direct SQL connection and are comfortable working with eagerly-evaluated DataFrames",
    "crumbs": [
      "Get started",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#databases",
    "href": "data-sources.html#databases",
    "title": "Data Sources",
    "section": "Databases",
    "text": "Databases\nYou can also connect querychat directly to a table in any database supported by SQLAlchemy. This includes popular databases like SQLite, DuckDB, PostgreSQL, MySQL, and many more.\nAssuming you have a database set up and accessible, you can pass a SQLAlchemy database URL to create_engine(), and then pass the resulting engine to querychat. Below are some examples for common databases.\n\nDuck DBSQLitePostgreSQLMySQL\n\n\npip install duckdb duckdb-engine\n\n\nduckdb-app.py\n\nfrom pathlib import Path\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\n# Assumes my_database.duckdb is in the same directory as this script\ndb_path = Path(__file__).parent / \"my_database.duckdb\"\nengine = create_engine(f\"duckdb:///{db_path}\")\n\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\n\n\nsqlite-app.py\n\nfrom pathlib import Path\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\n# Assumes my_database.db is in the same directory as this script\ndb_path = Path(__file__).parent / \"my_database.db\"\nengine = create_engine(f\"sqlite:///{db_path}\")\n\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\npip install psycopg2-binary\n\n\npostgresql-app.py\n\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\nengine = create_engine(\"postgresql+psycopg2://user:password@localhost:5432/mydatabase\")\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\npip install pymysql\n\n\nmysql-app.py\n\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\nengine = create_engine(\"mysql+pymysql://user:password@localhost:3306/mydatabase\")\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\n\nIf you don’t have a database set up, you can easily create a local DuckDB database from a CSV file using the following code:\n\n\ncreate-duckdb.py\n\nimport duckdb\n\nconn = duckdb.connect(\"my_database.duckdb\")\n\nconn.execute(\"\"\"\n    CREATE TABLE my_table AS\n    SELECT * FROM read_csv_auto('path/to/your/file.csv')\n\"\"\")\n\nOr, if you have a pandas DataFrame, you can create the DuckDB database like so:\n\n\ncreate-duckdb-from-pandas.py\n\nimport duckdb\nimport pandas as pd\nfrom querychat.data import titanic\n\nconn = duckdb.connect(\"my_database.duckdb\")\nconn.register('titanic_df', titanic())\nconn.execute(\"\"\"\n    CREATE TABLE titanic AS\n    SELECT * FROM titanic_df\n\"\"\")\n\nThen you can connect to this database using the DuckDB example above (changing the table name as appropriate):",
    "crumbs": [
      "Get started",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#custom-sources",
    "href": "data-sources.html#custom-sources",
    "title": "Data Sources",
    "section": "Custom sources",
    "text": "Custom sources\nIf you have a custom data source that doesn’t fit into the above categories, you can implement the DataSource interface/protocol. This requires implementing methods for getting schema information and executing queries.",
    "crumbs": [
      "Get started",
      "Data Sources"
    ]
  },
  {
    "objectID": "greet.html",
    "href": "greet.html",
    "title": "Greet users",
    "section": "",
    "text": "Provide a greeting\nWhen the querychat UI first appears, you will usually want it to greet the user with some basic instructions. By default, these instructions are auto-generated every time a user arrives. In a production setting with multiple users/visitors, this approach has some downsides: it’s slower, uses more API tokens, and produces different results each time. Instead, you should create a greeting file and pass it when creating your QueryChat object:\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\nfrom pathlib import Path\n\napp_dir = Path(__file__).parent\n\nqc = QueryChat(titanic(), \"titanic\", greeting=app_dir / \"greeting.md\")\napp = qc.app()\n\nYou can provide suggestions to the user by using the &lt;span class=\"suggestion\"&gt; &lt;/span&gt; tag:\n* **Filter and sort the data:**\n  * &lt;span class=\"suggestion\"&gt;Show only survivors&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;Filter to first class passengers under 30&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;Sort by fare from highest to lowest&lt;/span&gt;\n\n* **Answer questions about the data:**\n  * &lt;span class=\"suggestion\"&gt;What was the survival rate by gender?&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;What's the average age of children who survived?&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;How many passengers were traveling alone?&lt;/span&gt;\nThese suggestions appear in the greeting and automatically populate the chat text box when clicked. You can see this behavior in our querychat template.\n\n\nGenerate a greeting\nIf you need help coming up with a greeting, you can use the .generate_greeting() method:\n\n\npenguins-greeting.py\n\nfrom palmerpenguins import load_penguins\nfrom querychat import QueryChat\nfrom pathlib import Path\n\n# Create QueryChat object with your dataset\nqc = QueryChat(load_penguins(), \"penguins\")\n\n# Generate a greeting (this calls the LLM)\ngreeting_text = qc.generate_greeting()\n#&gt; Hello! I'm here to help you explore and analyze the penguins dataset.\n#&gt; Here are some example prompts you can try:\n#&gt; ...\n\n# Save it for reuse\nwith open(\"penguins_greeting.md\", \"w\") as f:\n    f.write(greeting_text)\n\nThis approach generates a greeting once and saves it for reuse, avoiding the latency and cost of generating it for every user.\n\n\npenguins-app.py\n\nfrom palmerpenguins import load_penguins\nfrom querychat import QueryChat\nfrom pathlib import Path\n\n# Then use the saved greeting in your app\napp_dir = Path(__file__).parent\nqc = QueryChat(\n  load_penguins(), \n  \"penguins\", \n  greeting=app_dir / \"penguins_greeting.md\",\n)\napp = qc.app()",
    "crumbs": [
      "Optimize",
      "Greet users"
    ]
  }
]