---
title: Dash
lightbox: true
---

[Dash](https://dash.plotly.com/) is a web framework for building interactive data applications. It provides a callback-based programming model that is designed for scaling to heavy load with simple infrastructure.

In this guide, you'll learn how to build Dash apps with querychat to enable rich data exploration experiences where [data views](#data-views) update based on natural language filters.

![](/images/dash-complete.png){fig-alt="Screenshot of querychat running in a custom Dash app." class="lightbox shadow rounded mb-3"}


## Initialize `QueryChat`

First, install querychat with Dash support:

```bash
pip install "querychat[dash]"
```

Then import the Dash-specific `QueryChat` class:

```{.python}
from querychat.dash import QueryChat
```

And initialize it with your [data source](data-sources.qmd):

```{.python}
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic")
```

::: {.callout-note collapse="true"}

## Quick start with `.app()`

Remember, the simplest way to get started is with `.app()`, which gives a "pre-baked" Dash app:

```{.python filename="dash-app.py"}
from querychat.dash import QueryChat
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic")
app = qc.app()

if __name__ == "__main__":
    app.run(debug=True)
```

Run with:

```bash
python dash-app.py
```
:::

## Relevant methods

After initializing `QueryChat`, use `.ui()` to place the chat interface in your layout, then call `.init_app(app)` to register querychat's callbacks. As users interact with the chat, the store at `.store_id` updates automatically. Use `Input(qc.store_id, "data")` in your callbacks, then access values with `.df(state)`, `.sql(state)`, and `.title(state)`.

| Method | Description |
|--------|-------------|
| `.ui()` | Returns the chat UI component |
| `.init_app(app)` | Registers querychat's internal callbacks on your Dash app |
| `.store_id` | ID of the `dcc.Store` component holding query state |
| `.df(state)` | Current filtered/sorted DataFrame |
| `.sql(state)` | Current SQL query (str \| None) |
| `.title(state)` | Short description of current filter (str \| None) |

## Basic layout

The most common pattern places chat alongside your custom filtered views:

```{python}
# | eval: false
# | code-fold: true
# | code-summary: "dash-custom.py"
{{< include _examples/dash-custom.py >}}
```

![](/images/dash-custom-app.png){fig-alt="Screenshot of custom Dash layout." class="lightbox shadow rounded mb-3"}

## Data views

The real power of querychat comes from connecting it to visualizations. Here's an example showing both filtered data and charts:

```{python}
# | eval: false
{{< include _examples/dash-viz.py >}}
```

When users filter data through the chat (e.g., "show only survivors"), both charts update automatically.

![](/images/dash-viz.png){fig-alt="Screenshot of Dash data views example." class="lightbox shadow rounded mb-3"}

A more complete example adds metrics:

```{python}
# | eval: false
# | code-fold: true
# | code-summary: "dash-complete.py"
{{< include _examples/dash-complete.py >}}
```

![](/images/dash-complete.png){fig-alt="Screenshot of complete Dash app with querychat." class="lightbox shadow rounded mb-3"}

### Resetting filters

Add a reset button to show all data by fetching the original data from `qc.data_source.get_data()`:

```python
reset_btn = html.Button("Reset", id="reset-btn")

@app.callback(
    Output("data-table", "rowData"),
    [Input(qc.store_id, "data"), Input("reset-btn", "n_clicks")],
)
def update_table(state, n_clicks):
    from dash import callback_context
    if callback_context.triggered_id == "reset-btn":
        return qc.data_source.get_data().to_pandas().to_dict("records")
    return qc.df(state).to_pandas().to_dict("records")
```

::: {.callout-tip}
This resets the data display only. Users can also ask the LLM to "reset" or "show all data" to clear filters through the chat interface.
:::

### Advanced patterns

#### Programmatic updates

You can update the display programmatically by creating callbacks that execute queries directly:

```python
@app.callback(
    Output("data-table", "rowData"),
    Output("data-title", "children"),
    Input("preset-survivors", "n_clicks"),
    prevent_initial_call=True
)
def apply_preset_filter(n_clicks):
    df = qc.data_source.execute_query(
        "SELECT * FROM titanic WHERE survived = 1"
    )
    return df.to_pandas().to_dict("records"), "Survivors only"
```

#### Multiple datasets

To explore multiple datasets, use separate `QueryChat` instances (i.e., separate chat interfaces).

::: {.callout-note}
### Multiple tables in one chat?

In some cases, you might be able to "pre-join" datasets into a single table and use one `QueryChat` instance to explore them together. In the future, we may support multiple filtered tables in one chat interface, but this is not currently available. Please upvote [the relevant issue](https://github.com/posit-dev/querychat/issues/6) if this is a feature you'd like to see!
:::

## See also

- [Greet users](greet.qmd) - Create welcoming onboarding experiences
- [Provide context](context.qmd) - Help the LLM understand your data better
