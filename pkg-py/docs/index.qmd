---
title: Introduction
lightbox: true
---

```{=html}
<style>h1.title { display:none; }</style>
```

<img src="/images/querychat.png" alt="querychat website banner image" class="d-block mx-auto mb-3" style="max-width:100%; max-height:425px"/>

<p class="fs-2 lead mt-3 mb-3 text-center" style="max-width: 600px; margin: auto;">
Explore data using natural language queries
</p>

<div class="d-flex justify-content-center mb-3">
<!-- badges start -->
<a href="https://pypi.org/project/querychat/"><img alt="PyPI" src="https://img.shields.io/pypi/v/querychat?logo=python&logoColor=white&color=orange"></a>
<a href="https://choosealicense.com/licenses/mit/"><img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="MIT License"></a>
<a href="https://pypi.org/project/querychat"><img src="https://img.shields.io/pypi/pyversions/querychat.svg" alt="versions"></a>
<a href="https://github.com/posit-dev/querychat"><img src="https://github.com/posit-dev/querychat/actions/workflows/py-test.yml/badge.svg?branch=main" alt="Python Tests"></a>
<!-- badges end -->
</div>


Querychat makes it easy to explore data with natural language through the power of [Shiny](https://shiny.posit.co/py) and large language models (LLMs). Start chatting with your data in just one line of code. Or, with a few more lines, design your own rich user experience around data exploration and analysis through natural language.

## Installation

Install the latest stable release [from PyPI](https://pypi.org/project/querychat/):

```bash
pip install querychat
```

## Quick start

The main entry point is the [`QueryChat` class](reference/QueryChat.qmd). It requires a [data source](data-sources.qmd) (e.g., pandas, polars, etc) and a name for the data. It also accepts optional parameters to customize the behavior, such as the `client` [model](models.qmd).
The quickest way to start chatting is to call the `.app()` method, which returns a Shiny app object.


```{.python filename="titanic-app.py"}
from querychat import QueryChat
from querychat.data import titanic

qc = QueryChat(titanic(), "titanic", client="openai/gpt-4.1")
app = qc.app()
```

With the above code saved to `titanic-app.py` and an API key set[^api-key], you can [run the app](https://shiny.posit.co/py/get-started/create-run.html#run-your-shiny-application) from a terminal (or [VSCode](https://marketplace.visualstudio.com/items?itemName=Posit.shiny)):

```bash
export OPENAI_API_KEY="your_api_key_here"
shiny run --reload titanic-app.py
```

[^api-key]: By default, Querychat uses OpenAI to power the chat experience. So, for this example to work, you'll need [an OpenAI API key](https://platform.openai.com/). See the [Models](models.qmd) page for details on how to set up credentials for other model providers.

Once running, you'll notice 3 main views:

1. A sidebar chat with suggestions on where to start exploring.
2. A data table that updates to reflect filtering and sorting queries.
3. The SQL query behind the data table, for transparency and reproducibility.

![](/images/quickstart.png){fig-alt="Screenshot of querychat's app with the titanic dataset." class="lightbox shadow rounded mb-3"}

Suppose we pick a suggestion like "Show me passengers who survived". Since this is a filtering operation, both the data table and SQL query update accordingly.

![](/images/quickstart-filter.png){fig-alt="Screenshot of the querychat's app with the titanic dataset filtered to passengers who survived." class="lightbox shadow rounded mb-3"}

Querychat can also handle more general questions about the data that require calculations and aggregations. For example, we can ask "What is the average age of passengers who survived?". In this case, querychat will generate/execute the SQL query to perform the relevant calculation, and return the result in the chat:

![](/images/quickstart-summary.png){fig-alt="Screenshot of the querychat's app with a summary statistic inlined in the chat." class="lightbox shadow rounded mb-3"}

As you'll learn later in [Build an app](build.qmd), you can also access the SQL query and filtered/sorted data frame programmatically for use elsewhere in your app. This makes it rather seemless to have natural language interaction with your data alongside other visualizations and analyses.

Before we build though, let's take a moment to better understand how querychat works under the hood, and whether it's right for you.


## How it works

Querychat leverages LLMs incredible capability to translate natural language into SQL queries. Frontier models are shockingly good at this task, but even the best models still need to know the overall data structure to perform well. For this reason, querychat supplies a [system prompt](context.qmd) with the schema of the data (i.e., column names, types, ranges, etc), but never the raw data itself.

When the LLM generates a SQL query, querychat executes it against a SQL database (DuckDB[^duckdb] by default) to get results in a **safe**, **reliable**, and **verifiable** manner. In short, this execution is **safe** since only `SELECT` statements are allowed, **reliable** since the database engine handles all calculations, and **verifiable** since the user can always see the SQL query that was run. This makes querychat a trustworthy tool for data exploration, as every action taken by the LLM is transparent and independently reproducible.


::: callout-important
### Data privacy

See the [Provide context](context.qmd) and [Tools](tools.qmd) articles to learn more about what information is provided to the LLM and what it's capable of doing with code execution.
::::

[^duckdb]: Duckdb is extremely fast and has a surprising number of [statistical functions](https://duckdb.org/docs/stable/sql/functions/aggregates.html#statistical-aggregates).

### Bespoke interfaces

While the quickstart app is a great way to get started, querychat is designed to be highly extensible.
You can not only customize the underlying model and data source, but also build fully custom Shiny apps around the core chat functionality.

For a motivating example, consider the following ([sidebot](https://shiny.posit.co/py/docs/genai-inspiration.html#sidebot)) app that leverages querychat's tooling to create reactive summaries and visualizations based on the user's natural language queries:

![](/images/sidebot.png){fig-alt="Screenshot of sidebot, a custom shiny app built with querychat." class="lightbox shadow rounded mb-3"}


## Next steps

From here, you might want to learn more about:

- [Models](models.qmd): customize the LLM behind querychat.
- [Data sources](data-sources.qmd): different data sources you can use with querychat.
- [Provide context](context.qmd): provide the LLM with the context it needs to work well.
- [Build an app](build.qmd): design a custom Shiny app around querychat.
