% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QueryChat.R
\name{QueryChat}
\alias{QueryChat}
\title{QueryChat: Interactive Data Querying with Natural Language}
\description{
\code{QueryChat} is an R6 class built on Shiny, shinychat, and ellmer to enable
interactive querying of data using natural language. It leverages large
language models (LLMs) to translate user questions into SQL queries, execute
them against a data source (data frame or database), and various ways of
accessing/displaying the results.
}
\details{
The \code{QueryChat} class takes your data (a data frame or database connection)
as input and provides methods to:
\itemize{
\item Generate a chat UI for natural language queries (e.g., \verb{$app()}, \verb{$sidebar()})
\item Reactively read SQL results in your Shiny app (e.g., \verb{$df()})
\item Programmatically get/set the current query and title (e.g., \verb{$sql()}, \verb{$title()})
}
}
\section{Usage}{


\if{html}{\out{<div class="sourceCode r">}}\preformatted{library(querychat)

# Create a QueryChat object
qc <- QueryChat$new(mtcars, "mtcars")

# Quick start: run a complete app
qc$app()

# Or build a custom Shiny app
ui <- page_sidebar(
  qc$sidebar(),
  verbatimTextOutput("sql"),
  dataTableOutput("data")
)

server <- function(input, output, session) \{
  qc$server()

  output$sql <- renderText(qc$sql())
  output$data <- renderDataTable(qc$df())
\}

shinyApp(ui, server)
}\if{html}{\out{</div>}}
}

\examples{
\dontrun{
# Basic usage with a data frame
qc <- QueryChat$new(mtcars, "mtcars")
app <- qc$app()

# With a custom greeting
greeting <- "Welcome! Ask me about the mtcars dataset."
qc <- QueryChat$new(mtcars, "mtcars", greeting = greeting)

# With a specific LLM provider
qc <- QueryChat$new(mtcars, "mtcars", client = "anthropic/claude-sonnet-4-5")

# Generate a greeting for reuse
qc <- QueryChat$new(mtcars, "mtcars")
greeting <- qc$generate_greeting(echo = "text")
# Save greeting for next time
writeLines(greeting, "mtcars_greeting.md")
}

## ------------------------------------------------
## Method `QueryChat$new`
## ------------------------------------------------

\dontrun{
# Basic usage
qc <- QueryChat$new(mtcars, "mtcars")

# With options
qc <- QueryChat$new(
  mtcars,
  "mtcars",
  greeting = "Welcome to the mtcars explorer!",
  client = "openai/gpt-4o",
  data_description = "Motor Trend car road tests dataset"
)

# With database
library(DBI)
conn <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(conn, "mtcars", mtcars)
qc <- QueryChat$new(conn, "mtcars")
}

## ------------------------------------------------
## Method `QueryChat$app`
## ------------------------------------------------

\dontrun{
library(querychat)

qc <- QueryChat$new(mtcars, "mtcars")
qc$app()
}


## ------------------------------------------------
## Method `QueryChat$app_obj`
## ------------------------------------------------

\dontrun{
library(querychat)

qc <- QueryChat$new(mtcars, "mtcars")
app <- qc$app_obj()
shiny::runApp(app)
}


## ------------------------------------------------
## Method `QueryChat$sidebar`
## ------------------------------------------------

\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

ui <- page_sidebar(
  qc$sidebar(),
  # Main content here
)
}

## ------------------------------------------------
## Method `QueryChat$ui`
## ------------------------------------------------

\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

ui <- fluidPage(
  qc$ui()
)
}

## ------------------------------------------------
## Method `QueryChat$server`
## ------------------------------------------------

\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  output$data <- renderDataTable(qc$df())
  output$query <- renderText(qc$sql())
}
}

## ------------------------------------------------
## Method `QueryChat$df`
## ------------------------------------------------

\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  output$table <- renderDataTable({
    qc$df()  # Reactive - will update when query changes
  })
}
}

## ------------------------------------------------
## Method `QueryChat$sql`
## ------------------------------------------------

\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  # Get current query
  output$current_query <- renderText({
    qc$sql()
  })

  # Set query programmatically
  observeEvent(input$filter_button, {
    qc$sql("SELECT * FROM mtcars WHERE cyl = 6")
  })
}
}

## ------------------------------------------------
## Method `QueryChat$title`
## ------------------------------------------------

\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  # Get current title
  output$title <- renderText({
    qc$title() \%||\% "No Query"
  })

  # Set title programmatically
  observeEvent(input$set_title, {
    qc$title("Filtered Cars")
  })
}
}

## ------------------------------------------------
## Method `QueryChat$generate_greeting`
## ------------------------------------------------

\dontrun{
# Create QueryChat object
qc <- QueryChat$new(mtcars, "mtcars")

# Generate a greeting and save it
greeting <- qc$generate_greeting(echo = "text")
writeLines(greeting, "mtcars_greeting.md")

# Later, use the saved greeting
qc2 <- QueryChat$new(mtcars, "mtcars", greeting = "mtcars_greeting.md")
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{greeting}}{The greeting message displayed to users.}

\item{\code{id}}{The module ID for namespacing.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{client}}{Get the (session-specific) chat client.}

\item{\code{data_source}}{Get the current data source.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-QueryChat-new}{\code{QueryChat$new()}}
\item \href{#method-QueryChat-app}{\code{QueryChat$app()}}
\item \href{#method-QueryChat-app_obj}{\code{QueryChat$app_obj()}}
\item \href{#method-QueryChat-sidebar}{\code{QueryChat$sidebar()}}
\item \href{#method-QueryChat-ui}{\code{QueryChat$ui()}}
\item \href{#method-QueryChat-server}{\code{QueryChat$server()}}
\item \href{#method-QueryChat-df}{\code{QueryChat$df()}}
\item \href{#method-QueryChat-sql}{\code{QueryChat$sql()}}
\item \href{#method-QueryChat-title}{\code{QueryChat$title()}}
\item \href{#method-QueryChat-generate_greeting}{\code{QueryChat$generate_greeting()}}
\item \href{#method-QueryChat-cleanup}{\code{QueryChat$cleanup()}}
\item \href{#method-QueryChat-clone}{\code{QueryChat$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-new"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-new}{}}}
\subsection{Method \code{new()}}{
Create a new QueryChat object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$new(
  data_source,
  table_name,
  ...,
  id = NULL,
  greeting = NULL,
  client = NULL,
  data_description = NULL,
  categorical_threshold = 20,
  extra_instructions = NULL,
  prompt_template = NULL,
  cleanup = NA
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data_source}}{Either a data.frame or a database connection (e.g., DBI
connection).}

\item{\code{table_name}}{A string specifying the table name to use in SQL queries.
If \code{data_source} is a data.frame, this is the name to refer to it by in
queries (typically the variable name). If \code{data_source} is a database
connection, this is the name of the table in the database.}

\item{\code{...}}{Additional arguments (currently unused).}

\item{\code{id}}{Optional module ID for the QueryChat instance. If not provided,
will be auto-generated from \code{table_name}. The ID is used to namespace
the Shiny module.}

\item{\code{greeting}}{Optional initial message to display to users. Can be a
character string (in Markdown format) or a file path. If not provided,
a greeting will be generated at the start of each conversation using the
LLM, which adds latency and cost. Use \verb{$generate_greeting()} to create
a greeting to save and reuse.}

\item{\code{client}}{Optional chat client. Can be:
\itemize{
\item An \link[ellmer:Chat]{ellmer::Chat} object
\item A string to pass to \code{\link[ellmer:chat-any]{ellmer::chat()}} (e.g., \code{"openai/gpt-4o"})
\item \code{NULL} (default): Uses the \code{querychat.client} option, the
\code{QUERYCHAT_CLIENT} environment variable, or defaults to
\code{\link[ellmer:chat_openai]{ellmer::chat_openai()}}
}}

\item{\code{data_description}}{Optional description of the data in plain text or
Markdown. Can be a string or a file path. This provides context to the
LLM about what the data represents.}

\item{\code{categorical_threshold}}{For text columns, the maximum number of unique
values to consider as a categorical variable. Default is 20.}

\item{\code{extra_instructions}}{Optional additional instructions for the chat
model in plain text or Markdown. Can be a string or a file path.}

\item{\code{prompt_template}}{Optional path to or string of a custom prompt
template file. If not provided, the default querychat template will be
used. See the package prompts directory for the default template format.}

\item{\code{cleanup}}{Whether or not to automatically run \verb{$cleanup()} when the
Shiny session/app stops. By default, cleanup only occurs if \code{QueryChat}
gets created within a Shiny session. Set to \code{TRUE} to always clean up,
or \code{FALSE} to never clean up automatically.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{QueryChat} object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# Basic usage
qc <- QueryChat$new(mtcars, "mtcars")

# With options
qc <- QueryChat$new(
  mtcars,
  "mtcars",
  greeting = "Welcome to the mtcars explorer!",
  client = "openai/gpt-4o",
  data_description = "Motor Trend car road tests dataset"
)

# With database
library(DBI)
conn <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(conn, "mtcars", mtcars)
qc <- QueryChat$new(conn, "mtcars")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-app"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-app}{}}}
\subsection{Method \code{app()}}{
Create and run a Shiny gadget for chatting with data

Runs a Shiny gadget (designed for interactive use) that provides
a complete interface for chatting with your data using natural language.
If you're looking to deploy this app or run it through some other means,
see \verb{$app_obj()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$app(..., bookmark_store = "url")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments passed to \verb{$app_obj()}.}

\item{\code{bookmark_store}}{The bookmarking storage method. Passed to
\code{\link[shiny:enableBookmarking]{shiny::enableBookmarking()}}. If \code{"url"} or \code{"server"}, the chat state
(including current query) will be bookmarked. Default is \code{"url"}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns the chat object after the app stops.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(querychat)

qc <- QueryChat$new(mtcars, "mtcars")
qc$app()
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-app_obj"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-app_obj}{}}}
\subsection{Method \code{app_obj()}}{
A streamlined Shiny app for chatting with data

Creates a Shiny app designed for chatting with data, with:
\itemize{
\item A sidebar containing the chat interface
\item A card displaying the current SQL query
\item A card displaying the filtered data table
\item A reset button to clear the query
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$app_obj(..., bookmark_store = "url")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Additional arguments (currently unused).}

\item{\code{bookmark_store}}{The bookmarking storage method. Passed to
\code{\link[shiny:enableBookmarking]{shiny::enableBookmarking()}}. If \code{"url"} or \code{"server"}, the chat state
(including current query) will be bookmarked. Default is \code{"url"}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A Shiny app object that can be run with \code{shiny::runApp()}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(querychat)

qc <- QueryChat$new(mtcars, "mtcars")
app <- qc$app_obj()
shiny::runApp(app)
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-sidebar"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-sidebar}{}}}
\subsection{Method \code{sidebar()}}{
Create a sidebar containing the querychat UI.

This method generates a \code{\link[bslib:sidebar]{bslib::sidebar()}} component containing the chat
interface, suitable for use with \code{\link[bslib:page_sidebar]{bslib::page_sidebar()}} or similar layouts.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$sidebar(width = 400, height = "100\%", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{width}}{Width of the sidebar in pixels. Default is 400.}

\item{\code{height}}{Height of the sidebar. Default is "100\%".}

\item{\code{...}}{Additional arguments passed to \code{\link[bslib:sidebar]{bslib::sidebar()}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{\link[bslib:sidebar]{bslib::sidebar()}} UI component.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

ui <- page_sidebar(
  qc$sidebar(),
  # Main content here
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-ui"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-ui}{}}}
\subsection{Method \code{ui()}}{
Create the UI for the querychat chat interface.

This method generates the chat UI component. Typically you'll use
\verb{$sidebar()} instead, which wraps this in a sidebar layout.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$ui(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Additional arguments passed to \code{\link[shinychat:chat_ui]{shinychat::chat_ui()}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A UI component containing the chat interface.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

ui <- fluidPage(
  qc$ui()
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-server"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-server}{}}}
\subsection{Method \code{server()}}{
Initialize the querychat server logic.

This method must be called within a Shiny server function. It sets up
the reactive logic for the chat interface and populates the internal
server values that are accessed via \verb{$df()}, \verb{$sql()}, and \verb{$title()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$server(session = shiny::getDefaultReactiveDomain())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{session}}{The Shiny session object.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns \code{NULL}. Access reactive values via \verb{$df()},
\verb{$sql()}, and \verb{$title()} methods.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  output$data <- renderDataTable(qc$df())
  output$query <- renderText(qc$sql())
}
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-df"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-df}{}}}
\subsection{Method \code{df()}}{
Get the current filtered data frame.

This is a reactive expression that returns the data after applying the
current SQL query. If no query has been set, returns the unfiltered data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$df()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data.frame with the filtered/transformed data.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  output$table <- renderDataTable({
    qc$df()  # Reactive - will update when query changes
  })
}
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-sql"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-sql}{}}}
\subsection{Method \code{sql()}}{
Get or set the current SQL query.

This method provides both getter and setter functionality for the SQL
query. When called without arguments, it returns the current query.
When called with a query string, it sets the query and returns whether
the query changed.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$sql(query = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{Optional SQL query string. If provided, sets the current
query to this value. If \code{NULL} (default), returns the current query.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\itemize{
\item When \code{query = NULL} (getter): Returns the current SQL query as a string
(may be an empty string \code{""} if no query has been set).
\item When \code{query} is provided (setter): Returns \code{TRUE} if the query was
changed to a new value, \code{FALSE} if it was the same as the current value.
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  # Get current query
  output$current_query <- renderText({
    qc$sql()
  })

  # Set query programmatically
  observeEvent(input$filter_button, {
    qc$sql("SELECT * FROM mtcars WHERE cyl = 6")
  })
}
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-title"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-title}{}}}
\subsection{Method \code{title()}}{
Get or set the current title.

The title is a short description of the current query that the LLM
provides whenever it generates a new SQL query. It can be used as a
status string for the data dashboard.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$title(value = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{Optional title string. If provided, sets the current title
to this value. If \code{NULL} (default), returns the current title.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\itemize{
\item When \code{value = NULL} (getter): Returns the current title as a string,
or \code{NULL} if no title has been set (because no SQL query has been set).
\item When \code{value} is provided (setter): Returns \code{TRUE} if the title was
changed to a new value, \code{FALSE} if it was the same as the current value.
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
qc <- QueryChat$new(mtcars, "mtcars")

server <- function(input, output, session) {
  qc$server()

  # Get current title
  output$title <- renderText({
    qc$title() \%||\% "No Query"
  })

  # Set title programmatically
  observeEvent(input$set_title, {
    qc$title("Filtered Cars")
  })
}
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-generate_greeting"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-generate_greeting}{}}}
\subsection{Method \code{generate_greeting()}}{
Generate a welcome greeting for the chat.

By default, \code{QueryChat$new()} generates a greeting at the start of every
new conversation, which is convenient for getting started and development,
but also might add unnecessary latency and cost. Use this method to
generate a greeting once and save it for reuse.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$generate_greeting(echo = c("none", "output"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{echo}}{Whether to print the greeting to the console. Options are
\code{"none"} (default, no output) or \code{"text"} (print to console).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The greeting string in Markdown format.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# Create QueryChat object
qc <- QueryChat$new(mtcars, "mtcars")

# Generate a greeting and save it
greeting <- qc$generate_greeting(echo = "text")
writeLines(greeting, "mtcars_greeting.md")

# Later, use the saved greeting
qc2 <- QueryChat$new(mtcars, "mtcars", greeting = "mtcars_greeting.md")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-cleanup"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-cleanup}{}}}
\subsection{Method \code{cleanup()}}{
Clean up resources associated with the data source.

This method releases any resources (e.g., database connections)
associated with the data source. Call this when you are done using
the QueryChat object to avoid resource leaks.

Note: If \code{auto_cleanup} was set to \code{TRUE} in the constructor,
this will be called automatically when the Shiny app stops.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$cleanup()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns \code{NULL}. Resources are cleaned up internally.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QueryChat-clone"></a>}}
\if{latex}{\out{\hypertarget{method-QueryChat-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryChat$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
