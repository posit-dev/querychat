[{"path":"https://posit-dev.github.io/querychat/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 querychat authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"starter-template","dir":"Articles","previous_headings":"","what":"Starter template","title":"Build an App","text":"Integrating querychat Shiny app requires just three steps: Initialize QueryChat instance data Add UI component (either $sidebar() $ui()) Use reactive values like $df(), $sql(), $title() build outputs respond user queries ’s starter template demonstrating steps: ’ll need call qc$server() method within server function set querychat’s reactive behavior, capture return value access reactive data.","code":"library(shiny) library(bslib) library(querychat) library(DT) library(palmerpenguins)  # Step 1: Initialize QueryChat qc <- QueryChat$new(penguins)  # Step 2: Add UI component ui <- page_sidebar(   sidebar = qc$sidebar(),   card(     card_header(\"Data Table\"),     dataTableOutput(\"table\")   ),   card(     fill = FALSE,     card_header(\"SQL Query\"),     verbatimTextOutput(\"sql\")   ) )  # Step 3: Use reactive values in server server <- function(input, output, session) {   qc_vals <- qc$server()      output$table <- renderDataTable({     datatable(qc_vals$df(), fillContainer = TRUE)   })    output$sql <- renderText({     qc_vals$sql() %||% \"SELECT * FROM penguins\"   }) }  shinyApp(ui, server)"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"reactives","dir":"Articles","previous_headings":"","what":"Reactives","title":"Build an App","text":"three main reactive values provided querychat use app:","code":""},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"filtered-data","dir":"Articles","previous_headings":"Reactives","what":"Filtered data","title":"Build an App","text":"$df() method returns current filtered /sorted data frame. updates whenever user prompts filtering sorting operation chat interface (see Data updating details). can use $df() power output app - visualizations, summary statistics, data tables, . user asks “show Adelie penguins” “sort body mass”, $df() automatically updates, outputs depend re-render.","code":"qc_vals <- qc$server()  output$table <- renderDataTable({   qc_vals$df()  # Returns filtered/sorted data })"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"sql-query","dir":"Articles","previous_headings":"Reactives","what":"SQL query","title":"Build an App","text":"$sql() method returns current SQL query string. useful displaying query users transparency reproducibility: can also use $sql() setter programmatically update query (see Programmatic filtering ).","code":"qc_vals <- qc$server()  output$current_query <- renderText({   qc_vals$sql() %||% \"SELECT * FROM penguins\" })"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"title","dir":"Articles","previous_headings":"Reactives","what":"Title","title":"Build an App","text":"$title() method returns short description current filter, provided LLM generates query. example, user asks “show Adelie penguins”, title might “Adelie penguins”. Returns NULL filter active. can also use $title() setter update title programmatically.","code":"qc_vals <- qc$server()  output$card_title <- renderText({   qc_vals$title() %||% \"All Data\" })"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"custom-ui","dir":"Articles","previous_headings":"","what":"Custom UI","title":"Build an App","text":"starter template , used $sidebar() method simple sidebar layout. cases, might want place chat UI somewhere else app layout, just fully customize goes sidebar. $ui() method designed – returns chat component without additional layout wrappers. example, might want create additional controls reset filters alongside chat UI: Customizing chat UIs See shinychat’s docs learn customizing chat UI component returned qc$ui().","code":"library(querychat) library(palmerpenguins)  qc <- QueryChat$new(penguins)  ui <- page_sidebar(   sidebar = sidebar(     qc$ui(),  # Chat component     actionButton(\"reset\", \"Reset Filters\", class = \"w-100\"),     fillable = TRUE,     width = 300   ),   # Main content here )"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"data-views","dir":"Articles","previous_headings":"","what":"Data views","title":"Build an App","text":"Thanks Shiny’s support interactive visualizations packages like plotly, ’s straightforward create rich data views depend QueryChat data. ’s example app showing filtered data bar chart depending data:  useful, slightly involved example like one might incorporate Shiny components like value boxes summarize key statistics filtered data.","code":"library(shiny) library(bslib) library(querychat) library(DT) library(plotly) library(palmerpenguins)  qc <- QueryChat$new(penguins, client = \"claude/claude-sonnet-4-5\")  ui <- page_sidebar(   sidebar = qc$sidebar(),   card(     card_header(\"Data Table\"),     dataTableOutput(\"table\")   ),   card(     card_header(\"Body Mass by Species\"),     plotlyOutput(\"mass_plot\")   ) )  server <- function(input, output, session) {   qc_vals <- qc$server()    output$table <- renderDataTable({     datatable(qc_vals$df(), fillContainer = TRUE)   })    output$mass_plot <- renderPlotly({     ggplot(qc_vals$df(), aes(x = body_mass_g, fill = species)) +       geom_density(alpha = 0.4) +       theme_minimal()   }) }  shinyApp(ui, server) library(shiny) library(bslib) library(DT) library(plotly) library(palmerpenguins) library(dplyr) library(bsicons) library(querychat)   qc <- QueryChat$new(penguins)  ui <- page_sidebar(   title = \"Palmer Penguins Analysis\",   class = \"bslib-page-dashboard\",   sidebar = qc$sidebar(),   layout_column_wrap(     width = 1 / 3,     fill = FALSE,     value_box(       title = \"Total Penguins\",       value = textOutput(\"count\"),       showcase = bs_icon(\"piggy-bank\"),       theme = \"primary\"     ),     value_box(       title = \"Species Count\",       value = textOutput(\"species_count\"),       showcase = bs_icon(\"bookmark-star\"),       theme = \"success\"     ),     value_box(       title = \"Avg Body Mass\",       value = textOutput(\"avg_mass\"),       showcase = bs_icon(\"speedometer\"),       theme = \"info\"     )   ),   layout_columns(     card(       card_header(textOutput(\"table_title\")),       DT::dataTableOutput(\"data_table\")     ),     card(       card_header(\"Species Distribution\"),       plotlyOutput(\"species_plot\")     )   ),   layout_columns(     card(       card_header(\"Bill Length Distribution\"),       plotlyOutput(\"bill_length_dist\")     ),     card(       card_header(\"Body Mass by Species\"),       plotlyOutput(\"mass_by_species\")     )   ) )  server <- function(input, output, session) {   qc_vals <- qc$server()    output$count <- renderText({     nrow(qc_vals$df())   })    output$species_count <- renderText({     length(unique(qc_vals$df()$species))   })    output$avg_mass <- renderText({     avg <- mean(qc_vals$df()$body_mass_g, na.rm = TRUE)     paste0(round(avg, 0), \"g\")   })    output$table_title <- renderText({     qc_vals$title() %||% \"All Penguins\"   })    output$data_table <- DT::renderDataTable({     DT::datatable(       qc_vals$df(),       fillContainer = TRUE,       options = list(         scrollX = TRUE,         pageLength = 10,         dom = \"ti\"       )     )   })    output$species_plot <- renderPlotly({     plot_ly(       count(qc_vals$df(), species),       x = ~species,       y = ~n,       type = \"bar\",       marker = list(color = c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\"))     )   })    output$bill_length_dist <- renderPlotly({     plot_ly(       qc_vals$df(),       x = ~bill_length_mm,       type = \"histogram\",       nbinsx = 30,       marker = list(color = \"#1f77b4\", opacity = 0.7)     )   })    output$mass_by_species <- renderPlotly({     plot_ly(       qc_vals$df(),       x = ~species,       y = ~body_mass_g,       color = ~sex,       type = \"box\",       colors = c(\"#1f77b4\", \"#ff7f0e\")     )   }) }  shinyApp(ui = ui, server = server)"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"programmatic-filtering","dir":"Articles","previous_headings":"","what":"Programmatic updates","title":"Build an App","text":"querychat’s reactive state can updated programmatically. example, might want add “Reset Filters” button clears active filters returns data table original state. can setting SQL query title default values. way don’t rely user LLM send right prompt. equivalent user asking LLM “reset” “show data”.","code":"ui <- page_sidebar(   sidebar = sidebar(     qc$ui(),     hr(),     actionButton(\"reset\", \"Reset Filters\")   ),   # Main content   card(dataTableOutput(\"table\")) )  server <- function(input, output, session) {   qc_vals <- qc$server()    output$table <- renderDataTable({     qc_vals$df()   })    observeEvent(input$reset, {     qc_vals$sql(\"\")     qc_vals$title(NULL)   }) }  shinyApp(ui, server)"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"multiple-tables","dir":"Articles","previous_headings":"","what":"Multiple tables","title":"Build an App","text":"Currently, two options exploring multiple tables querychat: Join tables single table passing querychat Use multiple querychat instances app first option makes possible chat multiple tables inside single chat interface, whereas second option requires separate chat interface table.","code":"library(shiny) library(bslib) library(palmerpenguins) library(titanic) library(querychat)  qc_penguins <- QueryChat$new(penguins) qc_titanic <- QueryChat$new(titanic_train)  ui <- page_navbar(   title = \"Multiple Datasets\",   sidebar = sidebar(     id = \"sidebar\",     conditionalPanel(       \"input.navbar == 'Penguins'\",       qc_penguins$ui()     ),     conditionalPanel(       \"input.navbar == 'Titanic'\",       qc_titanic$ui()     )   ),   nav_panel(     \"Penguins\",     card(dataTableOutput(\"penguins_table\"))   ),   nav_panel(     \"Titanic\",     card(dataTableOutput(\"titanic_table\"))   ),   id = \"navbar\" )  server <- function(input, output, session) {   qc_penguins_vals <- qc_penguins$server()   qc_titanic_vals <- qc_titanic$server()    output$penguins_table <- renderDataTable({     qc_penguins_vals$df()   })    output$titanic_table <- renderDataTable({     qc_titanic_vals$df()   }) }  shinyApp(ui, server)"},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"multiple-filtered-tables","dir":"Articles","previous_headings":"Multiple tables","what":"Multiple filtered tables","title":"Build an App","text":"intend supporting multiple filtered tables future release – ’re interested feature, please upvote relevant issue","code":""},{"path":"https://posit-dev.github.io/querychat/articles/build.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See also","title":"Build an App","text":"Greet users - Create welcoming onboarding experiences Provide context - Help LLM understand data better Tools - Understand querychat can hood","code":""},{"path":"https://posit-dev.github.io/querychat/articles/context.html","id":"default-prompt","dir":"Articles","previous_headings":"","what":"Default prompt","title":"Provide Context","text":"full visibility system prompt querychat generates LLM, can inspect system_prompt field. useful debugging understanding exactly context LLM using: default, system prompt contains following components: basic set behaviors guidelines LLM must follow order querychat work properly, including use tools execute queries update app. Column names Data types (integer, real, boolean, date/datetime, text) text columns less 10 unique values, assume categorical variables include list values integer real columns, include range data description (provided via data_description) Additional instructions want use guide querychat’s behavior (provided via extra_instructions).","code":"qc <- querychat(penguins) cat(qc$system_prompt)"},{"path":"https://posit-dev.github.io/querychat/articles/context.html","id":"data-description","dir":"Articles","previous_headings":"","what":"Data description","title":"Provide Context","text":"column names descriptive, querychat may already work well without additional context. However, columns named x, V1, value, etc., provide data description. Use data_description parameter : querychat doesn’t need information particular format – just provide human find helpful:","code":"qc <- querychat(   penguins,   data_description = \"data_description.md\" )  cat(qc$system_prompt) <!-- data_description.md -->  This dataset contains information about Palmer Archipelago penguins, collected for studying penguin populations.  - species: Penguin species (Adelie, Chinstrap, Gentoo) - island: Island where observed (Torgersen, Biscoe, Dream) - bill_length_mm: Bill length in millimeters - bill_depth_mm: Bill depth in millimeters - flipper_length_mm: Flipper length in millimeters - body_mass_g: Body mass in grams - sex: Penguin sex (male, female) - year: Year of observation"},{"path":"https://posit-dev.github.io/querychat/articles/context.html","id":"extra-instructions","dir":"Articles","previous_headings":"","what":"Additional instructions","title":"Provide Context","text":"can add custom instructions guide LLM’s behavior using extra_instructions parameter: string: LLMs may always follow instructions perfectly. Test extensively changing instructions models.","code":"qc <- querychat(   penguins,   extra_instructions = \"instructions.md\" )  cat(qc$system_prompt) instructions <- \" - Use British spelling conventions - Stay on topic and only discuss the data dashboard - Refuse to answer unrelated questions \"  qc <- querychat(   penguins,   extra_instructions = instructions )  cat(qc$system_prompt)"},{"path":"https://posit-dev.github.io/querychat/articles/context.html","id":"custom-template","dir":"Articles","previous_headings":"","what":"Custom template","title":"Provide Context","text":"want control system prompt, can provide custom prompt template using prompt_template parameter. advanced users want fully customize LLM’s behavior. See QueryChat reference details available template variables.","code":""},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"data-frames","dir":"Articles","previous_headings":"","what":"Data frames","title":"Data Sources","text":"can use data frame data source querychat. Simply pass querychat(): Behind scenes, querychat creates -memory DuckDB database registers data frame table SQL query execution.","code":"library(querychat) library(palmerpenguins)  qc <- querychat(mtcars) qc$app()  # Launch the app"},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"database-connections","dir":"Articles","previous_headings":"","what":"Database connections","title":"Data Sources","text":"can also connect querychat directly table database supported DBI. includes popular databases like SQLite, DuckDB, PostgreSQL, MySQL, many . Assuming database set accessible, can create DBI connection pass querychat(). examples common databases.","code":""},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"duckdb","dir":"Articles","previous_headings":"Database connections","what":"DuckDB","title":"Data Sources","text":"","code":"library(DBI) library(duckdb) library(querychat)  # Connect to a DuckDB database file con <- dbConnect(duckdb::duckdb(), dbdir = \"my_database.duckdb\")  qc <- querychat(con, \"my_table\") qc$app()  # Launch the app  # Don't forget to disconnect when done # dbDisconnect(con)"},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"sqlite","dir":"Articles","previous_headings":"Database connections","what":"SQLite","title":"Data Sources","text":"","code":"library(DBI) library(RSQLite) library(querychat)  # Connect to a SQLite database file con <- dbConnect(RSQLite::SQLite(), \"my_database.db\")  qc <- querychat(con, \"my_table\") qc$app()  # Launch the app  # Don't forget to disconnect when done # dbDisconnect(con)"},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"postgresql","dir":"Articles","previous_headings":"Database connections","what":"PostgreSQL","title":"Data Sources","text":"","code":"library(DBI) library(RPostgres) library(querychat)  # Connect to PostgreSQL con <- dbConnect(   RPostgres::Postgres(),   host = \"localhost\",   port = 5432,   dbname = \"mydatabase\",   user = \"myuser\",   password = \"mypassword\" )  qc <- querychat(con, \"my_table\") qc$app()  # Launch the app  # Don't forget to disconnect when done # dbDisconnect(con)"},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"mysql","dir":"Articles","previous_headings":"Database connections","what":"MySQL","title":"Data Sources","text":"","code":"library(DBI) library(RMariaDB) library(querychat)  # Connect to MySQL con <- dbConnect(   RMariaDB::MariaDB(),   host = \"localhost\",   port = 3306,   dbname = \"mydatabase\",   user = \"myuser\",   password = \"mypassword\" )  qc <- querychat(con, \"my_table\") qc$app()  # Launch the app  # Don't forget to disconnect when done # dbDisconnect(con)"},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"creating-a-database-from-a-data-frame","dir":"Articles","previous_headings":"","what":"Creating a database from a data frame","title":"Data Sources","text":"don’t database set , can easily create local DuckDB database data frame: can connect database using DuckDB example .","code":"library(DBI) library(duckdb)  con <- dbConnect(duckdb::duckdb(), dbdir = \"my_database.duckdb\")  # Write a data frame to the database dbWriteTable(con, \"penguins\", penguins)  # Or from CSV duckdb::duckdb_read_csv(con, \"my_table\", \"path/to/your/file.csv\")"},{"path":"https://posit-dev.github.io/querychat/articles/data-sources.html","id":"custom-sources","dir":"Articles","previous_headings":"","what":"Custom sources","title":"Data Sources","text":"custom data source doesn’t fit categories, can implement DataSource interface. See DataSource reference details implementing interface.","code":""},{"path":"https://posit-dev.github.io/querychat/articles/greet.html","id":"provide-a-greeting","dir":"Articles","previous_headings":"","what":"Provide a greeting","title":"Greet Users","text":"querychat UI first appears, usually want greet user basic instructions. default, instructions auto-generated every time user arrives. production setting multiple users/visitors, approach downsides: ’s slower, uses API tokens, produces different results time. Instead, create greeting file pass creating QueryChat object: can provide suggestions user using <span class=\"suggestion\"> <\/span> tag: suggestions appear greeting automatically populate chat text box clicked.","code":"qc <- querychat(   penguins,   greeting = \"greeting.md\" ) qc$app()  # Launch the app * **Filter and sort the data:**   * <span class=\"suggestion\">Show only Adelie penguins<\/span>   * <span class=\"suggestion\">Filter to penguins with body mass over 4000g<\/span>   * <span class=\"suggestion\">Sort by flipper length from longest to shortest<\/span>  * **Answer questions about the data:**   * <span class=\"suggestion\">What is the average bill length by species?<\/span>   * <span class=\"suggestion\">How many penguins are in each island?<\/span>   * <span class=\"suggestion\">Which species has the largest average body mass?<\/span>"},{"path":"https://posit-dev.github.io/querychat/articles/greet.html","id":"generate-a-greeting","dir":"Articles","previous_headings":"","what":"Generate a greeting","title":"Greet Users","text":"need help coming greeting, can use $generate_greeting() method: approach generates greeting saves reuse, avoiding latency cost generating every user.","code":"library(querychat)  # Create QueryChat object with your dataset qc <- querychat(penguins)  # Generate a greeting (this calls the LLM) greeting_text <- qc$generate_greeting(echo = \"text\") #> Hello! I'm here to help you explore and analyze the penguins dataset. #> Here are some example prompts you can try: #> ...  # Save it for reuse writeLines(greeting_text, \"penguins_greeting.md\") # Then use the saved greeting in your app querychat_app(   penguins,   greeting = \"penguins_greeting.md\" )"},{"path":"https://posit-dev.github.io/querychat/articles/models.html","id":"specify-a-model","dir":"Articles","previous_headings":"","what":"Specify a model","title":"Models","text":"use particular model, pass \"{provider}/{model}\" string client parameter, gets passed along ellmer::chat(): , ’d like effectively set new default model, can use querychat.client R option QUERYCHAT_CLIENT environment variable. Note can also useful pass full Chat object client parameter advanced use cases (e.g., custom parameters, tools, etc):","code":"qc <- querychat(penguins, client = \"anthropic/claude-sonnet-4-5\") qc$app()  # Launch the app # In your .Rprofile options(querychat.client = \"anthropic/claude-sonnet-4-5\") client <- chat_anthropic(model = \"claude-sonnet-4-5\") qc <- querychat(penguins, client = client) qc$app()  # Launch the app"},{"path":"https://posit-dev.github.io/querychat/articles/models.html","id":"credentials","dir":"Articles","previous_headings":"","what":"Credentials","title":"Models","text":"models require API key form authentication. See reference page relevant model provider (e.g., chat_anthropic()) learn set credentials. GitHub model marketplace already setup GitHub credentials, GitHub model marketplace provides free easy way get started. See details get setup. general, providers prefer credentials stored environment variables. Common practice use .Renviron file manage variables. example, chat_openai(), might add .Renviron file: , can edit .Renviron file using:","code":"library(ellmer)  # Just works if GITHUB_TOKEN is set in your environment client <- chat_github(model = \"gpt-4.1\") OPENAI_API_KEY=\"your_api_key_here\" usethis::edit_r_environ()"},{"path":"https://posit-dev.github.io/querychat/articles/models.html","id":"recommended-models","dir":"Articles","previous_headings":"","what":"Recommended models","title":"Models","text":"theory, use model tool calling support, currently recommend (November 2025): GPT-4.1 (default) Claude 4.5 Sonnet Google Gemini 3.0 testing, ’ve found models strike good balance accuracy latency. said, smaller/faster models like GPT-4.1-mini Claude Haiku 4.5 work well tables worth trying first—’re significantly cheaper faster. can always switch larger model find results aren’t meeting needs. end spectrum, reasoning models like o3-mini tend slow responses without providing meaningfully better results task. ’ve also seen decent results frontier local models (e.g., gpt-oss:20b), even compute run largest models, still tend lag behind cloud-hosted options terms accuracy speed. Data privacy concerns? data privacy concerns, consider org may provide access private instances models data residency guarantees. example, Azure, AWS Bedrock, Google Vertex AI provide private instances popular LLMs. can interface enterprise providers passing right string (e.g., \"bedrock-anthropic\") Chat object (e.g., chat_bedrock_anthropic()) client parameter. See ellmer docs details.","code":""},{"path":"https://posit-dev.github.io/querychat/articles/tools.html","id":"data-updating","dir":"Articles","previous_headings":"","what":"Data updating","title":"Tools","text":"user asks “Show …” “Filter …” “Sort …”, LLM requests call update_dashboard tool appropriate SQL query input. important constraint query must return original schema columns (typically using SELECT *). called, querychat set reactive value holding current SQL query execute query get result. result query used set reactive value holding filtered/sorted data frame. Thanks reactivity, automatically update views depending data frame, data table displayed UI. tool also takes title parameter, short description filter/sort operation (e.g., “Adelie penguins”). , also, made available reactive value display somewhere app. ’s basic example tool action $app() method. Notice pre-built app shows data table, also SQL query title generated LLM (transparency):  data updating tool reset_dashboard, clears active filters returns data table original unfiltered state. LLM typically uses users say “reset”, “start ”, “clear filters”.","code":"querychat_app(penguins)"},{"path":"https://posit-dev.github.io/querychat/articles/tools.html","id":"data-analysis","dir":"Articles","previous_headings":"","what":"Data analysis","title":"Tools","text":"user asks analytical questions like “average…?”, “many…?”, “item highest…?”, LLM generates SQL query requests call query tool. Unlike data updating tools, tool update reactive values. Instead, : Execute SQL query Display SQL query results UI Return results back LLM interpretation ’s example action:","code":"querychat_app(penguins)"},{"path":"https://posit-dev.github.io/querychat/articles/tools.html","id":"view-the-source","dir":"Articles","previous_headings":"","what":"View the source","title":"Tools","text":"’d like better understand tools work LLM prompted use , check following resources: Source code: querychat_tools.R Prompts: prompts/tool-update-dashboard.md prompts/tool-reset-dashboard.md prompts/tool-query.md","code":""},{"path":"https://posit-dev.github.io/querychat/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Garrick Aden-Buie. Author, maintainer. Joe Cheng. Author, conceptor. Carson Sievert. Author. . Copyright holder, funder.","code":""},{"path":"https://posit-dev.github.io/querychat/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Aden-Buie G, Cheng J, Sievert C (2025). querychat: Filter Query Data Frames 'shiny' Using LLM Chat Interface. R package version 0.1.0.9000, https://posit-dev.github.io/querychat/pkg-r.","code":"@Manual{,   title = {querychat: Filter and Query Data Frames in 'shiny' Using an LLM Chat Interface},   author = {Garrick Aden-Buie and Joe Cheng and Carson Sievert},   year = {2025},   note = {R package version 0.1.0.9000},   url = {https://posit-dev.github.io/querychat/pkg-r}, }"},{"path":"https://posit-dev.github.io/querychat/index.html","id":"querychat-","dir":"","previous_headings":"","what":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","title":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","text":"querychat facilitates safe reliable natural language exploration tabular data, powered SQL large language models (LLMs). users, offers intuitive web application can quickly ask questions data receive verifiable data-driven answers. developer, can access chat UI component, generated SQL queries, filtered data build custom applications integrate natural language querying data workflows.","code":""},{"path":"https://posit-dev.github.io/querychat/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","text":"Install stable release CRAN: development version GitHub:","code":"install.packages(\"querychat\") # install.packages(\"pak\") pak::pak(\"posit-dev/querychat/pkg-r\")"},{"path":"https://posit-dev.github.io/querychat/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","text":"quickest way start chatting data via querychat_app(), provides fully polished Shiny app. requires data source (e.g., data.frame, database connection, etc.) optionally parameters (e.g. LLM client model). running (requires API key1), ’ll notice 3 main views: sidebar chat suggestions start exploring. data table updates reflect filtering sorting queries. SQL query behind data table, transparency reproducibility.  Suppose pick suggestion like “Show Adelie penguins”. Since filtering operation, data table SQL query update accordingly.  querychat can also handle general questions data require calculations aggregations. example, can ask “average bill length species?”. LLM generate SQL query perform calculation, querychat execute , return result chat:","code":"library(querychat) library(palmerpenguins)  querychat_app(penguins, client = \"openai/gpt-4.1\")"},{"path":"https://posit-dev.github.io/querychat/index.html","id":"custom-apps","dir":"","previous_headings":"","what":"Custom apps","title":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","text":"querychat designed highly extensible – provides programmatic access chat interface, filtered/sorted data frame, SQL queries, . makes easy build custom web apps leverage natural language interaction data. example, ’s bespoke app exploring Airbnb listings Ashville, NC:  learn , see Build app step--step guide.","code":""},{"path":"https://posit-dev.github.io/querychat/index.html","id":"how-it-works","dir":"","previous_headings":"","what":"How it works","title":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","text":"querychat uses LLMs translate natural language SQL queries. Models sizes, small ones can run locally large frontier models major AI providers, remarkably effective task. even best models need understand data’s overall structure perform well. address , querychat includes schema metadata – column names, types, ranges, categorical values – LLM’s system prompt. Importantly, querychat send raw data LLM; shares enough structural information model generate accurate queries. LLM produces query, querychat executes SQL database (DuckDB2, default) obtain precise results. design makes querychat reliable, safe, reproducible: Reliable: query results come real database, LLM-generated summaries – outputs precise, verifiable, less vulnerable hallucination3. Safe: querychat’s tools read-design, avoiding destructive actions data.4 Reproducible: generated SQL can exported re-run environments, analysis isn’t locked single tool. Data privacy See Provide context Tools articles details exactly information provided LLM customize .","code":""},{"path":"https://posit-dev.github.io/querychat/index.html","id":"next-steps","dir":"","previous_headings":"","what":"Next steps","title":"Filter and Query Data Frames in shiny Using an LLM Chat Interface","text":", might want learn : Models: customize LLM behind querychat. Data sources: different data sources can use querychat. Provide context: provide LLM context needs work well. Build app: design custom Shiny app around querychat. Greet users: create welcoming onboarding experiences. Tools: understand querychat can hood.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":null,"dir":"Reference","previous_headings":"","what":"DBI Source — DBISource","title":"DBI Source — DBISource","text":"DataSource implementation DBI database connections (SQLite, PostgreSQL, MySQL, etc.).","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DBI Source — DBISource","text":"class wraps DBI connection provides SQL query execution specified table database.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"DBI Source — DBISource","text":"querychat::DataSource -> DBISource","code":""},{"path":[]},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"DBI Source — DBISource","text":"DBISource$new() DBISource$get_db_type() DBISource$get_schema() DBISource$execute_query() DBISource$test_query() DBISource$get_data() DBISource$cleanup() DBISource$clone()","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"DBI Source — DBISource","text":"Create new DBISource","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$new(conn, table_name)"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DBI Source — DBISource","text":"conn DBI connection object table_name Name table database. Can character string DBI::Id() object tables catalogs/schemas","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"new DBISource object","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DBI Source — DBISource","text":"","code":"\\dontrun{ conn <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") DBI::dbWriteTable(conn, \"iris\", iris) source <- DBISource$new(conn, \"iris\") }"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-get-db-type-","dir":"Reference","previous_headings":"","what":"Method get_db_type()","title":"DBI Source — DBISource","text":"Get database type","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$get_db_type()"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"string identifying database type","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-get-schema-","dir":"Reference","previous_headings":"","what":"Method get_schema()","title":"DBI Source — DBISource","text":"Get schema information database table","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$get_schema(categorical_threshold = 20)"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"DBI Source — DBISource","text":"categorical_threshold Maximum number unique values text column considered categorical (default: 20)","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"string describing schema","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-execute-query-","dir":"Reference","previous_headings":"","what":"Method execute_query()","title":"DBI Source — DBISource","text":"Execute SQL query","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$execute_query(query)"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"DBI Source — DBISource","text":"query SQL query string. NULL empty, returns data","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"data frame query results","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-test-query-","dir":"Reference","previous_headings":"","what":"Method test_query()","title":"DBI Source — DBISource","text":"Test SQL query fetching one row","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$test_query(query)"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"DBI Source — DBISource","text":"query SQL query string","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"data frame one row results","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-get-data-","dir":"Reference","previous_headings":"","what":"Method get_data()","title":"DBI Source — DBISource","text":"Get data table","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$get_data()"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"data frame containing data","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-cleanup-","dir":"Reference","previous_headings":"","what":"Method cleanup()","title":"DBI Source — DBISource","text":"Disconnect database","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$cleanup()"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"DBI Source — DBISource","text":"NULL (invisibly)","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"DBI Source — DBISource","text":"objects class cloneable method.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"DBI Source — DBISource","text":"","code":"DBISource$clone(deep = FALSE)"},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"DBI Source — DBISource","text":"deep Whether make deep clone.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DBISource.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DBI Source — DBISource","text":"","code":"if (FALSE) { # \\dontrun{ # Connect to a database conn <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") DBI::dbWriteTable(conn, \"mtcars\", mtcars)  # Create a DBI source db_source <- DBISource$new(conn, \"mtcars\")  # Get database type db_source$get_db_type()  # Returns \"SQLite\"  # Execute a query result <- db_source$execute_query(\"SELECT * FROM mtcars WHERE mpg > 25\")  # Note: cleanup() will disconnect the connection # If you want to keep the connection open, don't call cleanup() } # }  ## ------------------------------------------------ ## Method `DBISource$new` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ conn <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") DBI::dbWriteTable(conn, \"iris\", iris) source <- DBISource$new(conn, \"iris\") } # }"},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":null,"dir":"Reference","previous_headings":"","what":"Data Frame Source — DataFrameSource","title":"Data Frame Source — DataFrameSource","text":"DataSource implementation wraps data frame using DuckDB SQLite SQL query execution.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data Frame Source — DataFrameSource","text":"class creates -memory database connection registers provided data frame table. SQL queries executed database table. See DBISource full description available methods. default, DataFrameSource uses first available engine duckdb (checked first) RSQLite. can explicitly set engine parameter choose \"duckdb\" \"sqlite\", set global option querychat.DataFrameSource.engine choose default engine DataFrameSource instances. least one packages must installed.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"Data Frame Source — DataFrameSource","text":"querychat::DataSource -> querychat::DBISource -> DataFrameSource","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Data Frame Source — DataFrameSource","text":"querychat::DBISource$cleanup() querychat::DBISource$execute_query() querychat::DBISource$get_data() querychat::DBISource$get_db_type() querychat::DBISource$get_schema() querychat::DBISource$test_query()","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Data Frame Source — DataFrameSource","text":"DataFrameSource$new() DataFrameSource$clone()","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Data Frame Source — DataFrameSource","text":"Create new DataFrameSource","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Frame Source — DataFrameSource","text":"","code":"DataFrameSource$new(   df,   table_name,   engine = getOption(\"querychat.DataFrameSource.engine\", NULL) )"},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Frame Source — DataFrameSource","text":"df data frame. table_name Name use table SQL queries. Must valid table name (start letter, contain letters, numbers, underscores) engine Database engine use: \"duckdb\" \"sqlite\". Set global option querychat.DataFrameSource.engine specify default engine instances. NULL (default), uses first available engine duckdb RSQLite (order).","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Frame Source — DataFrameSource","text":"new DataFrameSource object","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data Frame Source — DataFrameSource","text":"","code":"\\dontrun{ source <- DataFrameSource$new(iris, \"iris\") }"},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Data Frame Source — DataFrameSource","text":"objects class cloneable method.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Frame Source — DataFrameSource","text":"","code":"DataFrameSource$clone(deep = FALSE)"},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Frame Source — DataFrameSource","text":"deep Whether make deep clone.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataFrameSource.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data Frame Source — DataFrameSource","text":"","code":"if (FALSE) { # \\dontrun{ # Create a data frame source (uses first available: duckdb or sqlite) df_source <- DataFrameSource$new(mtcars, \"mtcars\")  # Get database type df_source$get_db_type()  # Returns \"DuckDB\" or \"SQLite\"  # Execute a query result <- df_source$execute_query(\"SELECT * FROM mtcars WHERE mpg > 25\")  # Explicitly choose an engine df_sqlite <- DataFrameSource$new(mtcars, \"mtcars\", engine = \"sqlite\")  # Clean up when done df_source$cleanup() df_sqlite$cleanup() } # }  ## ------------------------------------------------ ## Method `DataFrameSource$new` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ source <- DataFrameSource$new(iris, \"iris\") } # }"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":null,"dir":"Reference","previous_headings":"","what":"Data Source Base Class — DataSource","title":"Data Source Base Class — DataSource","text":"abstract R6 class defining interface custom QueryChat data sources must implement. class instantiated directly; instead, use one concrete implementations like DataFrameSource DBISource.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Data Source Base Class — DataSource","text":"table_name Name table used SQL queries","code":""},{"path":[]},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Data Source Base Class — DataSource","text":"DataSource$get_db_type() DataSource$get_schema() DataSource$execute_query() DataSource$test_query() DataSource$get_data() DataSource$cleanup() DataSource$clone()","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-get-db-type-","dir":"Reference","previous_headings":"","what":"Method get_db_type()","title":"Data Source Base Class — DataSource","text":"Get database type","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$get_db_type()"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Source Base Class — DataSource","text":"string describing database type (e.g., \"DuckDB\", \"SQLite\")","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-get-schema-","dir":"Reference","previous_headings":"","what":"Method get_schema()","title":"Data Source Base Class — DataSource","text":"Get schema information table","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$get_schema(categorical_threshold = 20)"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Source Base Class — DataSource","text":"categorical_threshold Maximum number unique values text column considered categorical","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Source Base Class — DataSource","text":"string containing schema information formatted LLM prompts","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-execute-query-","dir":"Reference","previous_headings":"","what":"Method execute_query()","title":"Data Source Base Class — DataSource","text":"Execute SQL query return results","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$execute_query(query)"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Source Base Class — DataSource","text":"query SQL query string execute","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Source Base Class — DataSource","text":"data frame containing query results","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-test-query-","dir":"Reference","previous_headings":"","what":"Method test_query()","title":"Data Source Base Class — DataSource","text":"Test SQL query fetching one row","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$test_query(query)"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Source Base Class — DataSource","text":"query SQL query string test","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Source Base Class — DataSource","text":"data frame containing one row results (empty matches)","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-get-data-","dir":"Reference","previous_headings":"","what":"Method get_data()","title":"Data Source Base Class — DataSource","text":"Get unfiltered data data frame","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$get_data()"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Source Base Class — DataSource","text":"data frame containing data table","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-cleanup-","dir":"Reference","previous_headings":"","what":"Method cleanup()","title":"Data Source Base Class — DataSource","text":"Clean resources (close connections, etc.)","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$cleanup()"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Data Source Base Class — DataSource","text":"NULL (invisibly)","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Data Source Base Class — DataSource","text":"objects class cloneable method.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Source Base Class — DataSource","text":"","code":"DataSource$clone(deep = FALSE)"},{"path":"https://posit-dev.github.io/querychat/reference/DataSource.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Source Base Class — DataSource","text":"deep Whether make deep clone.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":null,"dir":"Reference","previous_headings":"","what":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"QueryChat R6 class built Shiny, shinychat, ellmer enable interactive querying data using natural language. leverages large language models (LLMs) translate user questions SQL queries, execute data source (data frame database), various ways accessing/displaying results.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"QueryChat class takes data (data frame database connection) input provides methods : Generate chat UI natural language queries (e.g., $app(), $sidebar()) Initialize server logic returns session-specific reactive values (via $server()) Access reactive data, SQL queries, titles returned server values","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"library(querychat)  # Create a QueryChat object qc <- QueryChat$new(mtcars)  # Quick start: run a complete app qc$app()  # Or build a custom Shiny app ui <- page_sidebar(   qc$sidebar(),   verbatimTextOutput(\"sql\"),   dataTableOutput(\"data\") )  server <- function(input, output, session) {   qc_vals <- qc$server()    output$sql <- renderText(qc_vals$sql())   output$data <- renderDataTable(qc_vals$df()) }  shinyApp(ui, server)"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"greeting greeting message displayed users. id ID QueryChat instance. tools allowed tools chat client.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"system_prompt Get system prompt. data_source Get current data source.","code":""},{"path":[]},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"QueryChat$new() QueryChat$client() QueryChat$console() QueryChat$app() QueryChat$app_obj() QueryChat$sidebar() QueryChat$ui() QueryChat$server() QueryChat$generate_greeting() QueryChat$cleanup() QueryChat$clone()","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Create new QueryChat object.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$new(   data_source,   table_name = missing_arg(),   ...,   id = NULL,   greeting = NULL,   client = NULL,   tools = c(\"update\", \"query\"),   data_description = NULL,   categorical_threshold = 20,   extra_instructions = NULL,   prompt_template = NULL,   cleanup = NA )"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"data_source Either data.frame database connection (e.g., DBI connection). table_name string specifying table name use SQL queries. data_source data.frame, name refer queries (typically variable name). provided, inferred variable name data.frame inputs. database connections, parameter required. ... Additional arguments (currently unused). id Optional module ID QueryChat instance. provided, auto-generated table_name. ID used namespace Shiny module. greeting Optional initial message display users. Can character string (Markdown format) file path. provided, greeting generated start conversation using LLM, adds latency cost. Use $generate_greeting() create greeting save reuse. client Optional chat client. Can : ellmer::Chat object string pass ellmer::chat() (e.g., \"openai/gpt-4o\") NULL (default): Uses querychat.client option, QUERYCHAT_CLIENT environment variable, defaults ellmer::chat_openai() tools querychat tools include chat client, default. \"update\" includes tools updating resetting dashboard \"query\" includes tool executing SQL queries. Use tools = \"update\" want dashboard updating tools, want disable querying tool entirely prevent LLM seeing data dataset. data_description Optional description data plain text Markdown. Can string file path. provides context LLM data represents. categorical_threshold text columns, maximum number unique values consider categorical variable. Default 20. extra_instructions Optional additional instructions chat model plain text Markdown. Can string file path. prompt_template Optional path string custom prompt template file. provided, default querychat template used. See package prompts directory default template format. cleanup Whether automatically run $cleanup() Shiny session/app stops. default, cleanup occurs QueryChat gets created within Shiny session. Set TRUE always clean , FALSE never clean automatically.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"new QueryChat object.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ # Basic usage qc <- QueryChat$new(mtcars)  # With options qc <- QueryChat$new(   mtcars,   greeting = \"Welcome to the mtcars explorer!\",   client = \"openai/gpt-4o\",   data_description = \"Motor Trend car road tests dataset\" )  # With database library(DBI) conn <- dbConnect(RSQLite::SQLite(), \":memory:\") dbWriteTable(conn, \"mtcars\", mtcars) qc <- QueryChat$new(conn, \"mtcars\") }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-client-","dir":"Reference","previous_headings":"","what":"Method client()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Create chat client, complete registered tools, current data source.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$client(   tools = NA,   update_dashboard = function(query, title) {  },   reset_dashboard = function() {  } )"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"tools querychat tools include chat client. \"update\" includes tools updating resetting dashboard \"query\" includes tool executing SQL queries. default, tools = NA, values provided initialization used. update_dashboard Optional function call query title generated LLM update_dashboard tool. reset_dashboard Optional function call reset_dashboard tool called.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-console-","dir":"Reference","previous_headings":"","what":"Method console()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Launch console-based chat interface data source.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$console(new = FALSE, ..., tools = \"query\")"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"new Whether create new chat client instance continue conversation last console chat session (default). ... Additional arguments passed $client() method. tools querychat tools include chat client. See $client() details. Ignored creating new chat client. default, \"query\" tool included, regardless tools set initialization.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-app-","dir":"Reference","previous_headings":"","what":"Method app()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Create run Shiny gadget chatting data Runs Shiny gadget (designed interactive use) provides complete interface chatting data using natural language. looking deploy app run means, see $app_obj().","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$app(..., bookmark_store = \"url\")"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"... Arguments passed $app_obj(). bookmark_store bookmarking storage method. Passed shiny::enableBookmarking(). \"url\" \"server\", chat state (including current query) bookmarked. Default \"url\".","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Invisibly returns list session-specific values: df: final filtered data frame sql: final SQL query string title: final title client: session-specific chat client instance","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples-1","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ library(querychat)  qc <- QueryChat$new(mtcars) qc$app() }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-app-obj-","dir":"Reference","previous_headings":"","what":"Method app_obj()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"streamlined Shiny app chatting data Creates Shiny app designed chatting data, : sidebar containing chat interface card displaying current SQL query card displaying filtered data table reset button clear query","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$app_obj(..., bookmark_store = \"url\")"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"... Additional arguments (currently unused). bookmark_store bookmarking storage method. Passed shiny::enableBookmarking(). \"url\" \"server\", chat state (including current query) bookmarked. Default \"url\".","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Shiny app object can run shiny::runApp().","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples-2","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ library(querychat)  qc <- QueryChat$new(mtcars) app <- qc$app_obj() shiny::runApp(app) }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-sidebar-","dir":"Reference","previous_headings":"","what":"Method sidebar()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Create sidebar containing querychat UI. method generates bslib::sidebar() component containing chat interface, suitable use bslib::page_sidebar() similar layouts.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$sidebar(   ...,   width = 400,   height = \"100%\",   fillable = TRUE,   id = NULL )"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"... Additional arguments passed bslib::sidebar(). width Width sidebar pixels. Default 400. height Height sidebar. Default \"100%\". fillable Whether sidebar fillable. Default TRUE. id Optional ID QueryChat instance. provided, use ID provided initialization. using $sidebar() Shiny module, need provide id = ns(\"your_id\") ns namespacing function shiny::NS().","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"bslib::sidebar() UI component.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples-3","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ qc <- QueryChat$new(mtcars)  ui <- page_sidebar(   qc$sidebar(),   # Main content here ) }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-ui-","dir":"Reference","previous_headings":"","what":"Method ui()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Create UI querychat chat interface. method generates chat UI component. Typically use $sidebar() instead, wraps sidebar layout.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$ui(..., id = NULL)"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"... Additional arguments passed shinychat::chat_ui(). id Optional ID QueryChat instance. provided, use ID provided initialization. using $ui() Shiny module, need provide id = ns(\"your_id\") ns namespacing function shiny::NS().","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"UI component containing chat interface.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples-4","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ qc <- QueryChat$new(mtcars)  ui <- fluidPage(   qc$ui() ) }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-server-","dir":"Reference","previous_headings":"","what":"Method server()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Initialize querychat server logic. method must called within Shiny server function. sets reactive logic chat interface returns session-specific reactive values.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$server(   enable_bookmarking = FALSE,   ...,   id = NULL,   session = shiny::getDefaultReactiveDomain() )"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"enable_bookmarking Whether enable bookmarking chat state. Default FALSE. enabled, chat state (including current query, title, chat history) saved restored Shiny bookmarks. requires Shiny app bookmarking enabled via shiny::enableBookmarking() enableBookmarking parameter shiny::shinyApp(). ... Ignored. id Optional module ID QueryChat instance. provided, use ID provided initialization. used Shiny modules, id match id used corresponding UI function (.e., qc$ui(id = ns(\"your_id\")) pairs qc$server(id = \"your_id\")). session Shiny session object.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"list containing session-specific reactive values chat client following elements: df: Reactive expression returning current filtered data frame sql: Reactive value current SQL query string title: Reactive value current title client: session-specific chat client instance","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples-5","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ qc <- QueryChat$new(mtcars)  server <- function(input, output, session) {   qc_vals <- qc$server(enable_bookmarking = TRUE)    output$data <- renderDataTable(qc_vals$df())   output$query <- renderText(qc_vals$sql())   output$title <- renderText(qc_vals$title() %||% \"No Query\") } }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-generate-greeting-","dir":"Reference","previous_headings":"","what":"Method generate_greeting()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Generate welcome greeting chat. default, QueryChat$new() generates greeting start every new conversation, convenient getting started development, also might add unnecessary latency cost. Use method generate greeting save reuse.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$generate_greeting(echo = c(\"none\", \"output\"))"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"echo Whether print greeting console. Options \"none\" (default, output) \"output\" (print console).","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"greeting string Markdown format.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"examples-6","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"\\dontrun{ # Create QueryChat object qc <- QueryChat$new(mtcars)  # Generate a greeting and save it greeting <- qc$generate_greeting() writeLines(greeting, \"mtcars_greeting.md\")  # Later, use the saved greeting qc2 <- QueryChat$new(mtcars, greeting = \"mtcars_greeting.md\") }"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-cleanup-","dir":"Reference","previous_headings":"","what":"Method cleanup()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Clean resources associated data source. method releases resources (e.g., database connections) associated data source. Call done using QueryChat object avoid resource leaks. Note: auto_cleanup set TRUE constructor, called automatically Shiny app stops.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$cleanup()"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"Invisibly returns NULL. Resources cleaned internally.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"objects class cloneable method.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"QueryChat$clone(deep = FALSE)"},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"deep Whether make deep clone.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/QueryChat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat: Interactive Data Querying with Natural Language — QueryChat","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage with a data frame qc <- QueryChat$new(mtcars) app <- qc$app()  # With a custom greeting greeting <- \"Welcome! Ask me about the mtcars dataset.\" qc <- QueryChat$new(mtcars, greeting = greeting)  # With a specific LLM provider qc <- QueryChat$new(mtcars, client = \"anthropic/claude-sonnet-4-5\")  # Generate a greeting for reuse qc <- QueryChat$new(mtcars) greeting <- qc$generate_greeting(echo = \"text\") # Save greeting for next time writeLines(greeting, \"mtcars_greeting.md\") } # }  ## ------------------------------------------------ ## Method `QueryChat$new` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ # Basic usage qc <- QueryChat$new(mtcars)  # With options qc <- QueryChat$new(   mtcars,   greeting = \"Welcome to the mtcars explorer!\",   client = \"openai/gpt-4o\",   data_description = \"Motor Trend car road tests dataset\" )  # With database library(DBI) conn <- dbConnect(RSQLite::SQLite(), \":memory:\") dbWriteTable(conn, \"mtcars\", mtcars) qc <- QueryChat$new(conn, \"mtcars\") } # }  ## ------------------------------------------------ ## Method `QueryChat$app` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ library(querychat)  qc <- QueryChat$new(mtcars) qc$app() } # }   ## ------------------------------------------------ ## Method `QueryChat$app_obj` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ library(querychat)  qc <- QueryChat$new(mtcars) app <- qc$app_obj() shiny::runApp(app) } # }   ## ------------------------------------------------ ## Method `QueryChat$sidebar` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ qc <- QueryChat$new(mtcars)  ui <- page_sidebar(   qc$sidebar(),   # Main content here ) } # }  ## ------------------------------------------------ ## Method `QueryChat$ui` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ qc <- QueryChat$new(mtcars)  ui <- fluidPage(   qc$ui() ) } # }  ## ------------------------------------------------ ## Method `QueryChat$server` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ qc <- QueryChat$new(mtcars)  server <- function(input, output, session) {   qc_vals <- qc$server(enable_bookmarking = TRUE)    output$data <- renderDataTable(qc_vals$df())   output$query <- renderText(qc_vals$sql())   output$title <- renderText(qc_vals$title() %||% \"No Query\") } } # }  ## ------------------------------------------------ ## Method `QueryChat$generate_greeting` ## ------------------------------------------------  if (FALSE) { # \\dontrun{ # Create QueryChat object qc <- QueryChat$new(mtcars)  # Generate a greeting and save it greeting <- qc$generate_greeting() writeLines(greeting, \"mtcars_greeting.md\")  # Later, use the saved greeting qc2 <- QueryChat$new(mtcars, greeting = \"mtcars_greeting.md\") } # }"},{"path":"https://posit-dev.github.io/querychat/reference/deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated functions — deprecated","title":"Deprecated functions — deprecated","text":"functions replaced new QueryChat R6 class API. Please update code use new class-based approach.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated functions — deprecated","text":"","code":"querychat_init(...)  querychat_sidebar(...)  querychat_ui(...)  querychat_server(...)  querychat_greeting(...)  querychat_data_source(...)"},{"path":"https://posit-dev.github.io/querychat/reference/is_data_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is a DataSource — is_data_source","title":"Check if object is a DataSource — is_data_source","text":"Check object DataSource","code":""},{"path":"https://posit-dev.github.io/querychat/reference/is_data_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is a DataSource — is_data_source","text":"","code":"is_data_source(x)"},{"path":"https://posit-dev.github.io/querychat/reference/is_data_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is a DataSource — is_data_source","text":"x Object check","code":""},{"path":"https://posit-dev.github.io/querychat/reference/is_data_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is a DataSource — is_data_source","text":"TRUE x DataSource, FALSE otherwise","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-convenience.html","id":null,"dir":"Reference","previous_headings":"","what":"QueryChat convenience functions — querychat","title":"QueryChat convenience functions — querychat","text":"Convenience functions wrapping QueryChat creation (.e., querychat()) app launching (.e., querychat_app()).","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-convenience.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QueryChat convenience functions — querychat","text":"","code":"querychat(   data_source,   table_name = missing_arg(),   ...,   id = NULL,   greeting = NULL,   client = NULL,   tools = c(\"update\", \"query\"),   data_description = NULL,   categorical_threshold = 20,   extra_instructions = NULL,   prompt_template = NULL,   cleanup = NA )  querychat_app(   data_source,   table_name = missing_arg(),   ...,   id = NULL,   greeting = NULL,   client = NULL,   tools = c(\"update\", \"query\"),   data_description = NULL,   categorical_threshold = 20,   extra_instructions = NULL,   prompt_template = NULL,   cleanup = NA,   bookmark_store = \"url\" )"},{"path":"https://posit-dev.github.io/querychat/reference/querychat-convenience.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"QueryChat convenience functions — querychat","text":"data_source Either data.frame database connection (e.g., DBI connection). table_name string specifying table name use SQL queries. data_source data.frame, name refer queries (typically variable name). provided, inferred variable name data.frame inputs. database connections, parameter required. ... Additional arguments (currently unused). id Optional module ID QueryChat instance. provided, auto-generated table_name. ID used namespace Shiny module. greeting Optional initial message display users. Can character string (Markdown format) file path. provided, greeting generated start conversation using LLM, adds latency cost. Use $generate_greeting() create greeting save reuse. client Optional chat client. Can : ellmer::Chat object string pass ellmer::chat() (e.g., \"openai/gpt-4o\") NULL (default): Uses querychat.client option, QUERYCHAT_CLIENT environment variable, defaults ellmer::chat_openai() tools querychat tools include chat client, default. \"update\" includes tools updating resetting dashboard \"query\" includes tool executing SQL queries. Use tools = \"update\" want dashboard updating tools, want disable querying tool entirely prevent LLM seeing data dataset. data_description Optional description data plain text Markdown. Can string file path. provides context LLM data represents. categorical_threshold text columns, maximum number unique values consider categorical variable. Default 20. extra_instructions Optional additional instructions chat model plain text Markdown. Can string file path. prompt_template Optional path string custom prompt template file. provided, default querychat template used. See package prompts directory default template format. cleanup Whether automatically run $cleanup() Shiny session/app stops. default, cleanup occurs QueryChat created within Shiny app. Set TRUE always clean , FALSE never clean automatically. querychat_app(), -memory databases created data frames always cleaned . bookmark_store bookmarking storage method. Passed shiny::enableBookmarking(). \"url\" \"server\", chat state (including current query) bookmarked. Default \"url\".","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-convenience.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"QueryChat convenience functions — querychat","text":"QueryChat object. See QueryChat available methods. Invisibly returns chat object app stops.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-convenience.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QueryChat convenience functions — querychat","text":"","code":"if (FALSE) { # \\dontrun{ # Quick start - chat with mtcars dataset in one line querychat_app(mtcars)  # Add options querychat_app(   mtcars,   greeting = \"Welcome to the mtcars explorer!\",   client = \"openai/gpt-4o\" )  # Chat with a database table (table_name required) library(DBI) conn <- dbConnect(RSQLite::SQLite(), \":memory:\") dbWriteTable(conn, \"mtcars\", mtcars) querychat_app(conn, \"mtcars\")  # Create QueryChat class object qc <- querychat(mtcars)  # Run the app later qc$app()  } # }"},{"path":"https://posit-dev.github.io/querychat/reference/querychat-package.html","id":null,"dir":"Reference","previous_headings":"","what":"querychat: Chat with Your Data Using Natural Language — querychat-package","title":"querychat: Chat with Your Data Using Natural Language — querychat-package","text":"querychat provides interactive chat interface querying data using natural language. translates questions SQL queries, executes data, displays results. package works data frames database connections.","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-package.html","id":"quick-start","dir":"Reference","previous_headings":"","what":"Quick Start","title":"querychat: Chat with Your Data Using Natural Language — querychat-package","text":"easiest way get started QueryChat R6 class:","code":"library(querychat)  # Create a QueryChat object (table name inferred from variable) qc <- QueryChat$new(mtcars)  # Option 1: Run a complete app with sensible defaults qc$app()  # Option 2: Build a custom Shiny app ui <- page_sidebar(   qc$sidebar(),   dataTableOutput(\"data\") )  server <- function(input, output, session) {   qc$server()   output$data <- renderDataTable(qc$df()) }  shinyApp(ui, server)"},{"path":"https://posit-dev.github.io/querychat/reference/querychat-package.html","id":"key-features","dir":"Reference","previous_headings":"","what":"Key Features","title":"querychat: Chat with Your Data Using Natural Language — querychat-package","text":"Natural language queries: Ask questions plain English SQL transparency: See generated SQL queries Multiple data sources: Works data frames database connections Customizable: Add data descriptions, extra instructions, custom greetings LLM agnostic: Works OpenAI, Anthropic, Google, providers via ellmer","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-package.html","id":"main-components","dir":"Reference","previous_headings":"","what":"Main Components","title":"querychat: Chat with Your Data Using Natural Language — querychat-package","text":"QueryChat: main R6 class creating chat interfaces DataSource, DataFrameSource, DBISource: R6 classes data sources","code":""},{"path":"https://posit-dev.github.io/querychat/reference/querychat-package.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"querychat: Chat with Your Data Using Natural Language — querychat-package","text":"see examples included package, run:   provides list available examples. run specific example, like '01-hello-app', use:","code":"shiny::runExample(package = \"querychat\") shiny::runExample(\"01-hello-app\", package = \"querychat\")"},{"path":[]},{"path":"https://posit-dev.github.io/querychat/reference/querychat-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"querychat: Chat with Your Data Using Natural Language — querychat-package","text":"Maintainer: Garrick Aden-Buie garrick@posit.co (ORCID) Authors: Joe Cheng joe@posit.co [conceptor] Carson Sievert carson@posit.co (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://posit-dev.github.io/querychat/news/index.html","id":"querychat-development-version","dir":"Changelog","previous_headings":"","what":"querychat (development version)","title":"querychat (development version)","text":"querychat() QueryChat$new() now use either duckdb {SQLite} -memory database backend data frames, depending package installed. installed, duckdb preferred. can explicitly choose engine DataFrameSource$new() set querychat.DataFrameSource.engine option choose global default. (#178) QueryChat$sidebar(), QueryChat$ui(), QueryChat$server() now support optional id parameter enable use within Shiny modules. used module UI function, pass id = ns(\"your_id\") ns namespacing function shiny::NS(). corresponding module server function, pass unwrapped ID QueryChat$server(id = \"your_id\"). enables multiple independent QueryChat instances QueryChat object. (#172) QueryChat$client() can now create standalone querychat-enabled chat clients configurable tools callbacks, enabling use outside Shiny applications. (#168) QueryChat$console() added launch interactive console-based chat sessions data source, persistent conversation state across invocations. (#168) tools used QueryChat chatbot now configurable. Use new tools parameter querychat() QueryChat$new() select either \"query\" \"update\" tools. Choose tools = \"update\" want QueryChat able update dashboard (useful want 100% certain LLM see raw data). (#168) querychat_app() now automatically clean data source QueryChat creates data source internally data frame. (#164) Breaking change: $sql() method now returns NULL instead \"\" (empty string) query set, aligning behavior $title() consistency. code using isTruthy() similar falsy checks continue working without changes. Code explicitly checks sql() == \"\" updated use falsy checks (e.g., !isTruthy(sql())) explicit null checks (.null(sql())). (#146) Tool detail cards can now expanded collapsed default querychat runs query updates dashboard via querychat.tool_details R option QUERYCHAT_TOOL_DETAILS environment variable. Valid values \"expanded\", \"collapsed\", \"default\". (#137) Added bookmarking support QueryChat$server() querychat_app(). bookmarking enabled (via bookmark_store = \"url\" \"server\" querychat_app() $app_obj(), via enable_bookmarking = TRUE $server()), chat state (including current query, title, chat history) saved restored Shiny bookmarks. (#107) Nearly entire functional API (.e., querychat_init(), querychat_sidebar(), querychat_server(), etc) hard deprecated favor simpler OOP-based API. Namely, new QueryChat$new() class now main entry point (instead querychat_init()) methods replace old functions (e.g., $sidebar(), $server(), etc). (#109) addition, querychat_data_source() renamed as_querychat_data_source(), remains exported developer extension point, users longer explicitly create data source. (#109) Added prompt_template support querychat_system_prompt(). (Thank , @oacar! #37, #45) querychat_init() now accepts client, replacing previous create_chat_func argument. (#60) client can : ellmer::Chat object, function returns ellmer::Chat object, provider-model string, e.g. \"openai/gpt-4.1\", passed ellmer::chat(). client provided, querychat use querychat.client R option, can options, QUERYCHAT_CLIENT environment variable, provider-model string, default model ellmer::chat_openai(). querychat_server() now uses shiny::ExtendedTask streaming chat response, allows dashboard update remain responsive chat response streaming . (#63) querychat now requires ellmer version 0.3.0 later uses rich tool cards dashboard updates database queries. (#65) New querychat_app() function lets quickly launch Shiny app querychat chat interface. (#66) querychat_ui() now adds .querychat class chat container querychat_sidebar() adds .querychat-sidebar class sidebar, allowing easier customization via CSS. (#68) querychat now uses separate tool reset dashboard. (#80) querychat_greeting() can used generate greeting message querychat bot. (#87) querychat’s system prompt tool descriptions rewritten clarity future extensibility. (#90)","code":""}]
