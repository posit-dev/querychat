[
  {
    "objectID": "context.html",
    "href": "context.html",
    "title": "Provide context",
    "section": "",
    "text": "querychat automatically gathers information about your table to help the LLM write accurate SQL queries. This includes column names and types, numerical ranges, and categorical value examples.1\nImportantly, we are not sending your raw data to the LLM and asking it to do complicated math. The LLM only needs to understand the structure and schema of your data in order to write SQL queries.\nYou can get even better results by customizing the system prompt in three ways:",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#default-prompt",
    "href": "context.html#default-prompt",
    "title": "Provide context",
    "section": "Default prompt",
    "text": "Default prompt\nFor full visibility into the system prompt that querychat generates for the LLM, you can inspect the system_prompt property. This is useful for debugging and understanding exactly what context the LLM is using:\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nprint(qc.system_prompt)\nBy default, the system prompt contains the following components:\n\nThe basic set of behaviors and guidelines the LLM must follow in order for querychat to work properly, including how to use tools to execute queries and update the app.\nThe SQL schema of the data frame you provided. This includes:\n\nColumn names\nData types (integer, float, boolean, datetime, text)\nFor text columns with less than 10 unique values, we assume they are categorical variables and include the list of values\nFor integer and float columns, we include the range\n\nA data description (if provided via data_description)\nAdditional instructions you want to use to guide querychat’s behavior (if provided via extra_instructions).",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#data-description",
    "href": "context.html#data-description",
    "title": "Provide context",
    "section": "Data description",
    "text": "Data description\nIf your column names are descriptive, querychat may already work well without additional context. However, if your columns are named x, V1, value, etc., you should provide a data description. Use the data_description parameter for this:\n\n\ntitanic-app.py\n\nfrom pathlib import Path\nfrom querychat import QueryChat\n\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    data_description=Path(\"data_description.md\")\n)\napp = qc.app()\n\nquerychat doesn’t need this information in any particular format – just provide what a human would find helpful:\n\n\ndata_description.md\n\nThis dataset contains information about Titanic passengers, collected for predicting survival.\n\n- survived: Survival (0 = No, 1 = Yes)\n- pclass: Ticket class (1 = 1st, 2 = 2nd, 3 = 3rd)\n- sex: Sex of passenger\n- age: Age in years\n- sibsp: Number of siblings/spouses aboard\n- parch: Number of parents/children aboard\n- fare: Passenger fare\n- embarked: Port of embarkation (C = Cherbourg, Q = Queenstown, S = Southampton)",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#extra-instructions",
    "href": "context.html#extra-instructions",
    "title": "Provide context",
    "section": "Additional instructions",
    "text": "Additional instructions\nYou can add custom instructions to guide the LLM’s behavior using the extra_instructions parameter:\nqc = QueryChat(\n    titanic,\n    \"titanic\",\n    extra_instructions=Path(\"instructions.md\")\n)\nOr as a string:\ninstructions = \"\"\"\n- Use British spelling conventions\n- Stay on topic and only discuss the data dashboard\n- Refuse to answer unrelated questions\n\"\"\"\n\nqc = QueryChat(titanic, \"titanic\", extra_instructions=instructions)\n\n\n\n\n\n\nWarning\n\n\n\nLLMs may not always follow your instructions perfectly. Test extensively when changing instructions or models.",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#custom-template",
    "href": "context.html#custom-template",
    "title": "Provide context",
    "section": "Custom template",
    "text": "Custom template\nIf you want more control over the system prompt, you can provide a custom prompt template using the prompt_template parameter. This is for more advanced users who want to fully customize the LLM’s behavior. See the API reference for details on the available template variables.",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "context.html#footnotes",
    "href": "context.html#footnotes",
    "title": "Provide context",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAll of this information is provided to the LLM as part of the system prompt – a string of text containing instructions and context for the LLM to consider when responding to user queries.↩︎",
    "crumbs": [
      "Overview",
      "Provide context"
    ]
  },
  {
    "objectID": "data-sources.html",
    "href": "data-sources.html",
    "title": "Data Sources",
    "section": "",
    "text": "querychat supports several different data sources, including:\nThe sections below describe how to use each type of data source with querychat.",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#data-frames",
    "href": "data-sources.html#data-frames",
    "title": "Data Sources",
    "section": "Data frames",
    "text": "Data frames\nYou can use any narwhals-compatible data frame as a data source in querychat. This includes popular data frame libraries like pandas, polars, pyarrow, and many more.\n\nPandasPolarsPyarrow\n\n\n\n\npandas-app.py\n\nimport pandas as pd\nfrom querychat import QueryChat\n\nmtcars = pd.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n)\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\n\npolars-app.py\n\nimport polars as pl\nfrom querychat import QueryChat\n\nmtcars = pl.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n)\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\n\npyarrow-app.py\n\nimport pyarrow as pa\nimport pyarrow.csv as pv\nfrom querychat import QueryChat\n\nmtcars = pv.read_csv(\n    \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n).to_table()\n\nqc = QueryChat(mtcars, \"mtcars\")\napp = qc.app()\n\n\n\n\nIf you’re building an app, note you can read the queried data frame reactively using the df() method, which returns a pandas.DataFrame by default.",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#databases",
    "href": "data-sources.html#databases",
    "title": "Data Sources",
    "section": "Databases",
    "text": "Databases\nYou can also connect querychat directly to a table in any database supported by SQLAlchemy. This includes popular databases like SQLite, DuckDB, PostgreSQL, MySQL, and many more.\nAssuming you have a database set up and accessible, you can pass a SQLAlchemy database URL to create_engine(), and then pass the resulting engine to querychat. Below are some examples for common databases.\n\nDuck DBSQLitePostgreSQLMySQL\n\n\npip install duckdb duckdb-engine\n\n\nduckdb-app.py\n\nfrom pathlib import Path\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\n# Assumes my_database.duckdb is in the same directory as this script\ndb_path = Path(__file__).parent / \"my_database.duckdb\"\nengine = create_engine(f\"duckdb:///{db_path}\")\n\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\n\n\nsqlite-app.py\n\nfrom pathlib import Path\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\n# Assumes my_database.db is in the same directory as this script\ndb_path = Path(__file__).parent / \"my_database.db\"\nengine = create_engine(f\"sqlite:///{db_path}\")\n\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\npip install psycopg2-binary\n\n\npostgresql-app.py\n\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\nengine = create_engine(\"postgresql+psycopg2://user:password@localhost:5432/mydatabase\")\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\npip install pymysql\n\n\nmysql-app.py\n\nfrom sqlalchemy import create_engine\nfrom querychat import QueryChat\n\nengine = create_engine(\"mysql+pymysql://user:password@localhost:3306/mydatabase\")\nqc = QueryChat(engine, \"my_table\")\napp = qc.app()\n\n\n\n\nIf you don’t have a database set up, you can easily create a local DuckDB database from a CSV file using the following code:\n\n\ncreate-duckdb.py\n\nimport duckdb\n\nconn = duckdb.connect(\"my_database.duckdb\")\n\nconn.execute(\"\"\"\n    CREATE TABLE my_table AS\n    SELECT * FROM read_csv_auto('path/to/your/file.csv')\n\"\"\")\n\nOr, if you have a pandas DataFrame, you can create the DuckDB database like so:\n\n\ncreate-duckdb-from-pandas.py\n\nimport duckdb\nimport pandas as pd\nfrom querychat.data import titanic\n\nconn = duckdb.connect(\"my_database.duckdb\")\nconn.register('titanic_df', titanic())\nconn.execute(\"\"\"\n    CREATE TABLE titanic AS\n    SELECT * FROM titanic_df\n\"\"\")\n\nThen you can connect to this database using the DuckDB example above (changing the table name as appropriate):",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "data-sources.html#custom-sources",
    "href": "data-sources.html#custom-sources",
    "title": "Data Sources",
    "section": "Custom sources",
    "text": "Custom sources\nIf you have a custom data source that doesn’t fit into the above categories, you can implement the DataSource interface/protocol. This requires implementing methods for getting schema information and executing queries.",
    "crumbs": [
      "Overview",
      "Data Sources"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html",
    "href": "reference/tools.tool_update_dashboard.html",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "tool_update_dashboard(data_source, update_fn)\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\nupdate_fn\nCallable[[UpdateDashboardData], None]\nCallback function to call with UpdateDashboardData when update succeeds\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html#parameters",
    "href": "reference/tools.tool_update_dashboard.html#parameters",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\nupdate_fn\nCallable[[UpdateDashboardData], None]\nCallback function to call with UpdateDashboardData when update succeeds\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_update_dashboard.html#returns",
    "href": "reference/tools.tool_update_dashboard.html#returns",
    "title": "tools.tool_update_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_update_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html",
    "href": "reference/tools.tool_reset_dashboard.html",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "tool_reset_dashboard(reset_fn)\nCreate a tool that resets the dashboard to show all data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nreset_fn\nCallable[[], None]\nCallback function to call when reset is invoked\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html#parameters",
    "href": "reference/tools.tool_reset_dashboard.html#parameters",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nreset_fn\nCallable[[], None]\nCallback function to call when reset is invoked\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_reset_dashboard.html#returns",
    "href": "reference/tools.tool_reset_dashboard.html#returns",
    "title": "tools.tool_reset_dashboard",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_reset_dashboard"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html",
    "href": "reference/tools.tool_query.html",
    "title": "tools.tool_query",
    "section": "",
    "text": "tool_query(data_source)\nCreate a tool that performs a SQL query on the data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html#parameters",
    "href": "reference/tools.tool_query.html#parameters",
    "title": "tools.tool_query",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nDataSource\nThe data source to query against\nrequired",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/tools.tool_query.html#returns",
    "href": "reference/tools.tool_query.html#returns",
    "title": "tools.tool_query",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTool\nA tool that can be registered with chatlas",
    "crumbs": [
      "API Reference",
      "Tools",
      "tools.tool_query"
    ]
  },
  {
    "objectID": "reference/QueryChat.html",
    "href": "reference/QueryChat.html",
    "title": "QueryChat",
    "section": "",
    "text": "QueryChat(\n    data_source,\n    table_name,\n    *,\n    id=None,\n    greeting=None,\n    client=None,\n    tools=('update', 'query'),\n    data_description=None,\n    categorical_threshold=20,\n    extra_instructions=None,\n    prompt_template=None,\n)\nCreate a QueryChat instance.\nQueryChat enables natural language interaction with your data through an LLM-powered chat interface. It can be used in Shiny applications, as a standalone chat client, or in an interactive console.\n\n\nBasic Shiny app:\nfrom querychat import QueryChat\n\nqc = QueryChat(my_dataframe, \"my_data\")\nqc.app()\nStandalone chat client:\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Get a chat client with all tools\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Start an interactive console chat\nqc.console()\nPrivacy-focused mode: Only allow dashboard filtering, ensuring the LLM can’t see any raw data.\nqc = QueryChat(df, \"my_data\", tools=\"update\")\nqc.app()\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich querychat tools to include in the chat client by default. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to disable all tools Default is (\"update\", \"query\") (both tools enabled). Set to \"update\" to prevent the LLM from accessing data values, only allowing dashboard filtering without answering questions. The tools can be overridden per-client by passing a different tools parameter to the .client() method.\n('update', 'query')\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nserver\nInitialize Shiny server logic.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nQueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nQueryChat.cleanup()\nClean up resources associated with the data source.\nCall this method when you are done using the QueryChat object to close database connections and avoid resource leaks.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nQueryChat.client(tools=MISSING, update_dashboard=None, reset_dashboard=None)\nCreate a chat client with registered tools.\nThis method creates a standalone chat client configured with the specified tools and callbacks. Each call returns an independent client instance with its own conversation state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), uses the tools specified during initialization\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nOptional callback function to call when the update_dashboard tool succeeds. Takes a dict with \"query\" and \"title\" keys. Only used if \"update\" is in tools.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nOptional callback function to call when the tool_reset_dashboard is invoked. Takes no arguments. Only used if \"update\" is in tools.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client with tools registered based on the tools parameter.\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3]})\nqc = QueryChat(df, \"my_data\")\n\n# Create client with all tools (default)\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Create client with only query tool (single string)\nclient = qc.client(tools=\"query\")\n\n# Create client with only query tool (tuple)\nclient = qc.client(tools=(\"query\",))\n\n# Create client with custom callbacks\nfrom querychat import UpdateDashboardData\n\n\ndef my_update(data: UpdateDashboardData):\n    print(f\"Query: {data['query']}, Title: {data['title']}\")\n\n\nclient = qc.client(update_dashboard=my_update)\n\n\n\n\nQueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\nThis method provides a REPL (Read-Eval-Print Loop) interface for chatting with your data from the command line. The console session persists by default, so you can exit and return to continue your conversation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nbool\nIf True, creates a new chat client and starts a fresh conversation. If False (default), continues the conversation from the previous console session.\nFalse\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich tools to include: “update”, “query”, or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), defaults to (\"query\",) only for privacy (prevents the LLM from accessing data values) Ignored if new=False and a console session already exists.\n'query'\n\n\n**kwargs\n\nAdditional arguments passed to the client() method when creating a new client.\n{}\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Start console (query tool only by default)\nqc.console()\n\n# Start fresh console with all tools (using tuple)\nqc.console(new=True, tools=(\"update\", \"query\"))\n\n# Start fresh console with all tools (using single string for one tool)\nqc.console(new=True, tools=\"query\")\n\n# Continue previous console session\nqc.console()  # picks up where you left off\n\n\n\n\nQueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nQueryChat.server(enable_bookmarking=False, id=None)\nInitialize Shiny server logic.\nThis method is intended for use in Shiny Code mode, where the user must explicitly call .server() within the Shiny server function. In Shiny Express mode, you can use querychat.express.QueryChat instead of querychat.QueryChat, which calls .server() automatically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenable_bookmarking\nbool\nWhether to enable bookmarking for the querychat module.\nFalse\n\n\nid\nOptional[str]\nOptional module ID for the QueryChat instance. If not provided, will use the ID provided at initialization. This must match the ID used in the .ui() or .sidebar() methods.\nNone\n\n\n\n\n\n\nfrom shiny import App, render, ui\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\n\n\ndef app_ui(request):\n    return ui.page_sidebar(\n        qc.sidebar(),\n        ui.card(\n            ui.card_header(ui.output_text(\"title\")),\n            ui.output_data_frame(\"data_table\"),\n        ),\n        title=\"Titanic QueryChat App\",\n        fillable=True,\n    )\n\n\ndef server(input, output, session):\n    qc_vals = qc.server(enable_bookmarking=True)\n\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"My Data\"\n\n\napp = App(app_ui, server, bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nServerValues\nA ServerValues dataclass containing session-specific reactive values and the chat client. See ServerValues documentation for details on the available attributes.\n\n\n\n\n\n\n\nQueryChat.sidebar(width=400, height='100%', fillable=True, id=None, **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nQueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#examples",
    "href": "reference/QueryChat.html#examples",
    "title": "QueryChat",
    "section": "",
    "text": "Basic Shiny app:\nfrom querychat import QueryChat\n\nqc = QueryChat(my_dataframe, \"my_data\")\nqc.app()\nStandalone chat client:\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Get a chat client with all tools\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Start an interactive console chat\nqc.console()\nPrivacy-focused mode: Only allow dashboard filtering, ensuring the LLM can’t see any raw data.\nqc = QueryChat(df, \"my_data\", tools=\"update\")\nqc.app()",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#parameters",
    "href": "reference/QueryChat.html#parameters",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich querychat tools to include in the chat client by default. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to disable all tools Default is (\"update\", \"query\") (both tools enabled). Set to \"update\" to prevent the LLM from accessing data values, only allowing dashboard filtering without answering questions. The tools can be overridden per-client by passing a different tools parameter to the .client() method.\n('update', 'query')\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#attributes",
    "href": "reference/QueryChat.html#attributes",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/QueryChat.html#methods",
    "href": "reference/QueryChat.html#methods",
    "title": "QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nserver\nInitialize Shiny server logic.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nQueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nQueryChat.cleanup()\nClean up resources associated with the data source.\nCall this method when you are done using the QueryChat object to close database connections and avoid resource leaks.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nQueryChat.client(tools=MISSING, update_dashboard=None, reset_dashboard=None)\nCreate a chat client with registered tools.\nThis method creates a standalone chat client configured with the specified tools and callbacks. Each call returns an independent client instance with its own conversation state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), uses the tools specified during initialization\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nOptional callback function to call when the update_dashboard tool succeeds. Takes a dict with \"query\" and \"title\" keys. Only used if \"update\" is in tools.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nOptional callback function to call when the tool_reset_dashboard is invoked. Takes no arguments. Only used if \"update\" is in tools.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client with tools registered based on the tools parameter.\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3]})\nqc = QueryChat(df, \"my_data\")\n\n# Create client with all tools (default)\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Create client with only query tool (single string)\nclient = qc.client(tools=\"query\")\n\n# Create client with only query tool (tuple)\nclient = qc.client(tools=(\"query\",))\n\n# Create client with custom callbacks\nfrom querychat import UpdateDashboardData\n\n\ndef my_update(data: UpdateDashboardData):\n    print(f\"Query: {data['query']}, Title: {data['title']}\")\n\n\nclient = qc.client(update_dashboard=my_update)\n\n\n\n\nQueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\nThis method provides a REPL (Read-Eval-Print Loop) interface for chatting with your data from the command line. The console session persists by default, so you can exit and return to continue your conversation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nbool\nIf True, creates a new chat client and starts a fresh conversation. If False (default), continues the conversation from the previous console session.\nFalse\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich tools to include: “update”, “query”, or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), defaults to (\"query\",) only for privacy (prevents the LLM from accessing data values) Ignored if new=False and a console session already exists.\n'query'\n\n\n**kwargs\n\nAdditional arguments passed to the client() method when creating a new client.\n{}\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Start console (query tool only by default)\nqc.console()\n\n# Start fresh console with all tools (using tuple)\nqc.console(new=True, tools=(\"update\", \"query\"))\n\n# Start fresh console with all tools (using single string for one tool)\nqc.console(new=True, tools=\"query\")\n\n# Continue previous console session\nqc.console()  # picks up where you left off\n\n\n\n\nQueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nQueryChat.server(enable_bookmarking=False, id=None)\nInitialize Shiny server logic.\nThis method is intended for use in Shiny Code mode, where the user must explicitly call .server() within the Shiny server function. In Shiny Express mode, you can use querychat.express.QueryChat instead of querychat.QueryChat, which calls .server() automatically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenable_bookmarking\nbool\nWhether to enable bookmarking for the querychat module.\nFalse\n\n\nid\nOptional[str]\nOptional module ID for the QueryChat instance. If not provided, will use the ID provided at initialization. This must match the ID used in the .ui() or .sidebar() methods.\nNone\n\n\n\n\n\n\nfrom shiny import App, render, ui\nfrom seaborn import load_dataset\nfrom querychat import QueryChat\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\n\n\ndef app_ui(request):\n    return ui.page_sidebar(\n        qc.sidebar(),\n        ui.card(\n            ui.card_header(ui.output_text(\"title\")),\n            ui.output_data_frame(\"data_table\"),\n        ),\n        title=\"Titanic QueryChat App\",\n        fillable=True,\n    )\n\n\ndef server(input, output, session):\n    qc_vals = qc.server(enable_bookmarking=True)\n\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"My Data\"\n\n\napp = App(app_ui, server, bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nServerValues\nA ServerValues dataclass containing session-specific reactive values and the chat client. See ServerValues documentation for details on the available attributes.\n\n\n\n\n\n\n\nQueryChat.sidebar(width=400, height='100%', fillable=True, id=None, **kwargs)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nQueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "QueryChat"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html",
    "href": "reference/types.DataSource.html",
    "title": "types.DataSource",
    "section": "",
    "text": "DataSource()\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntable_name\nstr\nName of the table to be used in SQL queries.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nName for the database behind the SQL execution.\n\n\nget_schema\nReturn schema information about the table as a string.\n\n\ntest_query\nTest SQL query by fetching only one row.\n\n\n\n\n\ntypes.DataSource.cleanup()\nClean up resources associated with the data source.\nThis method should clean up any connections or resources used by the data source.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataSource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_db_type()\nName for the database behind the SQL execution.\n\n\n\ntypes.DataSource.get_schema(categorical_threshold)\nReturn schema information about the table as a string.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA string containing the schema information in a format suitable for prompting an LLM about the data structure\n\n\n\n\n\n\n\ntypes.DataSource.test_query(query, *, require_all_columns=False)\nTest SQL query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns. Additional computed columns are allowed.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as a pandas DataFrame with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html#attributes",
    "href": "reference/types.DataSource.html#attributes",
    "title": "types.DataSource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntable_name\nstr\nName of the table to be used in SQL queries.",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "reference/types.DataSource.html#methods",
    "href": "reference/types.DataSource.html#methods",
    "title": "types.DataSource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nName for the database behind the SQL execution.\n\n\nget_schema\nReturn schema information about the table as a string.\n\n\ntest_query\nTest SQL query by fetching only one row.\n\n\n\n\n\ntypes.DataSource.cleanup()\nClean up resources associated with the data source.\nThis method should clean up any connections or resources used by the data source.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataSource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataSource.get_db_type()\nName for the database behind the SQL execution.\n\n\n\ntypes.DataSource.get_schema(categorical_threshold)\nReturn schema information about the table as a string.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA string containing the schema information in a format suitable for prompting an LLM about the data structure\n\n\n\n\n\n\n\ntypes.DataSource.test_query(query, *, require_all_columns=False)\nTest SQL query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns. Additional computed columns are allowed.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as a pandas DataFrame with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataSource"
    ]
  },
  {
    "objectID": "build.html",
    "href": "build.html",
    "title": "Build an app",
    "section": "",
    "text": "While the .app() method provides a quick way to start exploring data, building bespoke Shiny apps with querychat unlocks the full power of integrating natural language data exploration with custom visualizations, layouts, and interactivity. This guide shows you how to integrate querychat into your own Shiny applications and leverage its reactive data outputs to create rich, interactive dashboards.\nquerychat is a particularly good fit for Shiny apps that have:\nIn these apps, querychat can replace or augment your filtering UI by allowing users to describe what they want to see in natural language. Instead of building complex filter controls, users can simply ask questions like “show me customers from California who spent over $1000 last quarter” and querychat will generate the appropriate SQL query.\nThis is especially valuable when:\nIf you have an existing app with a reactive data frame that flows through multiple outputs, querychat can be a natural addition to provide an alternative way to filter that data.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#starter-template",
    "href": "build.html#starter-template",
    "title": "Build an app",
    "section": "Starter template",
    "text": "Starter template\nIntegrating querychat into a Shiny app requires just three steps:\n\nInitialize a querychat() instance with your data\nAdd the UI component (either .sidebar() or .ui())\nUse reactive values like .df(), .sql(), and .title() to build outputs that respond to user queries\n\nHere’s a starter template demonstrating these steps:\n\nExpressCore\n\n\nfrom shiny.express import render, ui\nfrom querychat.express import QueryChat\nfrom querychat.data import titanic\n\n# 1. Provide data source to QueryChat\nqc = QueryChat(titanic(), \"titanic\")\n\n# 2. Add sidebar chat control\nqc.sidebar()\n\n# 3. Add a card with reactive title and data frame\nwith ui.card():\n    with ui.card_header():\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n    \n# 4. Set some page options (optional)\nui.page_opts(\n    fillable=True,\n    title=\"Titanic Dataset Explorer\"\n)\n\n\nfrom shiny import App, render, ui\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\n# 1. Provide data source to QueryChat\nqc = QueryChat(titanic(), \"titanic\")\n\napp_ui = ui.page_sidebar(\n    # 2. Create sidebar chat control\n    qc.sidebar(),\n    ui.card(\n        ui.card_header(ui.output_text(\"title\")),\n        ui.output_data_frame(\"data_table\"),\n        fill=True,\n    ),\n    fillable=True\n)\n\n\ndef server(input, output, session):\n    # 3. Add server logic (to get reactive data frame and title)\n    qc_vals = qc.server()\n\n    # 4. Use the filtered/sorted data frame reactively\n    @render.data_frame\n    def data_table():\n        return qc_vals.df()\n\n    @render.text\n    def title():\n        return qc_vals.title() or \"Titanic Dataset\"\n\n\napp = App(app_ui, server)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWith Core, you’ll need to call the qc.server() method within your server function to set up querychat’s reactive behavior, and capture its return value to access reactive data. This is not necessary with Express, which handles it automatically and exposes reactive values directly on the querychat instance.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#reactives",
    "href": "build.html#reactives",
    "title": "Build an app",
    "section": "Reactives",
    "text": "Reactives\nThere are three main reactive values provided by querychat for use in your app:\n\nFiltered data\nThe .df() method returns the current filtered and/or sorted data frame. This updates whenever the user prompts a filtering or sorting operation through the chat interface (see Data updating for details).\n\nExpressCore\n\n\n@render.data_frame\ndef table():\n    return qc.df()  # Returns filtered/sorted data\n\n\nqc_vals = qc.server()\n\n@render.data_frame\ndef table():\n    return qc_vals.df()  # Returns filtered/sorted data\n\n\n\nYou can use .df() to power any output in your app - visualizations, summary statistics, data tables, and more. When a user asks to “show only survivors” or “sort by age”, .df() automatically updates, and any outputs that depend on it will re-render.\n\n\nSQL query\nThe .sql() method returns the current SQL query as a string. This is useful for displaying the query to users for transparency and reproducibility:\n\nExpressCore\n\n\n@render.text\ndef current_query():\n    return qc.sql() or \"SELECT * FROM my_data\"\n\n\nqc_vals = qc.server()\n\n@render.text\ndef current_query():\n    return qc_vals.sql() or \"SELECT * FROM my_data\"\n\n\n\nYou can also use .sql() as a setter to programmatically update the query (see Programmatic filtering below).\n\n\nTitle\nThe .title() method returns a short description of the current filter, provided by the LLM when it generates a query. For example, if a user asks to “show first-class survivors”, the title might be “First-class survivors”.\n\nExpress\n\n\n@render.text\ndef card_title():\n    return qc.title() or \"All Data\"\n\nCore\nqc_vals = qc.server()\n\n@render.text\ndef card_title():\n    return qc_vals.title() or \"All Data\"\n\n\n\n\nReturns None when no filter is active. You can also use .title() as a setter to update the title programmatically.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#custom-ui",
    "href": "build.html#custom-ui",
    "title": "Build an app",
    "section": "Custom UI",
    "text": "Custom UI\nIn the starter template above, we used the .sidebar() method for a simple sidebar layout. In some cases, you might want to place the chat UI somewhere else in your app layout, or just more fully customize what goes in the sidebar. The .ui() method is designed for this – it returns the chat component without additional layout wrappers.\nFor example here is how to place the chat in a sidebar with some additional controls:\n\nExpressCore\n\n\nfrom shiny.express import ui, reactive\nfrom querychat.express import QueryChat\n\nqc = QueryChat(data, \"my_data\")\n\nwith ui.sidebar():\n    qc.ui()  # Chat component\n    ui.hr()\n    ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\")\n\n\nfrom shiny import ui, reactive\nfrom querychat import QueryChat\n\nqc = QueryChat(data, \"my_data\")\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        qc.ui(),  # Chat component\n        ui.hr(),\n        ui.input_action_button(\"reset\", \"Reset Filters\", class_=\"w-100\"),\n    ),\n    # Main content here\n)\n\n\n\n\n\n\n\n\n\nCustom Shiny chat UIs\n\n\n\nLearn more about customizing Shiny chat UIs in the Shiny Chat documentation.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#data-views",
    "href": "build.html#data-views",
    "title": "Build an app",
    "section": "Data views",
    "text": "Data views\nThanks to Shiny’s support for Jupyter Widgets like Plotly, it’s straightforward to create rich data views that depend on querychat data. Here’s an example of an app showing both the filtered data and a bar chart depending on that same data:\nimport plotly.express as px\n\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\n\nfrom querychat.express import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.sidebar()\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Data Table\")\n\n        @render.data_frame\n        def table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render_plotly\n        def survival_plot():\n            d = qc.df()\n            summary = d.groupby('pclass')['survived'].mean().reset_index()\n            return px.bar(summary, x='pclass', y='survived')\nNow when a user filters the data through natural language (e.g., “filter to only children”), both the table and the chart update automatically.\n\nA more useful, but slightly more involved example like the one below might incorporate other Shiny components like value boxes to summarize key statistics about the filtered data.\n\n\ntitanic-dashboard.py\n\nimport plotly.express as px\nfrom faicons import icon_svg\nfrom querychat.data import titanic\nfrom querychat.express import QueryChat\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\n\nqc = QueryChat(titanic(), \"titanic\")\nqc.sidebar()\n\nwith ui.layout_column_wrap(fill=False):\n    with ui.value_box(showcase=icon_svg(\"users\")):\n        \"Passengers\"\n\n        @render.text\n        def count():\n            return str(len(qc.df()))\n\n    with ui.value_box(showcase=icon_svg(\"heart\")):\n        \"Survival Rate\"\n\n        @render.text\n        def survival():\n            rate = qc.df()[\"survived\"].mean() * 100\n            return f\"{rate:.1f}%\"\n\n    with ui.value_box(showcase=icon_svg(\"coins\")):\n        \"Avg Fare\"\n\n        @render.text\n        def fare():\n            avg = qc.df()[\"fare\"].mean()\n            return f\"${avg:.2f}\"\n\n\nwith ui.layout_columns():\n    with ui.card():\n        with ui.card_header():\n            \"Data Table\"\n\n            @render.text\n            def table_title():\n                return f\" - {qc.title()}\" if qc.title() else \"\"\n\n        @render.data_frame\n        def data_table():\n            return qc.df()\n\n    with ui.card():\n        ui.card_header(\"Survival by Class\")\n\n        @render_plotly\n        def survival_by_class():\n            df = qc.df()\n            summary = df.groupby(\"pclass\")[\"survived\"].mean().reset_index()\n            return px.bar(\n                summary,\n                x=\"pclass\",\n                y=\"survived\",\n                labels={\"pclass\": \"Class\", \"survived\": \"Survival Rate\"},\n            )\n\n\nwith ui.layout_columns():\n    with ui.card():\n        ui.card_header(\"Age Distribution\")\n\n        @render_plotly\n        def age_dist():\n            df = qc.df()\n            return px.histogram(df, x=\"age\", nbins=30)\n\n    with ui.card():\n        ui.card_header(\"Fare by Class\")\n\n        @render_plotly\n        def fare_by_class():\n            df = qc.df()\n            return px.box(df, x=\"pclass\", y=\"fare\", color=\"survived\")\n\n\nui.page_opts(\n    title=\"Titanic Survival Analysis\",\n    fillable=True,\n    class_=\"bslib-page-dashboard\",\n)",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#programmatic-updates",
    "href": "build.html#programmatic-updates",
    "title": "Build an app",
    "section": "Programmatic updates",
    "text": "Programmatic updates\nquerychat’s reactive state can be updated programmatically. For example, you might want to add a “Reset Filters” button that clears any active filters and returns the data table to its original state. You can do this by setting both the SQL query and title to their default values. This way you don’t have to rely on both the user and LLM to send the right prompt.\n\nExpressCore\n\n\nui.input_action_button(\"reset\", \"Reset Filters\")\n\n@reactive.effect\n@reactive.event(input.reset)\ndef _():\n    qc.sql(\"\")\n    qc.title(None)\n\n\nui.input_action_button(\"reset\", \"Reset Filters\")\n\nqc_vals = qc.server()\n\n@reactive.effect\n@reactive.event(input.reset)\ndef _():\n    qc_vals.sql.set(\"\")\n    qc_vals.title.set(None)\n\n\n\nThis is equivalent to the user asking the LLM to “reset” or “show all data”.",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#multiple-tables",
    "href": "build.html#multiple-tables",
    "title": "Build an app",
    "section": "Multiple tables",
    "text": "Multiple tables\nCurrently, you have two options for exploring multiple tables in querychat:\n\nJoin the tables into a single table before passing to querychat\nUse multiple querychat instances in the same app\n\nThe first option makes it possible to chat with multiple tables inside a single chat interface, whereas the second option requires a separate chat interface for each table.\n\n\n\n\n\n\nMultiple filtered tables\n\n\n\nWe plan to support multiple filtered tables in a future release – if you’re interested in this feature, please upvote the relevant issue\n\n\nHere’s an example of the second approach, using two separate querychat instances to explore both the titanic and penguins datasets within the same app:\n\n\nmultiple-datasets.py\n\nfrom querychat.data import titanic\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import render, ui\n\npenguins = load_dataset(\"penguins\")\n\nqc_titanic = QueryChat(titanic(), \"titanic\")\nqc_penguins = QueryChat(penguins, \"penguins\")\n\nwith ui.sidebar():\n    with ui.panel_conditional(\"input.navbar == 'Titanic'\"):\n        qc_titanic.ui()\n    with ui.panel_conditional(\"input.navbar == 'Penguins'\"):\n        qc_penguins.ui()\n\nwith ui.nav_panel(\"Titanic\"):\n\n    @render.data_frame\n    def titanic_table():\n        return qc_titanic.df()\n\n\nwith ui.nav_panel(\"Penguins\"):\n\n    @render.data_frame\n    def penguins_table():\n        return qc_penguins.df()\n\n\nui.page_opts(\n    id=\"navbar\",\n    title=\"Multiple Datasets with querychat\",\n    fillable=True,\n)",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "build.html#see-also",
    "href": "build.html#see-also",
    "title": "Build an app",
    "section": "See also",
    "text": "See also\n\nGreet users - Create welcoming onboarding experiences\nProvide context - Help the LLM understand your data better\nTools - Understand what querychat can do under the hood",
    "crumbs": [
      "Overview",
      "Build an app"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Explore data using natural language queries\nquerychat facilitates safe and reliable natural language exploration of tabular data, powered by SQL and large language models (LLMs). For users, it offers an intuitive web application where they can quickly ask questions of their data and receive verifiable data-driven answers. As a developer, you can access the chat UI component, generated SQL queries, and filtered data to build custom applications that integrate natural language querying into your data workflows.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Introduction",
    "section": "Installation",
    "text": "Installation\nInstall the latest stable release from PyPI:\npip install querychat",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Introduction",
    "section": "Quick start",
    "text": "Quick start\nThe main entry point is the QueryChat class. It requires a data source (e.g., pandas, polars, etc) and a name for the data. It also accepts optional parameters to customize the behavior, such as the client model. The quickest way to start chatting is to call the .app() method, which returns a Shiny app object.\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\n\nWith an API key set1, you can run that code in a Python console and then call app.run() to jump into a chat. Or you can save the code to titanic-app.py and run the app from a terminal (or Positron, or VS Code):\n# Optionally, change the default model:\nexport QUERYCHAT_CLIENT=\"anthropic/claude-sonnet-4-5\"\n# And provide appropriate credentials for your chosen model provider\nexport ANTHROPIC_API_KEY=\"your_api_key_here\"\nshiny run --reload titanic-app.py\nOnce running, you’ll notice 3 main views:\n\nA sidebar chat with suggestions on where to start exploring.\nA data table that updates to reflect filtering and sorting queries.\nThe SQL query behind the data table, for transparency and reproducibility.\n\n\nSuppose we pick a suggestion like “Show me passengers who survived”. Since this is a filtering operation, both the data table and SQL query update accordingly.\n\nquerychat can also handle more general questions about the data that require calculations and aggregations. For example, we can ask “What is the average age of passengers who survived?”. The LLM will generate the SQL query to perform the calculation, querychat will execute it, and return the result in the chat:",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#custom-apps",
    "href": "index.html#custom-apps",
    "title": "Introduction",
    "section": "Custom apps",
    "text": "Custom apps\nquerychat is designed to be highly extensible – it provides programmatic access to the chat interface, the filtered/sorted data frame, SQL queries, and more. This makes it easy to build custom web apps that leverage natural language interaction with your data. For example, here’s a bespoke app for exploring Airbnb listings in Ashville, NC:\n\nTo learn more, see Build an app for a step-by-step guide.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "Introduction",
    "section": "How it works",
    "text": "How it works\nquerychat uses LLMs to translate natural language into SQL queries. Models of all sizes, from small ones you can run locally to large frontier models from major AI providers, are remarkably effective at this task. But even the best models need to understand your data’s overall structure to perform well.\nTo address this, querychat includes schema metadata – column names, types, ranges, categorical values – in the LLM’s system prompt. Importantly, querychat does not send raw data to the LLM; it shares only enough structural information for the model to generate accurate queries. When the LLM produces a query, querychat executes it in a SQL database (DuckDB2, by default) to obtain precise results.\nThis design makes querychat reliable, safe, and reproducible:\n\nReliable: query results come from a real database, not LLM-generated summaries – so outputs are precise, verifiable, and less vulnerable to hallucination3.\nSafe: querychat’s tools are read-only by design, avoiding destructive actions on your data.4\nReproducible: generated SQL can be exported and re-run in other environments, so your analysis isn’t locked into a single tool.\n\n\n\n\n\n\n\nImportant\n\n\n\nData privacy\nSee the Provide context and Tools articles for more details on exactly what information is provided to the LLM and how customize it.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#next-steps",
    "href": "index.html#next-steps",
    "title": "Introduction",
    "section": "Next steps",
    "text": "Next steps\nFrom here, you might want to learn more about:\n\nModels: customize the LLM behind querychat.\nData sources: different data sources you can use with querychat.\nProvide context: provide the LLM with the context it needs to work well.\nBuild an app: design a custom Shiny app around querychat.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Introduction",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBy default, querychat uses OpenAI to power the chat experience. So, for this example to work, you’ll need an OpenAI API key. See the Models page for details on how to set up credentials for other model providers.↩︎\nDuckDB is extremely fast and has a surprising number of statistical functions.↩︎\nThe query tool gives query results to the model for context and interpretation. Thus, there is some potential that the model to mis-interpret those results.↩︎\nTo fully guarantee no destructive actions on your production database, ensure querychat’s database permissions are read-only.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Changelog",
    "section": "",
    "text": "All notable changes to this project will be documented in this file.\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.\n\n\n\n\n\nQueryChat.sidebar(), QueryChat.ui(), and QueryChat.server() now support an optional id parameter to create multiple chat instances from a single QueryChat object. (#172)\nQueryChat.client() can now create standalone querychat-enabled chat clients with configurable tools and callbacks, enabling use outside of Shiny applications. (#168)\nQueryChat.console() was added to launch interactive console-based chat sessions with your data source, with persistent conversation state across invocations. (#168)\nThe tools used in a QueryChat chatbot are now configurable. Use the new tools parameter of QueryChat() to select either or both \"query\" or \"update\" tools. Choose tools=[\"update\"] if you only want QueryChat to be able to update the dashboard (useful when you want to be 100% certain that the LLM will not see any raw data). (#168)\n\n\n\n\n\nThe update tool now requires that the SQL query returns all columns from the original data source, ensuring that the dashboard can display the complete data frame after filtering or sorting. If the query does not return all columns, an informative error message will be provided. (#180)\nObvious SQL keywords that lead to data modification (e.g., INSERT, UPDATE, DELETE, DROP, etc.) are now prohibited in queries run via the query tool or update tool, to prevent accidental data changes. If such keywords are detected, an informative error message will be provided. (#180)\n\n\n\n\n\n\n\n\nThe entire functional API (i.e., init(), sidebar(), server(), etc) has been hard deprecated in favor of a simpler OOP-based API. Namely, the new QueryChat() class is now the main entry point (instead of init()) and has methods to replace old functions (e.g., .sidebar(), .server(), etc). (#101)\nThe .sql() method now returns None instead of \"\" (empty string) when no query has been set, aligning with the behavior of .title() for consistency. Most code using the or operator or req() for falsy checks will continue working without changes. Code that explicitly checks sql() == \"\" should be updated to use falsy checks (if not sql()) or explicit null checks (if sql() is None). (#146)\n\n\n\n\n\nNew QueryChat.app() method enables quicker/easier chatting with a dataset. (#104)\nEnabled bookmarking by default in both .app() and .server() methods. In latter case, you’ll need to also specify the bookmark_store (either in shiny.App() or shiny.express.app_opts()) for it to take effect. (#104)\nThe current SQL query and title can now be programmatically set through the .sql() and .title() methods of QueryChat(). (#98, #101)\nNew querychat.data module provides sample datasets (titanic() and tips()) to make it easier to get started without external dependencies. (#118)\nAdded a .generate_greeting() method to help you create a greeting message for your querychat bot. (#87)\nAdded querychat_reset_dashboard() tool for easily resetting the dashboard filters when asked by the user. (#81)\n\n\n\n\n\nAdded rich tool UI support using shinychat development version and chatlas &gt;= 0.11.1. (#67)\nquerychat’s system prompt and tool descriptions were rewritten for clarity and future extensibility. (#90)\nTool detail cards can now be expanded or collapsed by default when querychat runs a query or updates the dashboard via the QUERYCHAT_TOOL_DETAILS environment variable. Valid values are \"expanded\", \"collapsed\", or \"default\". (#137)\n\n\n\n\n\n\nFixed another issue with data sources that aren’t already narwhals DataFrames (#83)\n\n\n\n\n\nFixed an issue with the query tool when used with SQLAlchemy data sources. (@npelikan #79)\n\n\n\n\n\nquerychat.init() now accepts a client argument, replacing the previous create_chat_callback argument. (#60)\nThe client can be:\n\na chatlas.Chat object,\na function that returns a chatlas.Chat object,\nor a provider-model string, e.g. \"openai/gpt-4.1\", to be passed to chatlas.ChatAuto().\n\nIf client is not provided, querychat will use the QUERYCHAT_CLIENT environment variable, which should be a provider-model string. If the envvar is not set, querychat uses OpenAI with the default model from chatlas.ChatOpenAI().\nquerychat.ui() now adds a .querychat class to the chat container and querychat.sidebar() adds a .querychat-sidebar class to the sidebar, allowing for easier customization via CSS. (#68)\n\n\n\n\nThis first release of the querychat package."
  },
  {
    "objectID": "CHANGELOG.html#unreleased",
    "href": "CHANGELOG.html#unreleased",
    "title": "Changelog",
    "section": "",
    "text": "QueryChat.sidebar(), QueryChat.ui(), and QueryChat.server() now support an optional id parameter to create multiple chat instances from a single QueryChat object. (#172)\nQueryChat.client() can now create standalone querychat-enabled chat clients with configurable tools and callbacks, enabling use outside of Shiny applications. (#168)\nQueryChat.console() was added to launch interactive console-based chat sessions with your data source, with persistent conversation state across invocations. (#168)\nThe tools used in a QueryChat chatbot are now configurable. Use the new tools parameter of QueryChat() to select either or both \"query\" or \"update\" tools. Choose tools=[\"update\"] if you only want QueryChat to be able to update the dashboard (useful when you want to be 100% certain that the LLM will not see any raw data). (#168)\n\n\n\n\n\nThe update tool now requires that the SQL query returns all columns from the original data source, ensuring that the dashboard can display the complete data frame after filtering or sorting. If the query does not return all columns, an informative error message will be provided. (#180)\nObvious SQL keywords that lead to data modification (e.g., INSERT, UPDATE, DELETE, DROP, etc.) are now prohibited in queries run via the query tool or update tool, to prevent accidental data changes. If such keywords are detected, an informative error message will be provided. (#180)"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "Changelog",
    "section": "",
    "text": "The entire functional API (i.e., init(), sidebar(), server(), etc) has been hard deprecated in favor of a simpler OOP-based API. Namely, the new QueryChat() class is now the main entry point (instead of init()) and has methods to replace old functions (e.g., .sidebar(), .server(), etc). (#101)\nThe .sql() method now returns None instead of \"\" (empty string) when no query has been set, aligning with the behavior of .title() for consistency. Most code using the or operator or req() for falsy checks will continue working without changes. Code that explicitly checks sql() == \"\" should be updated to use falsy checks (if not sql()) or explicit null checks (if sql() is None). (#146)\n\n\n\n\n\nNew QueryChat.app() method enables quicker/easier chatting with a dataset. (#104)\nEnabled bookmarking by default in both .app() and .server() methods. In latter case, you’ll need to also specify the bookmark_store (either in shiny.App() or shiny.express.app_opts()) for it to take effect. (#104)\nThe current SQL query and title can now be programmatically set through the .sql() and .title() methods of QueryChat(). (#98, #101)\nNew querychat.data module provides sample datasets (titanic() and tips()) to make it easier to get started without external dependencies. (#118)\nAdded a .generate_greeting() method to help you create a greeting message for your querychat bot. (#87)\nAdded querychat_reset_dashboard() tool for easily resetting the dashboard filters when asked by the user. (#81)\n\n\n\n\n\nAdded rich tool UI support using shinychat development version and chatlas &gt;= 0.11.1. (#67)\nquerychat’s system prompt and tool descriptions were rewritten for clarity and future extensibility. (#90)\nTool detail cards can now be expanded or collapsed by default when querychat runs a query or updates the dashboard via the QUERYCHAT_TOOL_DETAILS environment variable. Valid values are \"expanded\", \"collapsed\", or \"default\". (#137)"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "Changelog",
    "section": "",
    "text": "Fixed another issue with data sources that aren’t already narwhals DataFrames (#83)"
  },
  {
    "objectID": "CHANGELOG.html#section-2",
    "href": "CHANGELOG.html#section-2",
    "title": "Changelog",
    "section": "",
    "text": "Fixed an issue with the query tool when used with SQLAlchemy data sources. (@npelikan #79)"
  },
  {
    "objectID": "CHANGELOG.html#section-3",
    "href": "CHANGELOG.html#section-3",
    "title": "Changelog",
    "section": "",
    "text": "querychat.init() now accepts a client argument, replacing the previous create_chat_callback argument. (#60)\nThe client can be:\n\na chatlas.Chat object,\na function that returns a chatlas.Chat object,\nor a provider-model string, e.g. \"openai/gpt-4.1\", to be passed to chatlas.ChatAuto().\n\nIf client is not provided, querychat will use the QUERYCHAT_CLIENT environment variable, which should be a provider-model string. If the envvar is not set, querychat uses OpenAI with the default model from chatlas.ChatOpenAI().\nquerychat.ui() now adds a .querychat class to the chat container and querychat.sidebar() adds a .querychat-sidebar class to the sidebar, allowing for easier customization via CSS. (#68)"
  },
  {
    "objectID": "CHANGELOG.html#section-4",
    "href": "CHANGELOG.html#section-4",
    "title": "Changelog",
    "section": "",
    "text": "This first release of the querychat package."
  },
  {
    "objectID": "models.html",
    "href": "models.html",
    "title": "Models",
    "section": "",
    "text": "Under the hood, querychat is powered by chatlas, a library for building chat-based applications with large language models (LLMs). chatlas supports a wide range of LLM providers – see here for a full list.\n\nSpecify a model\nTo use a particular model, pass a \"{provider}/{model}\" string to the client parameter, which gets passed along to chatlas.ChatAuto\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(\n    titanic(),\n    \"titanic\",\n    client=\"anthropic/claude-sonnet-4-5\"\n)\nAnd, if you’d like to effectively set a new default model, you can use the QUERYCHAT_CLIENT environment variable.\nexport QUERYCHAT_CLIENT=\"anthropic/claude-sonnet-4-5\"\nNote that it can also be useful to pass a full Chat object to the client parameter for more advanced use cases (e.g., custom parameters, tools, etc). It can also be useful for getting some helpful autocomplete of available models.\nfrom chatlas import ChatAnthropic\n\nclient = ChatAnthropic(model=\"claude-sonnet-4-5\")\n\n\nCredentials\nMost models require an API key or some other form of authentication. See the reference page for the relevant model provider (e.g., ChatAnthropic) to learn more on how to set up credentials.\n\n\n\n\n\n\nGithub model marketplace\n\n\n\nIf you are already setup with Github credentials, Github model marketplace provides a free and easy way to get started. See here for more details on how to get setup.\n\n\ngithub-model.py\n\nfrom chatlas import ChatGithub\n\n# Just works if GITHUB_TOKEN is set in your environment\nclient = ChatGithub(model=\"gpt-4.1\")\n\n\n\nIn general, most providers will prefer credentials stored as environment variables, and common practice is to use a .env file to manage these variables. For example, for ChatOpenAI(), you might create a .env file like so:\n\n\n.env\n\nOPENAI_API_KEY=\"your_api_key_here\"\n\nThen, load the environment variables via the dotenv package:\npip install dotenv\nfrom dotenv import load_dotenv\nload_dotenv()\n\n\nRecommended models\nIn theory, you could use any model that has tool calling support, but we currently recommend (as of November 2025):\n\nGPT-4.1 (the default)\nClaude 4.5 Sonnet\nGoogle Gemini 3.0\n\nIn our testing, we’ve found that those models strike a good balance between accuracy and latency. That said, smaller/faster models like GPT-4.1-mini or Claude Haiku 4.5 work well for most tables and are worth trying first—they’re significantly cheaper and faster. You can always switch to a larger model if you find the results aren’t meeting your needs. On the other end of the spectrum, reasoning models like o3-mini tend to slow down responses without providing meaningfully better results for this task.\nWe’ve also seen some decent results with frontier local models (e.g., gpt-oss:20b), but even if you have the compute to run the largest models, they still tend to lag behind the cloud-hosted options in terms of accuracy and speed.\n\n\n\n\n\n\nData privacy concerns?\n\n\n\nIf you have data privacy concerns, consider that your org may provide access to private instances of these models with data residency guarantees. For example, Azure, AWS Bedrock, and Google Vertex AI all provide private instances of popular LLMs. You can interface with these enterprise providers by passing the right string (e.g., \"bedrock-anthropic\") or Chat object (e.g., ChatBedrockAnthropic()) to the client parameter. See the chatlas docs for more details.",
    "crumbs": [
      "Overview",
      "Models"
    ]
  },
  {
    "objectID": "reference/types.SQLAlchemySource.html",
    "href": "reference/types.SQLAlchemySource.html",
    "title": "types.SQLAlchemySource",
    "section": "",
    "text": "SQLAlchemySource(engine, table_name)\nA DataSource implementation that supports multiple SQL databases via SQLAlchemy.\nSupports various databases including PostgreSQL, MySQL, SQLite, Snowflake, and Databricks.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nDispose of the SQLAlchemy engine.\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from database table.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.SQLAlchemySource.cleanup()\nDispose of the SQLAlchemy engine.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_db_type()\nGet the database type.\nReturns the specific database type (e.g., POSTGRESQL, MYSQL, SQLITE) by inspecting the SQLAlchemy engine. Removes ” SQL” suffix if present.\n\n\n\ntypes.SQLAlchemySource.get_schema(categorical_threshold)\nGenerate schema information from database table.\nReturns: String describing the schema\n\n\n\ntypes.SQLAlchemySource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.SQLAlchemySource"
    ]
  },
  {
    "objectID": "reference/types.SQLAlchemySource.html#methods",
    "href": "reference/types.SQLAlchemySource.html#methods",
    "title": "types.SQLAlchemySource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nDispose of the SQLAlchemy engine.\n\n\nexecute_query\nExecute SQL query and return results as DataFrame.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from database table.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.SQLAlchemySource.cleanup()\nDispose of the SQLAlchemy engine.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.execute_query(query)\nExecute SQL query and return results as DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.SQLAlchemySource.get_db_type()\nGet the database type.\nReturns the specific database type (e.g., POSTGRESQL, MYSQL, SQLITE) by inspecting the SQLAlchemy engine. Removes ” SQL” suffix if present.\n\n\n\ntypes.SQLAlchemySource.get_schema(categorical_threshold)\nGenerate schema information from database table.\nReturns: String describing the schema\n\n\n\ntypes.SQLAlchemySource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.SQLAlchemySource"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "The starting point for any QueryChat session\n\n\n\nQueryChat\nCreate a QueryChat instance.\n\n\nexpress.QueryChat\nUse QueryChat with Shiny Express.\n\n\n\n\n\n\nSession-specific reactive values representing the current query\n\n\n\ntypes.ServerValues\nSession-specific reactive values and client returned by QueryChat.server().\n\n\n\n\n\n\nThe underlying logic for managing data sources\n\n\n\ntypes.DataSource\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\ntypes.DataFrameSource\nA DataSource implementation that wraps a pandas DataFrame using DuckDB.\n\n\ntypes.SQLAlchemySource\nA DataSource implementation that supports multiple SQL databases via\n\n\n\n\n\n\nThe underlying tools provided to the LLM\n\n\n\ntools.tool_query\nCreate a tool that performs a SQL query on the data.\n\n\ntools.tool_update_dashboard\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\ntools.tool_reset_dashboard\nCreate a tool that resets the dashboard to show all data.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#the-querychat-class",
    "href": "reference/index.html#the-querychat-class",
    "title": "Function reference",
    "section": "",
    "text": "The starting point for any QueryChat session\n\n\n\nQueryChat\nCreate a QueryChat instance.\n\n\nexpress.QueryChat\nUse QueryChat with Shiny Express.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reactive-values",
    "href": "reference/index.html#reactive-values",
    "title": "Function reference",
    "section": "",
    "text": "Session-specific reactive values representing the current query\n\n\n\ntypes.ServerValues\nSession-specific reactive values and client returned by QueryChat.server().",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#data-sources",
    "href": "reference/index.html#data-sources",
    "title": "Function reference",
    "section": "",
    "text": "The underlying logic for managing data sources\n\n\n\ntypes.DataSource\nAn abstract class defining the interface for data sources used by QueryChat.\n\n\ntypes.DataFrameSource\nA DataSource implementation that wraps a pandas DataFrame using DuckDB.\n\n\ntypes.SQLAlchemySource\nA DataSource implementation that supports multiple SQL databases via",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#tools",
    "href": "reference/index.html#tools",
    "title": "Function reference",
    "section": "",
    "text": "The underlying tools provided to the LLM\n\n\n\ntools.tool_query\nCreate a tool that performs a SQL query on the data.\n\n\ntools.tool_update_dashboard\nCreate a tool that modifies the data presented in the dashboard based on the SQL query.\n\n\ntools.tool_reset_dashboard\nCreate a tool that resets the dashboard to show all data.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/types.DataFrameSource.html",
    "href": "reference/types.DataFrameSource.html",
    "title": "types.DataFrameSource",
    "section": "",
    "text": "DataFrameSource(df, table_name)\nA DataSource implementation that wraps a pandas DataFrame using DuckDB.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nClose the DuckDB connection.\n\n\nexecute_query\nExecute query using DuckDB.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from DataFrame.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.DataFrameSource.cleanup()\nClose the DuckDB connection.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataFrameSource.execute_query(query)\nExecute query using DuckDB.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_db_type()\nGet the database type.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe string “DuckDB”\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_schema(categorical_threshold)\nGenerate schema information from DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema\n\n\n\n\n\n\n\ntypes.DataFrameSource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataFrameSource"
    ]
  },
  {
    "objectID": "reference/types.DataFrameSource.html#methods",
    "href": "reference/types.DataFrameSource.html#methods",
    "title": "types.DataFrameSource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nClose the DuckDB connection.\n\n\nexecute_query\nExecute query using DuckDB.\n\n\nget_data\nReturn the unfiltered data as a DataFrame.\n\n\nget_db_type\nGet the database type.\n\n\nget_schema\nGenerate schema information from DataFrame.\n\n\ntest_query\nTest query by fetching only one row.\n\n\n\n\n\ntypes.DataFrameSource.cleanup()\nClose the DuckDB connection.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\ntypes.DataFrameSource.execute_query(query)\nExecute query using DuckDB.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to execute\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results as pandas DataFrame\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_data()\nReturn the unfiltered data as a DataFrame.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe complete dataset as a pandas DataFrame\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_db_type()\nGet the database type.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe string “DuckDB”\n\n\n\n\n\n\n\ntypes.DataFrameSource.get_schema(categorical_threshold)\nGenerate schema information from DataFrame.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategorical_threshold\nint\nMaximum number of unique values for a text column to be considered categorical\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nString describing the schema\n\n\n\n\n\n\n\ntypes.DataFrameSource.test_query(query, *, require_all_columns=False)\nTest query by fetching only one row.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL query to test\nrequired\n\n\nrequire_all_columns\nbool\nIf True, validates that result includes all original table columns\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nQuery results with at most one row\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnsafeQueryError\nIf the query starts with a disallowed SQL operation\n\n\n\nMissingColumnsError\nIf require_all_columns is True and result is missing required columns",
    "crumbs": [
      "API Reference",
      "Data Sources",
      "types.DataFrameSource"
    ]
  },
  {
    "objectID": "reference/types.ServerValues.html",
    "href": "reference/types.ServerValues.html",
    "title": "types.ServerValues",
    "section": "",
    "text": "types.ServerValues(df, sql, title, client)\nSession-specific reactive values and client returned by QueryChat.server().\nThis dataclass contains all the session-specific reactive state for a QueryChat instance. Each session gets its own ServerValues to ensure proper isolation between concurrent sessions.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\nCallable[[], pd.DataFrame]\nA reactive Calc that returns the current filtered data frame. If no SQL query has been set, this returns the unfiltered data from the data source. Call it like .df() to reactively read the current data frame.\n\n\nsql\nReactiveStringOrNone\nA reactive Value containing the current SQL query string. Access the value by calling .sql(), or set it with .sql.set(\"SELECT ...\"). Returns None if no query has been set.\n\n\ntitle\nReactiveStringOrNone\nA reactive Value containing the current title for the query. The LLM provides this title when generating a new SQL query. Access it with .title(), or set it with .title.set(\"...\"). Returns None if no title has been set.\n\n\nclient\nchatlas.Chat\nThe session-specific chat client instance. This is a deep copy of the base client configured for this specific session, containing the chat history and tool registrations for this session only.",
    "crumbs": [
      "API Reference",
      "Reactive values",
      "types.ServerValues"
    ]
  },
  {
    "objectID": "reference/types.ServerValues.html#attributes",
    "href": "reference/types.ServerValues.html#attributes",
    "title": "types.ServerValues",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndf\nCallable[[], pd.DataFrame]\nA reactive Calc that returns the current filtered data frame. If no SQL query has been set, this returns the unfiltered data from the data source. Call it like .df() to reactively read the current data frame.\n\n\nsql\nReactiveStringOrNone\nA reactive Value containing the current SQL query string. Access the value by calling .sql(), or set it with .sql.set(\"SELECT ...\"). Returns None if no query has been set.\n\n\ntitle\nReactiveStringOrNone\nA reactive Value containing the current title for the query. The LLM provides this title when generating a new SQL query. Access it with .title(), or set it with .title.set(\"...\"). Returns None if no title has been set.\n\n\nclient\nchatlas.Chat\nThe session-specific chat client instance. This is a deep copy of the base client configured for this specific session, containing the chat history and tool registrations for this session only.",
    "crumbs": [
      "API Reference",
      "Reactive values",
      "types.ServerValues"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html",
    "href": "reference/express.QueryChat.html",
    "title": "express.QueryChat",
    "section": "",
    "text": "express.QueryChat(\n    data_source,\n    table_name,\n    *,\n    id=None,\n    greeting=None,\n    client=None,\n    tools=('update', 'query'),\n    data_description=None,\n    categorical_threshold=20,\n    extra_instructions=None,\n    prompt_template=None,\n    enable_bookmarking='auto',\n)\nUse QueryChat with Shiny Express.\nThis class makes it easy to use querychat within Shiny Express apps – it automatically calls .server() during initialization, so you don’t have to do it manually.\n\n\nfrom querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import app_opts, render, ui\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.card(fill=True):\n    with ui.card_header():\n\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n\n\nui.page_opts(\n    title=\"Titanic QueryChat App\",\n    fillable=True,\n)\n\napp_opts(bookmark_store=\"url\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich querychat tools to include in the chat client by default. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to disable all tools Default is (\"update\", \"query\") (both tools enabled). Set to \"update\" to prevent the LLM from accessing data values, only allowing dashboard filtering without answering questions. The tools can be overridden per-client by passing a different tools parameter to the .client() method.\n('update', 'query')\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ndf\nReactively read the current filtered data frame that is in effect.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nsql\nReactively read (or set) the current SQL query that is in effect.\n\n\ntitle\nReactively read (or set) the current title that is in effect.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nexpress.QueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nexpress.QueryChat.cleanup()\nClean up resources associated with the data source.\nCall this method when you are done using the QueryChat object to close database connections and avoid resource leaks.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nexpress.QueryChat.client(\n    tools=MISSING,\n    update_dashboard=None,\n    reset_dashboard=None,\n)\nCreate a chat client with registered tools.\nThis method creates a standalone chat client configured with the specified tools and callbacks. Each call returns an independent client instance with its own conversation state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), uses the tools specified during initialization\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nOptional callback function to call when the update_dashboard tool succeeds. Takes a dict with \"query\" and \"title\" keys. Only used if \"update\" is in tools.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nOptional callback function to call when the tool_reset_dashboard is invoked. Takes no arguments. Only used if \"update\" is in tools.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client with tools registered based on the tools parameter.\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3]})\nqc = QueryChat(df, \"my_data\")\n\n# Create client with all tools (default)\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Create client with only query tool (single string)\nclient = qc.client(tools=\"query\")\n\n# Create client with only query tool (tuple)\nclient = qc.client(tools=(\"query\",))\n\n# Create client with custom callbacks\nfrom querychat import UpdateDashboardData\n\n\ndef my_update(data: UpdateDashboardData):\n    print(f\"Query: {data['query']}, Title: {data['title']}\")\n\n\nclient = qc.client(update_dashboard=my_update)\n\n\n\n\nexpress.QueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\nThis method provides a REPL (Read-Eval-Print Loop) interface for chatting with your data from the command line. The console session persists by default, so you can exit and return to continue your conversation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nbool\nIf True, creates a new chat client and starts a fresh conversation. If False (default), continues the conversation from the previous console session.\nFalse\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich tools to include: “update”, “query”, or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), defaults to (\"query\",) only for privacy (prevents the LLM from accessing data values) Ignored if new=False and a console session already exists.\n'query'\n\n\n**kwargs\n\nAdditional arguments passed to the client() method when creating a new client.\n{}\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Start console (query tool only by default)\nqc.console()\n\n# Start fresh console with all tools (using tuple)\nqc.console(new=True, tools=(\"update\", \"query\"))\n\n# Start fresh console with all tools (using single string for one tool)\nqc.console(new=True, tools=\"query\")\n\n# Continue previous console session\nqc.console()  # picks up where you left off\n\n\n\n\nexpress.QueryChat.df()\nReactively read the current filtered data frame that is in effect.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe current filtered data frame as a pandas DataFrame. If no query has been set, this will return the unfiltered data frame from the data source.\n\n\n\n\n\n\n\nexpress.QueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nexpress.QueryChat.sidebar(\n    width=400,\n    height='100%',\n    fillable=True,\n    id=None,\n    **kwargs,\n)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nexpress.QueryChat.sql(query=None)\nReactively read (or set) the current SQL query that is in effect.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nOptional[str]\nIf provided, sets the current SQL query to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no query is provided, returns the current SQL query as a string (or None if no query has been set). If a query is provided, returns True if the query was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.title(value=None)\nReactively read (or set) the current title that is in effect.\nThe title is a short description of the current query that the LLM provides to us whenever it generates a new SQL query. It can be used as a status string for the data dashboard.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nOptional[str]\nIf provided, sets the current title to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no value is provided, returns the current title as a string, or None if no title has been set due to no SQL query being set. If a value is provided, sets the current title to this value and returns True if the title was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#examples",
    "href": "reference/express.QueryChat.html#examples",
    "title": "express.QueryChat",
    "section": "",
    "text": "from querychat.express import QueryChat\nfrom seaborn import load_dataset\nfrom shiny.express import app_opts, render, ui\n\ntitanic = load_dataset(\"titanic\")\n\nqc = QueryChat(titanic, \"titanic\")\nqc.sidebar()\n\nwith ui.card(fill=True):\n    with ui.card_header():\n\n        @render.text\n        def title():\n            return qc.title() or \"Titanic Dataset\"\n\n    @render.data_frame\n    def data_table():\n        return qc.df()\n\n\nui.page_opts(\n    title=\"Titanic QueryChat App\",\n    fillable=True,\n)\n\napp_opts(bookmark_store=\"url\")",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#parameters",
    "href": "reference/express.QueryChat.html#parameters",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_source\nIntoFrame | sqlalchemy.Engine\nEither a Narwhals-compatible data frame (e.g., Polars or Pandas) or a SQLAlchemy engine containing the table to query against.\nrequired\n\n\ntable_name\nstr\nIf a data_source is a data frame, a name to use to refer to the table in SQL queries (usually the variable name of the data frame, but it doesn’t have to be). If a data_source is a SQLAlchemy engine, the table_name is the name of the table in the database to query against.\nrequired\n\n\nid\nOptional[str]\nAn optional ID for the QueryChat module. If not provided, an ID will be generated based on the table_name.\nNone\n\n\ngreeting\nOptional[str | Path]\nA string in Markdown format, containing the initial message. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text(). You can use querychat.greeting() to help generate a greeting from a querychat configuration. If no greeting is provided, one will be generated at the start of every new conversation.\nNone\n\n\nclient\nOptional[str | chatlas.Chat]\nA chatlas.Chat object or a string to be passed to chatlas.ChatAuto()’s provider_model parameter, describing the provider and model combination to use (e.g. \"openai/gpt-4.1\", “anthropic/claude-sonnet-4-5”, “google/gemini-2.5-flash”. etc). If client is not provided, querychat consults the QUERYCHAT_CLIENT environment variable. If that is not set, it defaults to \"openai\".\nNone\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich querychat tools to include in the chat client by default. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to disable all tools Default is (\"update\", \"query\") (both tools enabled). Set to \"update\" to prevent the LLM from accessing data values, only allowing dashboard filtering without answering questions. The tools can be overridden per-client by passing a different tools parameter to the .client() method.\n('update', 'query')\n\n\ndata_description\nOptional[str | Path]\nDescription of the data in plain text or Markdown. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\ncategorical_threshold\nint\nThreshold for determining if a column is categorical based on number of unique values.\n20\n\n\nextra_instructions\nOptional[str | Path]\nAdditional instructions for the chat model. If a pathlib.Path object is passed, querychat will read the contents of the path into a string with .read_text().\nNone\n\n\nprompt_template\nOptional[str | Path]\nPath to or a string of a custom prompt file. If not provided, the default querychat template will be used. This should be a Markdown file that contains the system prompt template. The mustache template can use the following variables: - {db_engine}: The database engine used (e.g., “DuckDB”) - {schema}: The schema of the data source, generated by data_source.get_schema() - {data_description}: The optional data description provided - {extra_instructions}: Any additional instructions provided\nNone",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#attributes",
    "href": "reference/express.QueryChat.html#attributes",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_source\nGet the current data source.\n\n\nsystem_prompt\nGet the system prompt.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "reference/express.QueryChat.html#methods",
    "href": "reference/express.QueryChat.html#methods",
    "title": "express.QueryChat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napp\nQuickly chat with a dataset.\n\n\ncleanup\nClean up resources associated with the data source.\n\n\nclient\nCreate a chat client with registered tools.\n\n\nconsole\nLaunch an interactive console chat with the data.\n\n\ndf\nReactively read the current filtered data frame that is in effect.\n\n\ngenerate_greeting\nGenerate a welcome greeting for the chat.\n\n\nsidebar\nCreate a sidebar containing the querychat UI.\n\n\nsql\nReactively read (or set) the current SQL query that is in effect.\n\n\ntitle\nReactively read (or set) the current title that is in effect.\n\n\nui\nCreate the UI for the querychat component.\n\n\n\n\n\nexpress.QueryChat.app(bookmark_store='url')\nQuickly chat with a dataset.\nCreates a Shiny app with a chat sidebar and data table view – providing a quick-and-easy way to start chatting with your data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbookmark_store\nLiteral['url', 'server', 'disable']\nThe bookmarking store to use for the Shiny app. Options are: - \"url\": Store bookmarks in the URL (default). - \"server\": Store bookmarks on the server. - \"disable\": Disable bookmarking.\n'url'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nApp\nA Shiny App object that can be run with app.run() or served with shiny run.\n\n\n\n\n\n\n\nexpress.QueryChat.cleanup()\nClean up resources associated with the data source.\nCall this method when you are done using the QueryChat object to close database connections and avoid resource leaks.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nexpress.QueryChat.client(\n    tools=MISSING,\n    update_dashboard=None,\n    reset_dashboard=None,\n)\nCreate a chat client with registered tools.\nThis method creates a standalone chat client configured with the specified tools and callbacks. Each call returns an independent client instance with its own conversation state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None | MISSING_TYPE\nWhich tools to include: \"update\", \"query\", or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), uses the tools specified during initialization\nMISSING\n\n\nupdate_dashboard\nCallable[[UpdateDashboardData], None] | None\nOptional callback function to call when the update_dashboard tool succeeds. Takes a dict with \"query\" and \"title\" keys. Only used if \"update\" is in tools.\nNone\n\n\nreset_dashboard\nCallable[[], None] | None\nOptional callback function to call when the tool_reset_dashboard is invoked. Takes no arguments. Only used if \"update\" is in tools.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nchatlas.Chat\nA configured chat client with tools registered based on the tools parameter.\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3]})\nqc = QueryChat(df, \"my_data\")\n\n# Create client with all tools (default)\nclient = qc.client()\nresponse = client.chat(\"What's the average of column a?\")\n\n# Create client with only query tool (single string)\nclient = qc.client(tools=\"query\")\n\n# Create client with only query tool (tuple)\nclient = qc.client(tools=(\"query\",))\n\n# Create client with custom callbacks\nfrom querychat import UpdateDashboardData\n\n\ndef my_update(data: UpdateDashboardData):\n    print(f\"Query: {data['query']}, Title: {data['title']}\")\n\n\nclient = qc.client(update_dashboard=my_update)\n\n\n\n\nexpress.QueryChat.console(new=False, tools='query', **kwargs)\nLaunch an interactive console chat with the data.\nThis method provides a REPL (Read-Eval-Print Loop) interface for chatting with your data from the command line. The console session persists by default, so you can exit and return to continue your conversation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nbool\nIf True, creates a new chat client and starts a fresh conversation. If False (default), continues the conversation from the previous console session.\nFalse\n\n\ntools\nTOOL_GROUPS | tuple[TOOL_GROUPS, …] | None\nWhich tools to include: “update”, “query”, or both. Can be: - A single tool string: \"update\" or \"query\" - A tuple of tools: (\"update\", \"query\") - None or () to skip adding any tools - If not provided (default), defaults to (\"query\",) only for privacy (prevents the LLM from accessing data values) Ignored if new=False and a console session already exists.\n'query'\n\n\n**kwargs\n\nAdditional arguments passed to the client() method when creating a new client.\n{}\n\n\n\n\n\n\nfrom querychat import QueryChat\nimport pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nqc = QueryChat(df, \"my_data\")\n\n# Start console (query tool only by default)\nqc.console()\n\n# Start fresh console with all tools (using tuple)\nqc.console(new=True, tools=(\"update\", \"query\"))\n\n# Start fresh console with all tools (using single string for one tool)\nqc.console(new=True, tools=\"query\")\n\n# Continue previous console session\nqc.console()  # picks up where you left off\n\n\n\n\nexpress.QueryChat.df()\nReactively read the current filtered data frame that is in effect.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nThe current filtered data frame as a pandas DataFrame. If no query has been set, this will return the unfiltered data frame from the data source.\n\n\n\n\n\n\n\nexpress.QueryChat.generate_greeting(echo='none')\nGenerate a welcome greeting for the chat.\nBy default, QueryChat() generates a greeting at the start of every new conversation, which is convenient for getting started and development, but also might add unnecessary latency and cost. Use this method to generate a greeting once and save it for reuse.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nLiteral['none', 'output']\nIf echo = \"output\", prints the greeting to standard output. If echo = \"none\" (default), does not print anything.\n'none'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe greeting string (in Markdown format).\n\n\n\n\n\n\n\nexpress.QueryChat.sidebar(\n    width=400,\n    height='100%',\n    fillable=True,\n    id=None,\n    **kwargs,\n)\nCreate a sidebar containing the querychat UI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nWidth of the sidebar in pixels.\n400\n\n\nheight\nstr\nHeight of the sidebar.\n'100%'\n\n\nfillable\nbool\nWhether the sidebar should be fillable. Default is True.\nTrue\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments passed to shiny.ui.sidebar().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nui.Sidebar\nA sidebar UI component.\n\n\n\n\n\n\n\nexpress.QueryChat.sql(query=None)\nReactively read (or set) the current SQL query that is in effect.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nOptional[str]\nIf provided, sets the current SQL query to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no query is provided, returns the current SQL query as a string (or None if no query has been set). If a query is provided, returns True if the query was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.title(value=None)\nReactively read (or set) the current title that is in effect.\nThe title is a short description of the current query that the LLM provides to us whenever it generates a new SQL query. It can be used as a status string for the data dashboard.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nOptional[str]\nIf provided, sets the current title to this value.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None | bool\nIf no value is provided, returns the current title as a string, or None if no title has been set due to no SQL query being set. If a value is provided, sets the current title to this value and returns True if the title was changed to a new value, or False if it was the same as the current value.\n\n\n\n\n\n\n\nexpress.QueryChat.ui(id=None, **kwargs)\nCreate the UI for the querychat component.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nOptional[str]\nOptional ID for the QueryChat instance. If not provided, will use the ID provided at initialization.\nNone\n\n\n**kwargs\n\nAdditional arguments to pass to shinychat.chat_ui().\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA UI component.",
    "crumbs": [
      "API Reference",
      "The QueryChat class",
      "express.QueryChat"
    ]
  },
  {
    "objectID": "tools.html",
    "href": "tools.html",
    "title": "Tools",
    "section": "",
    "text": "querychat combines tool calling with reactivity to not only execute SQL, but also reactively update dependent data views. Understanding how these tools work will help you better understand what querychat is capable of and how to customize/extend to its behavior.\nOne important thing to understand generally about querychat’s tools is they are Python functions, and that execution happens on your machine, not on the LLM provider’s side. In other words, the SQL queries generated by the LLM are executed locally in the Python process running the app.\nquerychat provides the LLM access two tool groups:",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#data-updating",
    "href": "tools.html#data-updating",
    "title": "Tools",
    "section": "Data updating",
    "text": "Data updating\nWhen a user asks to “Show me…” or “Filter to…” or “Sort by…”, the LLM requests a call to the update_dashboard tool with an appropriate SQL query as input. An important constraint is that the query must return all original schema columns (typically using SELECT *). When called, querychat will both set a reactive value holding the current SQL query and execute the query to get the result. The result of query then used to set a reactive value holding the filtered/sorted data frame. Thanks to reactivity, this will automatically update any views depending on this data frame, such as the data table displayed in the UI.\nThis tool also takes a title parameter, which is a short description of the filter/sort operation (e.g., “First-class passengers”). This, also, is made available through a reactive value for display somewhere in your app.\nHere’s a basic example of this tool in action with the .app() method. Notice how this pre-built app not only shows the data table, but also the SQL query and title generated by the LLM (for transparency):\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()\n\n\nThe other data updating tool is reset_dashboard, which clears any active filters and returns the data table to its original unfiltered state. The LLM typically uses this when users say “reset”, “start over”, or “clear filters”.",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#data-analysis",
    "href": "tools.html#data-analysis",
    "title": "Tools",
    "section": "Data analysis",
    "text": "Data analysis\nWhen a user asks analytical questions like “What is the average…?”, “How many…?”, or “Which item has the highest…?”, the LLM generates a SQL query and requests a call to the query tool. Unlike the data updating tools, this tool will not update any reactive values. Instead, it will:\n\nExecute the SQL query\nDisplay both the SQL query and results in the UI\nReturn the results back to the LLM for interpretation\n\nHere’s an example of it in action:\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\n\nqc = QueryChat(titanic(), \"titanic\")\napp = qc.app()",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "tools.html#view-the-source",
    "href": "tools.html#view-the-source",
    "title": "Tools",
    "section": "View the source",
    "text": "View the source\nIf you’d like to better understand how the tools work and how the LLM is prompted to use them, check out the following resources:\nSource code:\n\ntools.py\n\nPrompts:\n\nprompts/tool-update-dashboard.md\nprompts/tool-reset-dashboard.md\nprompts/tool-query.md",
    "crumbs": [
      "Overview",
      "Tools"
    ]
  },
  {
    "objectID": "greet.html",
    "href": "greet.html",
    "title": "Greet users",
    "section": "",
    "text": "Provide a greeting\nWhen the querychat UI first appears, you will usually want it to greet the user with some basic instructions. By default, these instructions are auto-generated every time a user arrives. In a production setting with multiple users/visitors, this approach has some downsides: it’s slower, uses more API tokens, and produces different results each time. Instead, you should create a greeting file and pass it when creating your QueryChat object:\n\n\ntitanic-app.py\n\nfrom querychat import QueryChat\nfrom querychat.data import titanic\nfrom pathlib import Path\n\napp_dir = Path(__file__).parent\n\nqc = QueryChat(titanic(), \"titanic\", greeting=app_dir / \"greeting.md\")\napp = qc.app()\n\nYou can provide suggestions to the user by using the &lt;span class=\"suggestion\"&gt; &lt;/span&gt; tag:\n* **Filter and sort the data:**\n  * &lt;span class=\"suggestion\"&gt;Show only survivors&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;Filter to first class passengers under 30&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;Sort by fare from highest to lowest&lt;/span&gt;\n\n* **Answer questions about the data:**\n  * &lt;span class=\"suggestion\"&gt;What was the survival rate by gender?&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;What's the average age of children who survived?&lt;/span&gt;\n  * &lt;span class=\"suggestion\"&gt;How many passengers were traveling alone?&lt;/span&gt;\nThese suggestions appear in the greeting and automatically populate the chat text box when clicked. You can see this behavior in our querychat template.\n\n\nGenerate a greeting\nIf you need help coming up with a greeting, you can use the .generate_greeting() method:\n\n\npenguins-greeting.py\n\nfrom palmerpenguins import load_penguins\nfrom querychat import QueryChat\nfrom pathlib import Path\n\n# Create QueryChat object with your dataset\nqc = QueryChat(load_penguins(), \"penguins\")\n\n# Generate a greeting (this calls the LLM)\ngreeting_text = qc.generate_greeting()\n#&gt; Hello! I'm here to help you explore and analyze the penguins dataset.\n#&gt; Here are some example prompts you can try:\n#&gt; ...\n\n# Save it for reuse\nwith open(\"penguins_greeting.md\", \"w\") as f:\n    f.write(greeting_text)\n\nThis approach generates a greeting once and saves it for reuse, avoiding the latency and cost of generating it for every user.\n\n\npenguins-app.py\n\nfrom palmerpenguins import load_penguins\nfrom querychat import QueryChat\nfrom pathlib import Path\n\n# Then use the saved greeting in your app\napp_dir = Path(__file__).parent\nqc = QueryChat(\n  load_penguins(), \n  \"penguins\", \n  greeting=app_dir / \"penguins_greeting.md\",\n)\napp = qc.app()",
    "crumbs": [
      "Overview",
      "Greet users"
    ]
  }
]