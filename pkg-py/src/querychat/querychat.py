from __future__ import annotations

import copy
import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable, Literal, Optional, Union, overload

import chevron
import shinychat
import sqlalchemy
from shiny import Inputs, Outputs, Session, module, reactive, ui

from ._utils import normalize_client
from .tools import tool_query, tool_reset_dashboard, tool_update_dashboard

if TYPE_CHECKING:
    import chatlas
    import pandas as pd
    from narwhals.stable.v1.typing import IntoFrame

from .datasource import DataFrameSource, DataSource, SQLAlchemySource


@dataclass
class QueryChatConfig:
    """
    Configuration class for querychat.

    Warning:
    -------
    This class only exists as the return value of `init()`, which is deprecated,
    and so will likely be removed in a future release. New code should use the
    QueryChat.

    """

    data_source: DataSource
    system_prompt: str
    greeting: Optional[str]
    client: chatlas.Chat


ReactiveString = reactive.Value[str]
"""A reactive string value."""
ReactiveStringOrNone = reactive.Value[Union[str, None]]
"""A reactive string (or None) value."""


class QueryChat:
    """
    Create a QueryChat object representing (one or more) chat sessions.
    """

    def __init__(
        self,
        data_source: IntoFrame | sqlalchemy.Engine,
        table_name: str,
        *,
        greeting: Optional[str | Path] = None,
        client: Optional[Union[str, chatlas.Chat]] = None,
        data_description: Optional[str | Path] = None,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ):
        """
        Initialize querychat with any compliant data source.

        Parameters
        ----------
        data_source
            Either a Narwhals-compatible data frame (e.g., Polars or Pandas) or a
            SQLAlchemy engine containing the table to query against.
        table_name
            If a data_source is a data frame, a name to use to refer to the table in
            SQL queries (usually the variable name of the data frame, but it doesn't
            have to be). If a data_source is a SQLAlchemy engine, the table_name is
            the name of the table in the database to query against.
        greeting
            A string in Markdown format, containing the initial message. If a
            pathlib.Path object is passed, querychat will read the contents of the
            path into a string with `.read_text()`. You can use
            `querychat.greeting()` to help generate a greeting from a querychat
            configuration. If no greeting is provided, one will be generated at the
            start of every new conversation.
        client
            A `chatlas.Chat` object, a string to be passed to `chatlas.ChatAuto()`
            describing the model to use (e.g. `"openai/gpt-4.1"`), or a function
            that creates a chat client. If using a function, the function should
            accept a `system_prompt` argument and return a `chatlas.Chat` object.

            If `client` is not provided, querychat consults the `QUERYCHAT_CLIENT`
            environment variable, which can be set to a provider-model string. If no
            option is provided, querychat defaults to using
            `chatlas.ChatOpenAI(model="gpt-4.1")`.
        data_description
            Description of the data in plain text or Markdown. If a pathlib.Path
            object is passed, querychat will read the contents of the path into a
            string with `.read_text()`.
        extra_instructions
            Additional instructions for the chat model. If a pathlib.Path object is
            passed, querychat will read the contents of the path into a string with
            `.read_text()`.
        prompt_template
            Path to or a string of a custom prompt file. If not provided, the default querychat
            template will be used. This should be a Markdown file that contains the
            system prompt template. The mustache template can use the following
            variables:
            - `{{db_engine}}`: The database engine used (e.g., "DuckDB")
            - `{{schema}}`: The schema of the data source, generated by
              `data_source.get_schema()`
            - `{{data_description}}`: The optional data description provided
            - `{{extra_instructions}}`: Any additional instructions provided

        """
        config = init(
            data_source,
            table_name,
            client=client,
            greeting=greeting,
            data_description=data_description,
            extra_instructions=extra_instructions,
            prompt_template=prompt_template,
        )
        self.data_source = config.data_source
        self.system_prompt = config.system_prompt
        self.greeting = config.greeting
        self.client = config.client

    def sidebar(
        self,
        id: str,
        *,
        width: int = 400,
        height: str = "100%",
        **kwargs,
    ) -> ui.Sidebar:
        """
        Create a sidebar containing the querychat UI.

        Parameters
        ----------
        id
            The module ID.
        width
            Width of the sidebar in pixels.
        height
            Height of the sidebar.
        **kwargs
            Additional arguments passed to `shiny.ui.sidebar()`.

        Returns
        -------
        :
            A sidebar UI component.

        """
        return sidebar(
            id,
            width=width,
            height=height,
            **kwargs,
        )

    def ui(self, id: str, **kwargs):
        """
        Create the UI for the querychat component.

        Parameters
        ----------
        id
            The querychat UI component ID.
        **kwargs
            Additional arguments to pass to `shinychat.chat_ui()`.

        Returns
        -------
        :
            A UI component.

        """
        return mod_ui(id, **kwargs)

    def server(self, id: str):
        """
        Initialize the querychat server logic.

        Parameters
        ----------
        id
            An ID corresponding to the UI component.

        Returns
        -------
        :
            A QueryChatSession object, providing access to important reactive
            values like the filtered data frame and current SQL query.

        """
        config = QueryChatConfig(
            data_source=self.data_source,
            system_prompt=self.system_prompt,
            greeting=self.greeting,
            client=self.client,
        )
        return mod_server(id, querychat_config=config)

    def generate_greeting(self, *, echo: Literal["none", "text"] = "none"):
        """
        Generate a welcome greeting for the chat.

        By default, `QueryChat()` generates a greeting at the start of every new
        conversation, which is convenient for getting started and development,
        but also might add unnecessary latency and cost. Use this method to
        generate a greeting once and save it for reuse.

        Parameters
        ----------
        echo
            If `echo = "text"`, prints the greeting to standard output. If
            `echo = "none"` (default), does not print anything.

        Returns
        -------
        :
            The greeting string (in Markdown format).

        Examples
        --------
        ```python
        import polars as pl
        from querychat import QueryChat

        # First, create a QueryChat object with your data
        mtcars = pl.read_csv(
            "https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv"
        )
        qc = QueryChat(mtcars, "mtcars")

        # Then, generate a greeting, and save it for future use
        greeting_text = qc.generate_greeting()
        with open("mtcars_greeting.md", "w") as f:
            f.write(greeting_text)
        ```

        Now with the saved greeting, you can create a new QueryChat object

        ```python
        import pandas as pd
        from querychat import QueryChat

        # Create QueryChat object with mtcars dataset
        mtcars = pd.read_csv(
            "https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv"
        )
        with open("mtcars_greeting.md", "r") as f:
            greeting_text = f.read()

        # Use our saved greeting
        qc = QueryChat(mtcars, "mtcars", greeting=greeting_text)
        ```

        """
        client = copy.deepcopy(self.client)
        client.system_prompt = self.system_prompt
        prompt = "Please give me a friendly greeting. Include a few sample prompts in a two-level bulleted list."
        return str(client.chat(prompt, echo=echo))

    def set_system_prompt(
        self,
        data_source: DataSource,
        *,
        data_description: Optional[str | Path] = None,
        extra_instructions: Optional[str | Path] = None,
        categorical_threshold: int = 10,
        prompt_template: Optional[str | Path] = None,
    ) -> None:
        """
        Customize the system prompt.

        Control the logic behind how the system prompt is generated based on the
        data source's schema and optional additional context and instructions.

        NOTE
        ----
        This method is for parametrized system prompt generation only. To set a
        fully custom system prompt string, set the `system_prompt` attribute
        directly.

        Parameters
        ----------
        data_source
            A data source to generate schema information from
        data_description
            Optional description of the data, in plain text or Markdown format
        extra_instructions
            Optional additional instructions for the chat model, in plain text or
            Markdown format
        categorical_threshold
            Threshold for determining if a column is categorical based on number of
            unique values
        prompt_template
            Optional `Path` to or string of a custom prompt template. If not provided, the default
            querychat template will be used.

        Returns
        -------
        :
            The system prompt for the chat model.


        """
        self.system_prompt = system_prompt(
            data_source,
            data_description=data_description,
            extra_instructions=extra_instructions,
            categorical_threshold=categorical_threshold,
            prompt_template=prompt_template,
        )

    def set_data_source(
        self, data_source: IntoFrame | sqlalchemy.Engine | DataSource, table_name: str
    ) -> None:
        """
        Set a new data source for the QueryChat object.

        Parameters
        ----------
        data_source
            The new data source to use.
        table_name
            If a data_source is a data frame, a name to use to refer to the table

        Returns
        -------
        :
            None

        """
        self.data_source = _normalize_data_source(data_source, table_name)

    def set_client(self, client: Union[str, chatlas.Chat]) -> None:
        """
        Set a new chat client for the QueryChat object.

        Parameters
        ----------
        client
            A `chatlas.Chat` object or a string to be passed to
            `chatlas.ChatAuto()` describing the model to use (e.g.
            `"openai/gpt-4.1"`).

        Returns
        -------
        :
            None

        """
        self.client = normalize_client(client)


class QueriedValues:
    """
    Access (reactive) state from an active query chat session.

    Provides information about a chat session, such as the current SQL query,
    title, filtered data frame, chat history, etc.
    """

    def __init__(
        self,
        df: Callable[[], pd.DataFrame],
        sql: ReactiveString,
        title: ReactiveStringOrNone,
        chat: chatlas.Chat,
    ):
        """
        Initialize a QueriedValues object.

        Parameters
        ----------
        df
            Reactively read the current filtered data frame
        sql
            Reactively read (or set) the current SQL query
        title
            Reactively read (or set) the current title
        chat
            The chat object for the session

        """
        self._df = df
        self._sql = sql
        self._title = title
        self._chat = chat

    def df(self) -> pd.DataFrame:
        """
        Reactively read the current filtered data frame that is in effect.

        Returns
        -------
        :
            The current filtered data frame as a pandas DataFrame. If no query
            has been set, this will return the unfiltered data frame from the
            data source.

        """
        return self._df()

    @overload
    def sql(self, query: None = None) -> str: ...

    @overload
    def sql(self, query: str) -> bool: ...

    def sql(self, query: Optional[str] = None) -> str | bool:
        """
        Reactively read (or set) the current SQL query that is in effect.

        Parameters
        ----------
        query
            If provided, sets the current SQL query to this value.

        Returns
        -------
        :
            If no `query` is provided, returns the current SQL query as a string
            (possibly `""` if no query has been set). If a `query` is provided,
            returns `True` if the query was changed to a new value, or `False`
            if it was the same as the current value.

        """
        if query is None:
            return self._sql()
        else:
            return self._sql.set(query)

    @overload
    def title(self, value: None = None) -> str | None: ...

    @overload
    def title(self, value: str) -> bool: ...

    def title(self, value: Optional[str] = None) -> str | None | bool:
        """
        Reactively read (or set) the current title that is in effect.

        The title is a short description of the current query that the LLM
        provides to us whenever it generates a new SQL query. It can be used as
        a status string for the data dashboard.

        Returns
        -------
        :
            If no `value` is provided, returns the current title as a string, or
            `None` if no title has been set due to no SQL query being set. If a
            `value` is provided, sets the current title to this value and
            returns `True` if the title was changed to a new value, or `False`
            if it was the same as the current value.

        """
        if value is None:
            return self._title()
        else:
            return self._title.set(value)

    def chat(self) -> chatlas.Chat:
        """
        Get the chat object for this session.

        Returns
        -------
        :
            The chat object

        """
        return self._chat

    def __getitem__(self, key: str) -> Any:
        """
        Allow access to configuration parameters like a dictionary. For
        backwards compatibility only; new code should use the attributes
        directly instead.
        """
        return {
            "chat": self.chat,
            "sql": self.sql,
            "title": self.title,
            "df": self.df,
        }.get(key)


def system_prompt(
    data_source: DataSource,
    *,
    data_description: Optional[str | Path] = None,
    extra_instructions: Optional[str | Path] = None,
    categorical_threshold: int = 10,
    prompt_template: Optional[str | Path] = None,
) -> str:
    """
    Create a system prompt for the chat model based on a data source's schema
    and optional additional context and instructions.

    **Deprecated.** Use `QueryChat.set_system_prompt()` instead.
    """
    # Read the prompt file
    if prompt_template is None:
        # Default to the prompt file in the same directory as this module
        # This allows for easy customization by placing a different prompt.md file there
        prompt_template = Path(__file__).parent / "prompts" / "prompt.md"
    prompt_str = (
        prompt_template.read_text()
        if isinstance(prompt_template, Path)
        else prompt_template
    )

    data_description_str = (
        data_description.read_text()
        if isinstance(data_description, Path)
        else data_description
    )

    extra_instructions_str = (
        extra_instructions.read_text()
        if isinstance(extra_instructions, Path)
        else extra_instructions
    )

    is_duck_db = data_source.get_db_type().lower() == "duckdb"

    return chevron.render(
        prompt_str,
        {
            "db_type": data_source.get_db_type(),
            "is_duck_db": is_duck_db,
            "schema": data_source.get_schema(
                categorical_threshold=categorical_threshold,
            ),
            "data_description": data_description_str,
            "extra_instructions": extra_instructions_str,
        },
    )


def init(
    data_source: IntoFrame | sqlalchemy.Engine,
    table_name: str,
    *,
    greeting: Optional[str | Path] = None,
    data_description: Optional[str | Path] = None,
    extra_instructions: Optional[str | Path] = None,
    prompt_template: Optional[str | Path] = None,
    system_prompt_override: Optional[str] = None,
    client: Optional[Union[chatlas.Chat, str]] = None,
) -> QueryChatConfig:
    """
    Initialize querychat with any compliant data source.

    **Deprecated.** Use `QueryChat()` instead.
    """
    resolved_client = normalize_client(client)

    # Validate table name (must begin with letter, contain only letters, numbers, underscores)
    if not re.match(r"^[a-zA-Z][a-zA-Z0-9_]*$", table_name):
        raise ValueError(
            "Table name must begin with a letter and contain only letters, numbers, and underscores",
        )

    data_source_obj = _normalize_data_source(data_source, table_name)

    # Process greeting
    if greeting is None:
        print(
            "Warning: No greeting provided; the LLM will be invoked at conversation start to generate one. "
            "For faster startup, lower cost, and determinism, please save a greeting and pass it to init().",
            "You can also use `querychat.greeting()` to help generate a greeting.",
            file=sys.stderr,
        )

    # quality of life improvement to do the Path.read_text() for user or pass along the string
    greeting_str = greeting.read_text() if isinstance(greeting, Path) else greeting

    # Create the system prompt, or use the override
    if isinstance(system_prompt_override, Path):
        system_prompt_ = system_prompt_override.read_text()
    else:
        system_prompt_ = system_prompt_override or system_prompt(
            data_source_obj,
            data_description=data_description,
            extra_instructions=extra_instructions,
            prompt_template=prompt_template,
        )

    return QueryChatConfig(
        data_source=data_source_obj,
        system_prompt=system_prompt_,
        greeting=greeting_str,
        client=resolved_client,
    )


def _normalize_data_source(
    data_source: IntoFrame | sqlalchemy.Engine | DataSource,
    table_name: str,
) -> DataSource:
    if isinstance(data_source, DataSource):
        return data_source
    if isinstance(data_source, sqlalchemy.Engine):
        return SQLAlchemySource(data_source, table_name)
    return DataFrameSource(data_source, table_name)


@module.ui
def mod_ui(**kwargs) -> ui.TagList:
    """
    Create the UI for the querychat component.

    **Deprecated.** Use `QueryChat.ui()` instead.
    """
    # Include CSS and JS
    css_path = Path(__file__).parent / "static" / "css" / "styles.css"
    js_path = Path(__file__).parent / "static" / "js" / "querychat.js"

    tag = shinychat.chat_ui("chat", **kwargs)
    tag.add_class("querychat")

    return ui.TagList(
        ui.head_content(
            ui.include_css(css_path),
            ui.include_js(js_path),
        ),
        tag,
    )


def sidebar(
    id: str,
    width: int = 400,
    height: str = "100%",
    **kwargs,
) -> ui.Sidebar:
    """
    Create a sidebar containing the querychat UI.

    **Deprecated.** Use `QueryChat.sidebar()` instead.
    """
    return ui.sidebar(
        mod_ui(id),
        width=width,
        height=height,
        class_="querychat-sidebar",
        **kwargs,
    )


@module.server
def mod_server(
    input: Inputs,
    output: Outputs,
    session: Session,
    querychat_config: QueryChatConfig,
) -> QueriedValues:
    """
    Initialize the querychat server.

    **Deprecated.** Use `QueryChat.server()` instead.
    """
    # Extract config parameters
    data_source = querychat_config.data_source
    system_prompt = querychat_config.system_prompt
    greeting = querychat_config.greeting
    client = querychat_config.client

    # Reactive values to store state
    current_title = ReactiveStringOrNone(None)
    current_query = ReactiveString("")

    @reactive.calc
    def filtered_df():
        if current_query.get() == "":
            return data_source.get_data()
        else:
            return data_source.execute_query(current_query.get())

    # Create the tool functions
    update_dashboard_tool = tool_update_dashboard(
        data_source,
        current_query,
        current_title,
    )
    reset_dashboard_tool = tool_reset_dashboard(
        current_query,
        current_title,
    )
    query_tool = tool_query(data_source)

    chat_ui = shinychat.Chat("chat")

    # Set up the chat object for this session
    chat = copy.deepcopy(client)
    chat.set_turns([])
    chat.system_prompt = system_prompt

    # Register tools with annotations for the UI
    chat.register_tool(update_dashboard_tool)
    chat.register_tool(query_tool)
    chat.register_tool(reset_dashboard_tool)

    # Handle user input
    @chat_ui.on_user_submit
    async def _(user_input: str):
        stream = await chat.stream_async(user_input, echo="none", content="all")
        await chat_ui.append_message_stream(stream)

    # Handle update button clicks
    @reactive.effect
    @reactive.event(input.chat_update)
    def _():
        update = input.chat_update()
        if update is None:
            return
        if not isinstance(update, dict):
            return

        query = update.get("query")
        title = update.get("title")
        if query is not None:
            current_query.set(query)
        if title is not None:
            current_title.set(title)

    @reactive.effect
    async def greet_on_startup():
        if querychat_config.greeting:
            await chat_ui.append_message(greeting)
        elif querychat_config.greeting is None:
            stream = await chat.stream_async(
                "Please give me a friendly greeting. Include a few sample prompts in a two-level bulleted list.",
                echo="none",
            )
            await chat_ui.append_message_stream(stream)

    # Return the interface for other components to use
    return QueriedValues(filtered_df, current_query, current_title, chat)
